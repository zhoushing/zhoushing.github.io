<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2021-09-25T03:48:10.918Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树中的最大路径和</title>
    <link href="http://zhoushing.github.io/2021-09-25-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.html"/>
    <id>http://zhoushing.github.io/2021-09-25-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.html</id>
    <published>2021-09-25T03:41:22.000Z</published>
    <updated>2021-09-25T03:48:10.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-124-二叉树中的最大路径和"><a href="#力扣-124-二叉树中的最大路径和" class="headerlink" title="力扣 124. 二叉树中的最大路径和"></a>力扣 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/exx1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/exx2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以递归尝试链接路径，并将分支总值较大的分支传回给上级</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * 二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归寻找线路</span></span><br><span class="line">        getMax(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无节点可连接</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边的链路</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, getMax(node.left));</span><br><span class="line">        <span class="comment">// 右边的链路</span></span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, getMax(node.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录链路最大值，这里 node.val + left + right 代表着一条完整链路</span></span><br><span class="line">        result = Math.max(result, node.val + left + right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择左右链路的较大值与当前节点链接并返回 Math.max(left, right) + node.val </span></span><br><span class="line">        <span class="comment">// 代表着当前节点构成的链路一边</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210925114543145.png" alt="image-20210925114543145"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-124-二叉树中的最大路径和&quot;&gt;&lt;a href=&quot;#力扣-124-二叉树中的最大路径和&quot; class=&quot;headerlink&quot; title=&quot;力扣 124. 二叉树中的最大路径和&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="递归" scheme="http://zhoushing.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>环形链表II</title>
    <link href="http://zhoushing.github.io/2021-09-24-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html"/>
    <id>http://zhoushing.github.io/2021-09-24-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</id>
    <published>2021-09-24T07:21:10.000Z</published>
    <updated>2021-09-24T07:24:29.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-142-环形链表-II"><a href="#力扣-142-环形链表-II" class="headerlink" title="力扣 142. 环形链表 II"></a>力扣 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 10^4]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以直接用双指针进行追击，如果通过起点和追击点来确定环入口</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 追击成功</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode temp = head;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从起点和追击点同时出发，相遇点为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (temp != fast) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210924152354346.png" alt="image-20210924152354346"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-142-环形链表-II&quot;&gt;&lt;a href=&quot;#力扣-142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 142. 环形链表 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>初识计算机网络</title>
    <link href="http://zhoushing.github.io/2021-09-23-%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <id>http://zhoushing.github.io/2021-09-23-%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</id>
    <published>2021-09-23T06:46:06.000Z</published>
    <updated>2021-09-23T10:10:01.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    随着时代的发展，计算机已经对我们社会和生活产生了深远的影响。计算机相关技术也被应用于各种各样的领域，有些人因此提出了“20世纪最伟大的发明就是计算机”。在笔者看来，到21世纪甚至以后的世界，计算机也会产生巨大的作用。</p><p>​    前段时间的华为的鸿蒙系统比较火，而鸿蒙系统就是打通手机、电脑、平板、电视、汽车和智能穿戴等多种设备的统一操作系统。</p><p>​    “万物互联时代，没有人会是一座孤岛。无论经历多大的困难，华为为全球消费者提供更好的用户体验、更好的产品的决心不会改变。我们希望与更多合作伙伴、开发者共同繁荣鸿蒙生态，为全球消费者提供更好的体验、更好的产品、更好的服务。”华为常务董事、消费者业务CEO余承东在发布会接近尾声时上台致辞说了这样一段话。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923151609804.png" alt="image-20210923151609804"></p><p>​    上图就是新一代物联网应用场景图，想必读者很直观的可以看到万物互联时代带来的便利和美好，而今天我们就来聊聊最开始的“互联”——计算机互联。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>​    最开始的时候，计算机总是以单机模式被广泛使用。但是随着计算机技术的不断发展，人们就不满足于只能单机工作的计算机了，可能是一段迫切分享的信息，可能是一件需要协调的工作，导致了计算机互联的诞生。一台台计算机的连接，最后构成了网络状的计算机联系，这就形成了最早的计算机网络。</p><p>​    <a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>，在维基百科中，将其称为是指容许<a href="https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9_(%E7%94%B5%E4%BF%A1%E7%BD%91%E7%BB%9C)">节点</a>分享资源的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字</a>电信网络。笔者认为计算机网络正如其名，由计算机设备或者其他电子设备组成的一个网络状的连接关系。随着互联网的爆发式发展和普及，信息网络已经随处可见，现如今的计算机网络也发展成了一个庞大的体系了。</p><p>​    一个体系的诞生通常伴随着各种规范和协议的诞生，谈及计算机网络，就不得不谈最家喻户晓的 <code>OSI</code> 模型和 <code>TCP/IP</code>模型。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h3><p>​    <code>OSI</code> 模型是由<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p>​    从下图可以看出该模型将通信系统中的数据流划分为七个层。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923153708838.png" alt="image-20210923153708838"></p><h3 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h3><p>​    如下图所示 <code>TCP/IP</code> 模型只有四层，相当于 <code>OSI</code> 模型中应用、表示和会话层合并成应用层，数据链路层和物理层合并为网络接口层，TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923154023773.png" alt="image-20210923154023773"></p><p>​    <strong>TCP/IP 参考模型</strong>是一个抽象的分层模型，这个模型中，所有的 <a href="https://zh.wikipedia.org/wiki/TCP/IP">TCP/IP</a> 系列 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a> 都归类到4个抽象的“层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个<em>协议栈</em>。</p><p>​    由于现在网络中用的都是TCP/IP 参考模型，所以接下来我们着重讲 <strong>TCP/IP协议族</strong> 中的重要协议。</p><h2 id="TCP-IP-协议族主要协议"><a href="#TCP-IP-协议族主要协议" class="headerlink" title="TCP/IP 协议族主要协议"></a>TCP/IP 协议族主要协议</h2><p>​    下图中就是TCP/IP 协议族中的主要协议了，这些协议相互协作，共同工作完成了我们日常生活中的许多需求，例如 HTTP （超文本传输协议），FTP（文件传输协议），DHCP（动态主机设定协议）等等。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923154652668.png" alt="image-20210923154652668"></p><p>​    因为该协议家族的两个核心协议：<strong>TCP（<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a>）</strong>和<strong>IP（<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>）</strong>，为该家族中最早通过的标准[<a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#cite_note-3">3]</a>。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>，因此又称为<strong>TCP/IP协议栈</strong>。</p><p>​    在本篇文章中会先对最核心的 TCP 协议进行论述，其他还有许多重要的协议会放到之后的文章进行讲解。</p><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>​    <strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AF%80%E6%B5%81">字节流</a> 的 <a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议。在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议</a>（UDP）是同一层内另一个与 TCP 相对的 无连接、不可靠 的重要传输协议，在之后我们还会再提到。</p><p>​    提到 TCP 就不免提到它的三次握手和四次挥手，还有随之而来的许多扩展问题：可不可以是两次握手？可不可以是三次挥手？</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手协议的过程：</p><p>​    第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>​    第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>​    第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923163513140.png" alt="image-20210923163513140"></p><p>在上图中我们可以看出，三次握手就像张三和李四建立友好关系一样，但是这两个人文邹邹的，故事如下：</p><p>​    张三：你好！我叫张三，<strong>我能和你做朋友吗</strong>？</p><p>​    李四今天正好心情不错，看见张三这个陌生人打招呼也回了句：张三你好，<strong>我知道你要和我做朋友了</strong>，我叫李四。</p><p>​    张三一看李四的回应，心想，“有戏，又认识一个朋友”，俗话说得好，“多一个朋友多一条路”嘛，就又回到：<strong>我知道我们是朋友了</strong>，现在我们可以开始聊天（che dan）了。</p><p>然后张三和李四就开始了快乐的交流。</p><p>在网络中的两台计算机就像这样进行交流然后建立连接关系之后再进行数据交换，正如上面所提到的那个问题，可不可以是两次握手？</p><h3 id="两次握手或者其他次握手行不行"><a href="#两次握手或者其他次握手行不行" class="headerlink" title="两次握手或者其他次握手行不行"></a>两次握手或者其他次握手行不行</h3><p>答案是不可以！</p><p>TCP作为一种可靠传输控制协议，其<strong>核心思想</strong>：既要保证数据可靠传输，又要提高传输的效率，而用<strong>三次恰恰可以满足以上两方面的需求！</strong>通俗的来说就是两次无法保证可靠，而四次或者更多次握手又没有必要，所以TCP是三次握手。</p><p>在网上有许多说法关于三次握手的必要性：</p><ul><li><a href="https://blog.csdn.net/b954960630/article/details/81861579">检测双方的能力</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923171915643.png" alt="image-20210923171915643"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/114731254">三次握手实质上是四次，是双向握手+双向确认的过程</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172116772.png" alt="image-20210923172116772"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/254224088">三次握手保证失效的连接请求不会产生影响</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172323991.png" alt="image-20210923172323991"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/573627478">需要三次握手来确定序列号</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172526005.png" alt="image-20210923172526005"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>如果说三次握手代表着关系的建立，那么对应的四次挥手就代表着关系的结束，也就是网络中的断连。</p><p>​    第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p>​    即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><p>​    第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>​    即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><p>​    第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>​    即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><p>​    第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923173243645.png" alt="image-20210923173243645"></p><p>可以从上面看出来，四次挥手其实是双方要断开连接时的一个协商过程：</p><p>​    张三：李四啊，你看我们也聊了这么久了，天色也不早了，<strong>我也说了不少了，该回家了</strong>？</p><p>​    李四聊的正在兴头上，但是天色确实不早了，于是说：<strong>我知道你说完了，但是我还有一些事没说完</strong>。</p><p>​    于是李四：巴拉巴拉巴拉。。。</p><p>​    李四觉得说的差不多了，也打算结束这次交流了：张三，<strong>我说完了，再见吧</strong>，有机会再聊。</p><p>​    张三一看李四终于说完了：<strong>再见李四</strong>。</p><p>然后张三和李四就开始了快乐的各回各家各找各妈了。</p><h3 id="可不可以是三次挥手或者更少次"><a href="#可不可以是三次挥手或者更少次" class="headerlink" title="可不可以是三次挥手或者更少次"></a>可不可以是三次挥手或者更少次</h3><p>答案同样是不可以！</p><p>在上面的描述和演示图中我们可以看出来，四次挥手都很重要：</p><p>第一次是率先离开的甲方告诉另一方自己结束传输了；第二次是另一方的乙方回复甲方知道了，但是一般还会有数据需要传输，在这些或多或少的传输结束后；第三次乙方告诉甲方自己这边也结束传输了；最后一次甲方给乙方的回复是<strong>为了确保乙方知道  自己（甲方）已经收到乙方发出的结束传输报文了</strong>。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考 <a href="https://www.cyc2018.xyz/">CS-Notes</a> 以及 <a href="https://zh.wikipedia.org/">维基百科</a>、<a href="https://zhuanlan.zhihu.com/p/86426969">三次握手和四次挥手</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;​    随着时代的发展，计算机已经对我们社会和生活产生了深远的影响。计算机相关技术也被应用于各种各样的领域，有些人因此提出了“20世纪最伟</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://zhoushing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://zhoushing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>字符串相乘</title>
    <link href="http://zhoushing.github.io/2021-09-22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98.html"/>
    <id>http://zhoushing.github.io/2021-09-22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E4%B9%98.html</id>
    <published>2021-09-22T02:59:15.000Z</published>
    <updated>2021-09-22T03:02:43.700Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-43-字符串相乘"><a href="#力扣-43-字符串相乘" class="headerlink" title="力扣 43. 字符串相乘"></a>力扣 <a href="https://leetcode-cn.com/problems/multiply-strings/">43. 字符串相乘</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定两个以字符串形式表示的非负整数 <code>num1</code> 和 <code>num2</code>，返回 <code>num1</code> 和 <code>num2</code> 的乘积，它们的乘积也表示为字符串形式。</p><p><strong>提示：</strong></p><ul><li>num1 和 num2 的长度小于110。</li><li>num1 和 num2 只包含数字 0-9。</li><li>num1 和 num2 均不以零开头，除非是数字 0 本身。</li><li>不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以直接模拟数的运算过程，注意额外的进位即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">multiply</span><span class="params">(String num1, String num2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 乘数为 0</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.equals(num1, <span class="string">&quot;0&quot;</span>) || Objects.equals(num2, <span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size1 = num1.length();</span><br><span class="line">        <span class="keyword">int</span> size2 = num2.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两数相乘的位数是 [size1 + size2 - 1, size1 + size2]</span></span><br><span class="line">        <span class="comment">// 例如 10 * 10 = 100</span></span><br><span class="line">        <span class="comment">// 99 * 99 = 9801</span></span><br><span class="line">        <span class="keyword">int</span>[] nums = <span class="keyword">new</span> <span class="keyword">int</span> [size1 + size2];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] char1 = num1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] char2 = num2.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转，从低位开始计算</span></span><br><span class="line">        reverse(char1);</span><br><span class="line">        reverse(char2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size1; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> now;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// 按位累乘并计算进位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size2; j++) &#123;</span><br><span class="line">                now = (char1[i] - <span class="string">&#x27;0&#x27;</span>) * (char2[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                now += nums[i + j];</span><br><span class="line">                now += count;</span><br><span class="line">                count = now / <span class="number">10</span>;</span><br><span class="line">                now = now % <span class="number">10</span>;</span><br><span class="line">                nums[i + j] = now;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 多余的进位</span></span><br><span class="line">            <span class="keyword">int</span> tick = i + size2;</span><br><span class="line">            <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                now = nums[tick] + count;</span><br><span class="line">                <span class="keyword">while</span> (now &gt; <span class="number">9</span>) &#123;</span><br><span class="line">                    count = now / <span class="number">10</span>;</span><br><span class="line">                    now = now % <span class="number">10</span>;</span><br><span class="line">                    nums[tick] = now;</span><br><span class="line">                    tick++;</span><br><span class="line">                    now = nums[tick] + count;</span><br><span class="line">                &#125;</span><br><span class="line">                nums[tick] = now;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            result.append(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 预防数组多出来一位的 0</span></span><br><span class="line">        <span class="keyword">if</span> (nums[length - <span class="number">1</span>] != <span class="number">0</span>) &#123;</span><br><span class="line">            result.append(nums[length - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 翻转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>[] chars)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> temp = chars[i];</span><br><span class="line">            chars[i] = chars[chars.length - <span class="number">1</span> - i];</span><br><span class="line">            chars[chars.length - <span class="number">1</span> - i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210922110201839.png" alt="image-20210922110201839"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-43-字符串相乘&quot;&gt;&lt;a href=&quot;#力扣-43-字符串相乘&quot; class=&quot;headerlink&quot; title=&quot;力扣 43. 字符串相乘&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/multipl</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="模拟" scheme="http://zhoushing.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>递增的三元子序列</title>
    <link href="http://zhoushing.github.io/2021-09-21-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-09-21-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-09-21T09:32:17.000Z</published>
    <updated>2021-09-21T09:37:59.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-334-递增的三元子序列"><a href="#力扣-334-递增的三元子序列" class="headerlink" title="力扣 334. 递增的三元子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 10^5</code></p></li><li><p><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以贪心使得 a 最小， b 尽可能小， 然后找到 c 即可（当 a，b 不再更新时，说明三元组找到了）</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> b = Integer.MAX_VALUE; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 &lt;= 是因为避免 2, 2, 3 这种情况, 或者 1, 2, 2 的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 使得 a 为最小元素</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= a) &#123;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使得 b 尽可能小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= b) &#123;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 a, b 不更新了, 说明遇到了三元组</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210921173421177.png" alt="image-20210921173421177"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-334-递增的三元子序列&quot;&gt;&lt;a href=&quot;#力扣-334-递增的三元子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 334. 递增的三元子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>划分字母区间</title>
    <link href="http://zhoushing.github.io/2021-09-21-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"/>
    <id>http://zhoushing.github.io/2021-09-21-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-09-21T03:09:20.000Z</published>
    <updated>2021-09-21T03:15:21.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-763-划分字母区间"><a href="#力扣-763-划分字母区间" class="headerlink" title="力扣 763. 划分字母区间"></a>力扣 <a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以记录每个字母最后出现的位置，然后通过标记的方式来划分字符串</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希表存储字符最后出现的位置</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            map.put(chars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = map.get(chars[left]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 看有没有字符出现的位置在更后面</span></span><br><span class="line">            <span class="keyword">int</span> tick = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (tick &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(chars[tick]) &gt; right) &#123;</span><br><span class="line">                    <span class="comment">// 然后有就将右边界向后移</span></span><br><span class="line">                    right = map.get(chars[tick]);</span><br><span class="line">                &#125;</span><br><span class="line">                tick++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录区间</span></span><br><span class="line">            result.add(right - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            left = right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = map.get(chars[left]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210921111510736.png" alt="image-20210921111510736"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-763-划分字母区间&quot;&gt;&lt;a href=&quot;#力扣-763-划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;力扣 763. 划分字母区间&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串</title>
    <link href="http://zhoushing.github.io/2021-09-20-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <id>http://zhoushing.github.io/2021-09-20-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html</id>
    <published>2021-09-20T04:04:53.000Z</published>
    <updated>2021-09-20T04:08:15.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-409-最长回文串"><a href="#力扣-409-最长回文串" class="headerlink" title="力扣 409. 最长回文串"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>    假设字符串的长度不会超过 1010。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为我们可以自由组合，所以我们只需要偶数次出现的字符和至多一个单个字符即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 字母数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">58</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ch) &#123;</span><br><span class="line">            letters[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取字符出现的偶次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> letter : letters) &#123;</span><br><span class="line">            <span class="comment">// 通过 (letter &amp; 1) 来截断奇次</span></span><br><span class="line">            result += letter - (letter &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总共的次数不等于字符长度, 就代表可以有一个奇字母放在回文子串中间</span></span><br><span class="line">        <span class="keyword">return</span> result &lt; ch.length? result + <span class="number">1</span>: result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210920120711577.png" alt="image-20210920120711577"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-409-最长回文串&quot;&gt;&lt;a href=&quot;#力扣-409-最长回文串&quot; class=&quot;headerlink&quot; title=&quot;力扣 409. 最长回文串&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/long</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>除自身以外数组的乘积</title>
    <link href="http://zhoushing.github.io/2021-09-20-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html"/>
    <id>http://zhoushing.github.io/2021-09-20-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</id>
    <published>2021-09-20T03:05:16.000Z</published>
    <updated>2021-09-20T03:08:17.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-238-除自身以外数组的乘积"><a href="#力扣-238-除自身以外数组的乘积" class="headerlink" title="力扣 238. 除自身以外数组的乘积"></a>力扣 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><ul><li><p>提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p></li><li><p>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></li><li><p>进阶：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，*<em>因为一个 数组内除当前元素其他元素的乘积等于 其左累乘 * 右累乘，我们可以采用左右前缀累乘的方式*</em>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 前缀和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个数组内除当前元素其他元素的乘积等于 其左累乘 * 右累乘</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先当前元素左边的所有元素累乘并存储</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再将右边的元素累乘</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210920110744027.png" alt="image-20210920110744027"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-238-除自身以外数组的乘积&quot;&gt;&lt;a href=&quot;#力扣-238-除自身以外数组的乘积&quot; class=&quot;headerlink&quot; title=&quot;力扣 238. 除自身以外数组的乘积&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="前缀和" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>搜索二维矩阵II</title>
    <link href="http://zhoushing.github.io/2021-09-19-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II.html"/>
    <id>http://zhoushing.github.io/2021-09-19-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II.html</id>
    <published>2021-09-19T15:29:39.000Z</published>
    <updated>2021-09-19T15:36:16.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-240-搜索二维矩阵-II"><a href="#力扣-240-搜索二维矩阵-II" class="headerlink" title="力扣 240. 搜索二维矩阵 II"></a>力扣 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><ul><li><strong>提示：</strong><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= n, m &lt;= 300</li><li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/searchgrid2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/searchgrid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为题中的数是明显有序的，我们可以采用双指针的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 行指针</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 列指针</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第一排最后一个元素开始查找</span></span><br><span class="line">        <span class="keyword">while</span> (m &lt; matrix.length &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[m][n] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前元素大于目标元素, 就将列指针向前移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[m][n] &gt; target) &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前元素小于于目标元素, 就将行指针向后移</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210919233509873.png" alt="image-20210919233509873"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-240-搜索二维矩阵-II&quot;&gt;&lt;a href=&quot;#力扣-240-搜索二维矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 240. 搜索二维矩阵 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>无重叠区间</title>
    <link href="http://zhoushing.github.io/2021-09-19-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"/>
    <id>http://zhoushing.github.io/2021-09-19-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-09-19T01:37:42.000Z</published>
    <updated>2021-09-19T01:40:43.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-435-无重叠区间"><a href="#力扣-435-无重叠区间" class="headerlink" title="力扣 435. 无重叠区间"></a>力扣 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><ul><li><strong>提示：</strong><ul><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为需要保证区间不重复，我们可以将右区间进行排序，每次选取右区间较小的进行选择</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照后边界排序，希望每次选择右边界更小的</span></span><br><span class="line">        <span class="comment">// 因为右边界越小的代表对后面区间的影响越小</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] interval1, <span class="keyword">int</span>[] interval2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">1</span>] - interval2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次都选择不重叠区间，剩下的区间就代表着要去除的重叠区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= right) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210919093935447.png" alt="image-20210919093935447"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-435-无重叠区间&quot;&gt;&lt;a href=&quot;#力扣-435-无重叠区间&quot; class=&quot;headerlink&quot; title=&quot;力扣 435. 无重叠区间&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/non-</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="http://zhoushing.github.io/2021-09-18-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html"/>
    <id>http://zhoushing.github.io/2021-09-18-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html</id>
    <published>2021-09-18T15:00:00.000Z</published>
    <updated>2021-09-18T15:03:12.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-200-岛屿数量"><a href="#力扣-200-岛屿数量" class="headerlink" title="力扣 200. 岛屿数量"></a>力扣 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><ul><li><strong>提示：</strong><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为数据量较小，直接采用了标记+DFS的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     * 二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// x，y移动</span></span><br><span class="line">    <span class="keyword">int</span>[] x = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] y = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵高宽</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前位置是否走过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isFind = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isFind[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前位置是陆地，并将周边陆地走遍</span></span><br><span class="line">                    dfs(i, j, grid, isFind);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历将周围土地走遍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid, <span class="keyword">boolean</span>[][] isFind)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 越界或者走到水上</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || (m - i) * (n - j) &lt;= <span class="number">0</span> || isFind[i][j] || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isFind[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; <span class="number">4</span>; e++) &#123;</span><br><span class="line">            dfs(i + x[e], j + y[e], grid, isFind);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210918230245763.png" alt="image-20210918230245763"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-200-岛屿数量&quot;&gt;&lt;a href=&quot;#力扣-200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;力扣 200. 岛屿数量&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/number-</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>杨辉三角II</title>
    <link href="http://zhoushing.github.io/2021-09-17-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II.html"/>
    <id>http://zhoushing.github.io/2021-09-17-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II.html</id>
    <published>2021-09-17T01:07:25.000Z</published>
    <updated>2021-09-17T01:11:34.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-119-杨辉三角-II"><a href="#力扣-119-杨辉三角-II" class="headerlink" title="力扣 119. 杨辉三角 II"></a>力扣 <a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= rowIndex &lt;= 33</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 0</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 1</span><br><span class="line">输出: [1,1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了倒序滚动更新的方式，倒序保证了中间的变得越大，滚动实现了空间优化</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个integer对象数组</span></span><br><span class="line">        Integer[] dp = <span class="keyword">new</span> Integer[rowIndex + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组初始化</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个数开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 滚动更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = Arrays.asList(dp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210917091032235.png" alt="image-20210917091032235"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-119-杨辉三角-II&quot;&gt;&lt;a href=&quot;#力扣-119-杨辉三角-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 119. 杨辉三角 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>设计模式入门</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html</id>
    <published>2021-09-16T15:17:49.000Z</published>
    <updated>2021-09-17T13:47:10.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915170151978.png" alt="image-20210915170151978"></p><p>就如上图所示的，接下来我们会分为创造型、结构型以及行为型来进行扩展。</p><h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p><strong>保证全局仅有一个实例，并提供一个访问它的全局访问点。</strong></p><p><strong>单例模式用来创建全局唯一的对象。</strong>一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：<a href="https://www.cnblogs.com/hyhy904/p/10958554.html">懒汉式、饿汉式</a>、<a href="https://www.cnblogs.com/tangZH/p/10031337.html">双重检测</a>、<a href="https://blog.csdn.net/hqw11/article/details/85061890">静态内部类</a>、<a href="https://www.cnblogs.com/happy4java/p/11206105.html">枚举</a>。</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对OOP特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><p>工厂模式包括<a href="https://www.cnblogs.com/gclokok/p/10029088.html">简单工厂、工厂方法、抽象工厂</a>这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h3 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h3><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/86619675">建造者模式</a>用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li></ul><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h3><p><strong><a href="https://blog.csdn.net/ShuSheng0007/article/details/80864854">代理模式</a>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</strong>。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p><h3 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2.桥接模式"></a>2.桥接模式</h3><p><strong>将抽象部分与它的实现分离（实现指的是抽象类以及它的不同派生类组合起来用来实现自己的对象，例如手机既可以按照品牌分类，又可以按照功能分类），使它们都可以独立地变化。</strong></p><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/345126462">23种经典设计模式的原理、背后的思想、应用场景</a> 以及 <a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/i</summary>
      
    
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小覆盖子串</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html</id>
    <published>2021-09-16T15:06:53.000Z</published>
    <updated>2021-09-16T15:13:43.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-76-最小覆盖子串"><a href="#力扣-76-最小覆盖子串" class="headerlink" title="力扣 76. 最小覆盖子串"></a>力扣 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><ul><li><strong>提示：</strong><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用滑动窗口的方法，先向右延展确定一个最小符合右边界，然后收缩左边界</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; needMap = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; windowsMap = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目标字符串的所有字符记录到needMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            needMap.put(c, needMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口的左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口中符合 needMap 条件的字符数量</span></span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小覆盖子串的起始结尾索引和长度</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到入窗口的元素</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右移窗口</span></span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新窗口内的数据</span></span><br><span class="line">            <span class="keyword">if</span> (needMap.containsKey(c)) &#123;</span><br><span class="line">                windowsMap.put(c, windowsMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果该字符全部被涵盖，则 valid 加一</span></span><br><span class="line">                <span class="keyword">if</span> (windowsMap.get(c).equals(needMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断左侧窗口是否需要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == needMap.size()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首先更新最小覆盖子串的索引和长度</span></span><br><span class="line">                <span class="comment">// right 自增过一次</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到出窗口的元素</span></span><br><span class="line">                <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 窗口右移</span></span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新窗口中的数据</span></span><br><span class="line">                <span class="keyword">if</span> (windowsMap.containsKey(d)) &#123;</span><br><span class="line">                    <span class="comment">// 刚好移除左端点元素后, 滑动窗口不包含目标字符串了</span></span><br><span class="line">                    <span class="keyword">if</span> (windowsMap.get(d).equals(needMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowsMap.put(d, windowsMap.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210916231121253.png" alt="image-20210916231121253"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-76-最小覆盖子串&quot;&gt;&lt;a href=&quot;#力扣-76-最小覆盖子串&quot; class=&quot;headerlink&quot; title=&quot;力扣 76. 最小覆盖子串&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/mini</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="http://zhoushing.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计哈希映射</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.html</id>
    <published>2021-09-16T02:12:50.000Z</published>
    <updated>2021-09-16T02:52:03.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-706-设计哈希映射"><a href="#力扣-706-设计哈希映射" class="headerlink" title="力扣 706. 设计哈希映射"></a>力扣 <a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><ul><li>MyHashMap() 用空映射初始化对象</li><li>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</li><li>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</li><li>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</li></ul><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= key, value &lt;= 10^6</code></li><li>最多调用 <code>10^4</code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, -1, null, 1, null, -1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashMap myHashMap = new MyHashMap();</span><br><span class="line">myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）</span><br><span class="line">myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]</span><br><span class="line">myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数据结构设计算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了链表数组的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键值对内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定内存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表数组, jdk 1.8 之前 HashMap 的主要实现方式</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num % BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化各个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Pair&gt;(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="comment">// 获取迭代器, AbstractSequentialList 定义的方法 iterator()</span></span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="comment">// 找到对应键值就改变</span></span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                pair.setValue(value);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到就添加</span></span><br><span class="line">        data[h].addLast(<span class="keyword">new</span> Pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                data[h].remove(pair);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210916105128403.png" alt="image-20210916105128403"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-706-设计哈希映射&quot;&gt;&lt;a href=&quot;#力扣-706-设计哈希映射&quot; class=&quot;headerlink&quot; title=&quot;力扣 706. 设计哈希映射&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/d</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设计" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="http://zhoushing.github.io/2021-09-15-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html"/>
    <id>http://zhoushing.github.io/2021-09-15-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html</id>
    <published>2021-09-15T03:04:23.000Z</published>
    <updated>2021-09-15T03:10:25.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-32-最长有效括号"><a href="#力扣-32-最长有效括号" class="headerlink" title="力扣 32. 最长有效括号"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接动态规划状态转移的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 根据右括号来判定</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前一个符号为 ( 时, 说明此刻至少拥有一对括号, 可以从 i-2 的状态转移过来</span></span><br><span class="line">                <span class="comment">// 诸如 () 或者 ()() 的形式</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 当前一个符号为 ) 时, 判断前面对应的位置是不是 ( </span></span><br><span class="line">                <span class="comment">// 因为是从前往后计算的, 所以 (()) 这样的计算肯定在 ((())) 之前</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 累计最大值</span></span><br><span class="line">                max = Math.max(max, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915111008675.png" alt="image-20210915111008675"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-32-最长有效括号&quot;&gt;&lt;a href=&quot;#力扣-32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;力扣 32. 最长有效括号&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/long</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="http://zhoushing.github.io/2021-09-15-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-09-15-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-09-15T02:02:40.000Z</published>
    <updated>2021-09-15T02:06:34.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-23-合并K个升序链表"><a href="#力扣-23-合并K个升序链表" class="headerlink" title="力扣 23. 合并K个升序链表"></a>力扣 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><ul><li><strong>提示：</strong><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i] 按 升序 排列</code></li><li><code>lists[i].length 的总和不超过 10^4</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了遍历链表并记录最小值的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.length;</span><br><span class="line">        <span class="comment">// 链表数组为空</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个链表</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tick != n) &#123;</span><br><span class="line">            tick = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">10050</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录最小值以及出现的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tick++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lists[i].val &lt; min) &#123;</span><br><span class="line">                        min = lists[i].val;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        list.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (lists[i].val == min) &#123;</span><br><span class="line">                        list.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值记录以及链表移动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">                temp.next = lists[i];</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915100603081.png" alt="image-20210915100603081"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#力扣-23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;力扣 23. 合并K个升序链表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="http://zhoushing.github.io/2021-09-14-%E5%AD%90%E9%9B%86.html"/>
    <id>http://zhoushing.github.io/2021-09-14-%E5%AD%90%E9%9B%86.html</id>
    <published>2021-09-14T14:29:17.000Z</published>
    <updated>2021-09-14T14:32:50.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-10-正则表达式匹配"><a href="#力扣-10-正则表达式匹配" class="headerlink" title="力扣 10. 正则表达式匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以直接向后遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历result里的集合，取出来加上nums[i]作为一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            temp.addAll(result.get(j));</span><br><span class="line"></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完result集合后，要把nums[i]本身也作为一个元素保存</span></span><br><span class="line">        temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        result.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后添加一个空元素</span></span><br><span class="line">    result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210914223150479.png" alt="image-20210914223150479"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#力扣-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 10. 正则表达式匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/r</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="http://zhoushing.github.io/2021-09-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <id>http://zhoushing.github.io/2021-09-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html</id>
    <published>2021-09-14T13:17:53.000Z</published>
    <updated>2021-09-14T13:37:28.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-10-正则表达式匹配"><a href="#力扣-10-正则表达式匹配" class="headerlink" title="力扣 10. 正则表达式匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><ul><li><strong>提示：</strong><ul><li>0 &lt;= s.length &lt;= 20</li><li>0 &lt;= p.length &lt;= 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串匹配算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以使用动态规划来求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] cp = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]: 表示s的前i个字符, p的前j个字符是否能够匹配</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[cs.length + <span class="number">1</span>][cp.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s, p 都为空的时候是匹配的, 而其他都预设是不匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当某位字符为 * 时, 它可以抵消前一个字符, 所以存在下述转移式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 当两个字符相等 or p 字符串当前字符串是万能字符 .</span></span><br><span class="line">                <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">1</span>] || cp[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 可以直接抵消, 等于上次的结果</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当匹配到 * 时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 字符串s * 的前一个字符能够跟字符串p 的末位匹配上时</span></span><br><span class="line">                    <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">2</span>] || cp[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对应的两种状态:</span></span><br><span class="line">                        <span class="comment">// dp[i][j] = dp[i][j - 2] 匹配 0 次</span></span><br><span class="line">                        <span class="comment">// dp[i][j] = dp[i - 1][j] 匹配 1到多 次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 不能匹配</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 只能匹配 0 次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[cs.length][cp.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210914212852472.png" alt="image-20210914212852472"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#力扣-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 10. 正则表达式匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/r</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>初识设计模式</title>
    <link href="http://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</id>
    <published>2021-09-13T14:37:19.000Z</published>
    <updated>2021-09-17T13:25:54.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>想必大家都知道，在面向对象中，存在着三大特性和五大原则：</p><ul><li>三大原则<ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li>五大原则<ul><li>单一职责原则（Single Responsibility Principle）</li><li>开放封闭原则（Open－Close Principle）</li><li>里氏替换原则（the Liskov Substitution Principle）</li><li>依赖倒置原则（the Dependency Inversion Principle）</li><li>接口分离原则（the Interface Segregation Principle）</li></ul></li></ul><p>今天，我们的主角不是面向对象，而是设计模式，在设计模式中同样也存在着六大原则，和上述的五大原有着重复：</p><ul><li>六大原则<ul><li>单一职责原则，实现类要职责单一；</li><li>开闭原则，要对扩展开放，对修改关闭；</li><li>里氏替换原则，所有引用父类的地方必须能透明地使用其子类的对象；</li><li>依赖倒置原则，要面向接口编程，不要面向实现编程；</li><li>接口隔离原则，使用多个专门的接口，而不使用单一的总接口，即调用方不应该依赖那些它不需要的接口；</li><li>迪米特原则，只与你的直接朋友交谈，不跟“陌生人”说话，要降低耦合。</li></ul></li></ul><p>下面我们来一一解释。</p><p>上述五大原则、六大原则仅是作者个人认为，还有包括诸如合成复用等原则，也是很有用的原则，请读者去自行了解。</p><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>定义</strong>：一个类只应该负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p><p><strong>问题由来：</strong>当类T负责两个不同的职责时，当由于职责1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责2功能发生故障。</p><p>单一职责原则告诉我们：<strong>一个类不应该担负太多的责任，就像996的你一样！</strong>在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><p><strong>单一职责原的优点有：</strong></p><ol><li><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p></li><li><p>提高类的可读性，提高系统的可维护性；</p></li><li><p>降低变更引起的风险，变更是不可避免的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p></li></ol><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>定义：</strong>一个软件实体应当对扩展开放，对修改关闭。即<strong>软件实体应尽量在不修改原有代码的情况下进行功能扩展</strong>。</p><p><strong>问题由来：</strong>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。因为变化，升级和维护等原因，如果需要对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要对原有代码经过重新测试。所以当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现使我们需要的。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p><strong>为什么使用开闭原则：</strong></p><p>第一：开闭原则非常有名</p><p>只要是面向对象编程，在开发时都会强调开闭原则。</p><p>第二：开闭原则是最基础的设计原则</p><p>其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，而开闭原则才是其精神领袖。依照Java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。</p><p>第三：开闭原则可以提高复用性</p><p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，而不是在一个类中独立实现一套业务逻辑。只有这样的代码才可以复用，逻辑粒度越小，被复用的可能性越大。为什么要复用呢？复用可以减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量以及系统变化时产生bug的机会。怎么才能提高复用率呢？设计者需要缩小逻辑粒度，直到一个逻辑不可以分为止。</p><p>第四：开闭原则可以提高维护性</p><p>一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，再进行修改，是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后再修改，那是对维护人员的折磨和摧残。</p><p>第五：面向对象开发的要求</p><p>万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到尽可能多变化的因素，然后留下接口，等待“可能”转变为“现实”。</p><p><strong>如何使用开闭原则</strong></p><p>第一：抽象约束<br>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p><p>1.通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。</p><p>2.参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求。</p><p>3.抽象层尽量保持稳定，一旦确定就不要修改。</p><p>第二：元数据(metadata)控件模块行为</p><p>编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p><p>第三：制定项目章程<br>在一个团队中，建立项目章程是非常重要的，因为章程是所有开发人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。</p><p>第四：封装变化</p><p>对变化封装包含两层含义：</p><p>(1)将相同的变化封装到一个接口或抽象类中。</p><p>(2)将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。 封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p><strong>定义</strong>：里氏代换原则：<strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong>。</p><p><strong>继承优点</strong></p><p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；提高代码的重用性；子类可以形似父类，但又异于父类；提高代码的可扩展性，实现父类的方法就可以“为所欲为”了；提高产品或项目的开放性。</p><p><strong>继承缺点</strong></p><p><strong>继承是侵入性的。</strong>只要继承，就必须拥有父类的所有属性和方法；降低代码的灵活性。子类必须拥有父类的属性和方法；</p><p><strong>增强了耦合性。</strong>当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果，大片的代码需要重构。</p><p><strong>克服继承的缺点——里氏替换原则</strong></p><p>从整体上来看，利大于弊。</p><p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>在使用里氏代换原则时需要注意如下几个问题：</p><p>(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p><p>(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p><p>(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p><strong>定义：</strong></p><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><p><strong>依赖倒置原则的作用</strong></p><p>（1）依赖倒置原则可以降低类间的耦合性。</p><p>（2）依赖倒置原则可以提高系统的稳定性。</p><p>（3）依赖倒置原则可以减少并行开发引起的风险。</p><p>（4）依赖倒置原则可以提高代码的可读性和可维护性。</p><p><strong>依赖倒置原则的实现方法</strong></p><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><p>（1）每个类尽量提供接口或抽象类，或者两者都具备。</p><p>（2）变量的声明类型尽量是接口或者是抽象类。</p><p>（3）任何类都不应该从具体类派生。</p><p>（4）使用继承时尽量遵循里氏替换原则。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><strong>定义：</strong>使用多个专门的接口，而不使用单一的总接口，即<strong>客户端不应该依赖那些它不需要的接口</strong>。</p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</p><p>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><p>（1）单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</p><p>（2）单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><p><strong>接口隔离原则的优点</strong></p><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：</p><p>（1）将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>（2）接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</p><p>（3）如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</p><p>（4）使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</p><p>（5）能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><p><strong>接口隔离原则的实现方法</strong></p><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量：</p><p>（1）接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</p><p>（2）为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</p><p>（3）了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</p><p>（4）提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p><strong>定义：</strong>迪米特法则(Law of Demeter, LoD)：<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。</p><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><p><strong>迪米特法则的优点</strong></p><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><p>降低了类之间的耦合度，提高了模块的相对独立性。</p><p>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</p><p>但是，<strong>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低</strong>。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><p><strong>迪米特法则的实现方法</strong></p><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><p>从依赖者的角度来说，只依赖应该依赖的对象。</p><p>从被依赖者的角度说，只暴露应该暴露的方法。</p><p>所以，在运用迪米特法则时要注意以下 6 点：</p><ol><li><p>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</p></li><li><p>在类的结构设计上，尽量降低类成员的访问权限。</p></li><li><p>在类的设计上，优先考虑将一个类设置成不变类。</p></li><li><p>在对其他类的引用上，将引用其他对象的次数降到最低。</p></li><li><p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p></li><li><p>谨慎使用序列化（Serializable）功能。</p></li></ol><h3 id="六大原则总结"><a href="#六大原则总结" class="headerlink" title="六大原则总结"></a>六大原则总结</h3><p>单一职责原则告诉我们实现类要职责单一；</p><p>里氏替换原则告诉我们不要破坏继承体系；</p><p>依赖倒置原则告诉我们要面向接口编程；</p><p>接口隔离原则告诉我们在设计接口的时候要精简单一；</p><p>迪米特原则告诉我们要降低耦合；</p><p>开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p><p>但是在实际项目中出现问题都是不可避免的，使用<strong>六大原则的前提是要保证系统的稳定性，不可照本宣科造成系统设计过度或者影响系统运行</strong>。</p><h2 id="二十三种设计模式"><a href="#二十三种设计模式" class="headerlink" title="二十三种设计模式"></a>二十三种设计模式</h2><p>23种经典设计模式共分为3种类型，分别是创建型、结构型和行为型。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915170151978.png" alt="image-20210915170151978"></p><p>具体的在之后的<a href="https://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式入门</a>之中再继续讲解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/qa/other/22063.html">设计模式六大原则是什么</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;想必大家都知道，在面向对象中，存在着三大特性和五大原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三大原则&lt;ul&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;继承&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
