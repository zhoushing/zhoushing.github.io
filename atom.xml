<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2021-09-21T09:37:59.312Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>递增的三元子序列</title>
    <link href="http://zhoushing.github.io/2021-09-21-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-09-21-%E9%80%92%E5%A2%9E%E7%9A%84%E4%B8%89%E5%85%83%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-09-21T09:32:17.000Z</published>
    <updated>2021-09-21T09:37:59.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-334-递增的三元子序列"><a href="#力扣-334-递增的三元子序列" class="headerlink" title="力扣 334. 递增的三元子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence/">334. 递增的三元子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数数组 nums ，判断这个数组中是否存在长度为 3 的递增子序列。</p><p>如果存在这样的三元组下标 (i, j, k) 且满足 i &lt; j &lt; k ，使得 <code>nums[i] &lt; nums[j] &lt; nums[k]</code> ，返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li><p><code>1 &lt;= nums.length &lt;= 10^5</code></p></li><li><p><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5]</span><br><span class="line">输出：true</span><br><span class="line">解释：任何 i &lt; j &lt; k 的三元组都满足题意</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [5,4,3,2,1]</span><br><span class="line">输出：false</span><br><span class="line">解释：不存在满足题意的三元组</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,1,5,0,4,6]</span><br><span class="line">输出：true</span><br><span class="line">解释：三元组 (3, 4, 5) 满足题意，因为 nums[3] == 0 &lt; nums[4] == 4 &lt; nums[5] == 6</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以贪心使得 a 最小， b 尽可能小， 然后找到 c 即可（当 a，b 不再更新时，说明三元组找到了）</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">increasingTriplet</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> b = Integer.MAX_VALUE; </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 &lt;= 是因为避免 2, 2, 3 这种情况, 或者 1, 2, 2 的情况</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            <span class="comment">// 使得 a 为最小元素</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt;= a) &#123;</span><br><span class="line">                a = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 使得 b 尽可能小</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (num &lt;= b) &#123;</span><br><span class="line">                b = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 a, b 不更新了, 说明遇到了三元组</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210921173421177.png" alt="image-20210921173421177"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-334-递增的三元子序列&quot;&gt;&lt;a href=&quot;#力扣-334-递增的三元子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 334. 递增的三元子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>划分字母区间</title>
    <link href="http://zhoushing.github.io/2021-09-21-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html"/>
    <id>http://zhoushing.github.io/2021-09-21-%E5%88%92%E5%88%86%E5%AD%97%E6%AF%8D%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-09-21T03:09:20.000Z</published>
    <updated>2021-09-21T03:15:21.764Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-763-划分字母区间"><a href="#力扣-763-划分字母区间" class="headerlink" title="力扣 763. 划分字母区间"></a>力扣 <a href="https://leetcode-cn.com/problems/partition-labels/">763. 划分字母区间</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>提示：</strong></p><ul><li><code>S</code>的长度在<code>[1, 500]</code>之间。</li><li><code>S</code>只包含小写字母 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以记录每个字母最后出现的位置，然后通过标记的方式来划分字符串</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 哈希表存储字符最后出现的位置</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> length = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            map.put(chars[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = map.get(chars[left]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; length) &#123;</span><br><span class="line">            <span class="comment">// 看有没有字符出现的位置在更后面</span></span><br><span class="line">            <span class="keyword">int</span> tick = left + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (tick &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.get(chars[tick]) &gt; right) &#123;</span><br><span class="line">                    <span class="comment">// 然后有就将右边界向后移</span></span><br><span class="line">                    right = map.get(chars[tick]);</span><br><span class="line">                &#125;</span><br><span class="line">                tick++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录区间</span></span><br><span class="line">            result.add(right - left + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            left = right + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (left &gt;= length) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            right = map.get(chars[left]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210921111510736.png" alt="image-20210921111510736"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-763-划分字母区间&quot;&gt;&lt;a href=&quot;#力扣-763-划分字母区间&quot; class=&quot;headerlink&quot; title=&quot;力扣 763. 划分字母区间&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串</title>
    <link href="http://zhoushing.github.io/2021-09-20-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html"/>
    <id>http://zhoushing.github.io/2021-09-20-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2.html</id>
    <published>2021-09-20T04:04:53.000Z</published>
    <updated>2021-09-20T04:08:15.646Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-409-最长回文串"><a href="#力扣-409-最长回文串" class="headerlink" title="力扣 409. 最长回文串"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-palindrome/">409. 最长回文串</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。</p><p>在构造过程中，请注意区分大小写。比如 “Aa” 不能当做一个回文字符串。</p><p>注意:<br>    假设字符串的长度不会超过 1010。</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;abccccdd&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">7</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">我们可以构造的最长的回文串是&quot;dccaccd&quot;, 它的长度是 7。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为我们可以自由组合，所以我们只需要偶数次出现的字符和至多一个单个字符即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 字母数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] letters = <span class="keyword">new</span> <span class="keyword">int</span> [<span class="number">58</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 统计字母</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : ch) &#123;</span><br><span class="line">            letters[c - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取字符出现的偶次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> letter : letters) &#123;</span><br><span class="line">            <span class="comment">// 通过 (letter &amp; 1) 来截断奇次</span></span><br><span class="line">            result += letter - (letter &amp; <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果总共的次数不等于字符长度, 就代表可以有一个奇字母放在回文子串中间</span></span><br><span class="line">        <span class="keyword">return</span> result &lt; ch.length? result + <span class="number">1</span>: result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210920120711577.png" alt="image-20210920120711577"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-409-最长回文串&quot;&gt;&lt;a href=&quot;#力扣-409-最长回文串&quot; class=&quot;headerlink&quot; title=&quot;力扣 409. 最长回文串&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/long</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>除自身以外数组的乘积</title>
    <link href="http://zhoushing.github.io/2021-09-20-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html"/>
    <id>http://zhoushing.github.io/2021-09-20-%E9%99%A4%E8%87%AA%E8%BA%AB%E4%BB%A5%E5%A4%96%E6%95%B0%E7%BB%84%E7%9A%84%E4%B9%98%E7%A7%AF.html</id>
    <published>2021-09-20T03:05:16.000Z</published>
    <updated>2021-09-20T03:08:17.719Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-238-除自身以外数组的乘积"><a href="#力扣-238-除自身以外数组的乘积" class="headerlink" title="力扣 238. 除自身以外数组的乘积"></a>力扣 <a href="https://leetcode-cn.com/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。</p><ul><li><p>提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。</p></li><li><p>说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。</p></li><li><p>进阶：<br>你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。）</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,3,4]</span><br><span class="line">输出: [24,12,8,6]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，*<em>因为一个 数组内除当前元素其他元素的乘积等于 其左累乘 * 右累乘，我们可以采用左右前缀累乘的方式*</em>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 前缀和</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] productExceptSelf(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一个数组内除当前元素其他元素的乘积等于 其左累乘 * 右累乘</span></span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先当前元素左边的所有元素累乘并存储</span></span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            result[i] = result[i - <span class="number">1</span>] * nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再将右边的元素累乘</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            result[i] *= right;</span><br><span class="line">            right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210920110744027.png" alt="image-20210920110744027"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-238-除自身以外数组的乘积&quot;&gt;&lt;a href=&quot;#力扣-238-除自身以外数组的乘积&quot; class=&quot;headerlink&quot; title=&quot;力扣 238. 除自身以外数组的乘积&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="前缀和" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>搜索二维矩阵II</title>
    <link href="http://zhoushing.github.io/2021-09-19-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II.html"/>
    <id>http://zhoushing.github.io/2021-09-19-%E6%90%9C%E7%B4%A2%E4%BA%8C%E7%BB%B4%E7%9F%A9%E9%98%B5II.html</id>
    <published>2021-09-19T15:29:39.000Z</published>
    <updated>2021-09-19T15:36:16.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-240-搜索二维矩阵-II"><a href="#力扣-240-搜索二维矩阵-II" class="headerlink" title="力扣 240. 搜索二维矩阵 II"></a>力扣 <a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</p><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p><ul><li><strong>提示：</strong><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= n, m &lt;= 300</li><li><code>-10^9 &lt;= matrix[i][j] &lt;= 10^9</code></li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/searchgrid2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/searchgrid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为题中的数是明显有序的，我们可以采用双指针的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchMatrix</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 行指针</span></span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 列指针</span></span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].length - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第一排最后一个元素开始查找</span></span><br><span class="line">        <span class="keyword">while</span> (m &lt; matrix.length &amp;&amp; n &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[m][n] == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前元素大于目标元素, 就将列指针向前移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[m][n] &gt; target) &#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前元素小于于目标元素, 就将行指针向后移</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                m++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210919233509873.png" alt="image-20210919233509873"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-240-搜索二维矩阵-II&quot;&gt;&lt;a href=&quot;#力扣-240-搜索二维矩阵-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 240. 搜索二维矩阵 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>无重叠区间</title>
    <link href="http://zhoushing.github.io/2021-09-19-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html"/>
    <id>http://zhoushing.github.io/2021-09-19-%E6%97%A0%E9%87%8D%E5%8F%A0%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-09-19T01:37:42.000Z</published>
    <updated>2021-09-19T01:40:43.295Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-435-无重叠区间"><a href="#力扣-435-无重叠区间" class="headerlink" title="力扣 435. 无重叠区间"></a>力扣 <a href="https://leetcode-cn.com/problems/non-overlapping-intervals/">435. 无重叠区间</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。</p><ul><li><strong>提示：</strong><ul><li>可以认为区间的终点总是大于它的起点。</li><li>区间 [1,2] 和 [2,3] 的边界相互“接触”，但没有相互重叠。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3], [3,4], [1,3] ]</span><br><span class="line"></span><br><span class="line">输出: 1</span><br><span class="line"></span><br><span class="line">解释: 移除 [1,3] 后，剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [1,2], [1,2] ]</span><br><span class="line"></span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: [ [1,2], [2,3] ]</span><br><span class="line"></span><br><span class="line">输出: 0</span><br><span class="line"></span><br><span class="line">解释: 你不需要移除任何区间，因为它们已经是无重叠的了。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为需要保证区间不重复，我们可以将右区间进行排序，每次选取右区间较小的进行选择</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 按照后边界排序，希望每次选择右边界更小的</span></span><br><span class="line">        <span class="comment">// 因为右边界越小的代表对后面区间的影响越小</span></span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] interval1, <span class="keyword">int</span>[] interval2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> interval1[<span class="number">1</span>] - interval2[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = intervals.length;</span><br><span class="line">        <span class="keyword">int</span> right = intervals[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 每次都选择不重叠区间，剩下的区间就代表着要去除的重叠区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[i][<span class="number">0</span>] &gt;= right) &#123;</span><br><span class="line">                ++result;</span><br><span class="line">                right = intervals[i][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> n - result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210919093935447.png" alt="image-20210919093935447"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-435-无重叠区间&quot;&gt;&lt;a href=&quot;#力扣-435-无重叠区间&quot; class=&quot;headerlink&quot; title=&quot;力扣 435. 无重叠区间&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/non-</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="http://zhoushing.github.io/2021-09-18-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html"/>
    <id>http://zhoushing.github.io/2021-09-18-%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F.html</id>
    <published>2021-09-18T15:00:00.000Z</published>
    <updated>2021-09-18T15:03:12.769Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-200-岛屿数量"><a href="#力扣-200-岛屿数量" class="headerlink" title="力扣 200. 岛屿数量"></a>力扣 <a href="https://leetcode-cn.com/problems/number-of-islands/">200. 岛屿数量</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个由 ‘1’（陆地）和 ‘0’（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><ul><li><strong>提示：</strong><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 300</code></li><li><code>grid[i][j]</code> 的值为 <code>&#39;0&#39;</code> 或 <code>&#39;1&#39;</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>因为数据量较小，直接采用了标记+DFS的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     * 二维数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// x，y移动</span></span><br><span class="line">    <span class="keyword">int</span>[] x = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] y = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵高宽</span></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(<span class="keyword">char</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        m = grid.length;</span><br><span class="line">        n = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前位置是否走过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] isFind = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!isFind[i][j] &amp;&amp; grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 当前位置是陆地，并将周边陆地走遍</span></span><br><span class="line">                    dfs(i, j, grid, isFind);</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历将周围土地走遍</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">char</span>[][] grid, <span class="keyword">boolean</span>[][] isFind)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 越界或者走到水上</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || (m - i) * (n - j) &lt;= <span class="number">0</span> || isFind[i][j] || grid[i][j] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        isFind[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> e = <span class="number">0</span>; e &lt; <span class="number">4</span>; e++) &#123;</span><br><span class="line">            dfs(i + x[e], j + y[e], grid, isFind);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210918230245763.png" alt="image-20210918230245763"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-200-岛屿数量&quot;&gt;&lt;a href=&quot;#力扣-200-岛屿数量&quot; class=&quot;headerlink&quot; title=&quot;力扣 200. 岛屿数量&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/number-</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>杨辉三角II</title>
    <link href="http://zhoushing.github.io/2021-09-17-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II.html"/>
    <id>http://zhoushing.github.io/2021-09-17-%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92II.html</id>
    <published>2021-09-17T01:07:25.000Z</published>
    <updated>2021-09-17T01:11:34.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-119-杨辉三角-II"><a href="#力扣-119-杨辉三角-II" class="headerlink" title="力扣 119. 杨辉三角 II"></a>力扣 <a href="https://leetcode-cn.com/problems/pascals-triangle-ii/">119. 杨辉三角 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个非负索引 <code>rowIndex</code>，返回「杨辉三角」的第 <code>rowIndex</code> 行。</p><p>在「杨辉三角」中，每个数是它左上方和右上方的数的和。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/1626927345-DZmfxB-PascalTriangleAnimated2.gif" alt="img"></p><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= rowIndex &lt;= 33</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 3</span><br><span class="line">输出: [1,3,3,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 0</span><br><span class="line">输出: [1]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: rowIndex = 1</span><br><span class="line">输出: [1,1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了倒序滚动更新的方式，倒序保证了中间的变得越大，滚动实现了空间优化</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">getRow</span><span class="params">(<span class="keyword">int</span> rowIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 新建一个integer对象数组</span></span><br><span class="line">        Integer[] dp = <span class="keyword">new</span> Integer[rowIndex + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 数组初始化</span></span><br><span class="line">        Arrays.fill(dp,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第二个数开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; dp.length;i++)&#123;</span><br><span class="line">            <span class="comment">// 滚动更新</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i - <span class="number">1</span>;j &gt; <span class="number">0</span>;j--) &#123;</span><br><span class="line">                dp[j] = dp[j] + dp[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;Integer&gt; result = Arrays.asList(dp);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210917091032235.png" alt="image-20210917091032235"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-119-杨辉三角-II&quot;&gt;&lt;a href=&quot;#力扣-119-杨辉三角-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 119. 杨辉三角 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>设计模式入门</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%A5%E9%97%A8.html</id>
    <published>2021-09-16T15:17:49.000Z</published>
    <updated>2021-09-17T13:47:10.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915170151978.png" alt="image-20210915170151978"></p><p>就如上图所示的，接下来我们会分为创造型、结构型以及行为型来进行扩展。</p><h2 id="一、创建型设计模式"><a href="#一、创建型设计模式" class="headerlink" title="一、创建型设计模式"></a>一、创建型设计模式</h2><p>创建型设计模式包括：单例模式、工厂模式、建造者模式、原型模式。它主要解决对象的创建问题，封装复杂的创建过程，解耦对象的创建代码和使用代码。</p><h3 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1. 单例模式"></a>1. 单例模式</h3><p><strong>保证全局仅有一个实例，并提供一个访问它的全局访问点。</strong></p><p><strong>单例模式用来创建全局唯一的对象。</strong>一个类只允许创建一个对象（或者叫实例），那这个类就是一个单例类，这种设计模式就叫作单例模式。单例有几种经典的实现方式，它们分别是：<a href="https://www.cnblogs.com/hyhy904/p/10958554.html">懒汉式、饿汉式</a>、<a href="https://www.cnblogs.com/tangZH/p/10031337.html">双重检测</a>、<a href="https://blog.csdn.net/hqw11/article/details/85061890">静态内部类</a>、<a href="https://www.cnblogs.com/happy4java/p/11206105.html">枚举</a>。</p><p>尽管单例是一个很常用的设计模式，在实际的开发中，我们也确实经常用到它，但是，有些人认为单例是一种反模式（anti-pattern），并不推荐使用，主要的理由有以下几点：</p><ul><li>单例对OOP特性的支持不友好</li><li>单例会隐藏类之间的依赖关系</li><li>单例对代码的扩展性不友好</li><li>单例对代码的可测试性不友好</li><li>单例不支持有参数的构造函数</li></ul><p>那有什么替代单例的解决方案呢？如果要完全解决这些问题，我们可能要从根上寻找其他方式来实现全局唯一类。比如，通过工厂模式、IOC容器来保证全局唯一性。</p><p>有人把单例当作反模式，主张杜绝在项目中使用。我个人觉得这有点极端。模式本身没有对错，关键看你怎么用。如果单例类并没有后续扩展的需求，并且不依赖外部系统，那设计成单例类就没有太大问题。对于一些全局类，我们在其他地方new的话，还要在类之间传来传去，不如直接做成单例类，使用起来简洁方便。</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><p>工厂模式包括<a href="https://www.cnblogs.com/gclokok/p/10029088.html">简单工厂、工厂方法、抽象工厂</a>这3种细分模式。其中，简单工厂和工厂方法比较常用，抽象工厂的应用场景比较特殊，所以很少用到，不是我们学习的重点。</p><p>工厂模式用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。实际上，如果创建对象的逻辑并不复杂，那我们直接通过new来创建对象就可以了，不需要使用工厂模式。当创建逻辑比较复杂，是一个“大工程”的时候，我们就考虑使用工厂模式，封装对象的创建过程，将对象的创建和使用相分离。</p><p>当每个对象的创建逻辑都比较简单的时候，我推荐使用简单工厂模式，将多个对象的创建逻辑放到一个工厂类中。当每个对象的创建逻辑都比较复杂的时候，为了避免设计一个过于庞大的工厂类，我们推荐使用工厂方法模式，将创建逻辑拆分得更细，每个对象的创建逻辑独立到各自的工厂类中。</p><p>详细点说，工厂模式的作用有下面4个，这也是判断要不要使用工厂模式最本质的参考标准。</p><ul><li>封装变化：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明。</li><li>代码复用：创建代码抽离到独立的工厂类之后可以复用。</li><li>隔离复杂性：封装复杂的创建逻辑，调用者无需了解如何创建对象。</li><li>控制复杂度：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁。</li></ul><p>除此之外，我们还讲了工厂模式一个非常经典的应用场景：依赖注入框架，比如Spring IOC、Google Guice，它用来集中创建、组装、管理对象，跟具体业务代码解耦，让程序员聚焦在业务代码的开发上。</p><h3 id="3-建造者模式"><a href="#3-建造者模式" class="headerlink" title="3. 建造者模式"></a>3. 建造者模式</h3><p><a href="https://blog.csdn.net/ShuSheng0007/article/details/86619675">建造者模式</a>用来创建复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象。建造者模式的原理和实现比较简单，重点是掌握应用场景，避免过度使用。</p><p>如果一个类中有很多属性，为了避免构造函数的参数列表过长，影响代码的可读性和易用性，我们可以通过构造函数配合set()方法来解决。但是，如果存在下面情况中的任意一种，我们就要考虑使用建造者模式了。</p><ul><li>我们把类的必填属性放到构造函数中，强制创建对象的时候就设置。如果必填的属性有很多，把这些必填属性都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填属性通过set()方法设置，那校验这些必填属性是否已经填写的逻辑就无处安放了。</li><li>如果类的属性之间有一定的依赖关系或者约束条件，我们继续使用构造函数配合set()方法的设计思路，那这些依赖关系或约束条件的校验逻辑就无处安放了。</li><li>如果我们希望创建不可变对象，也就是说，对象在创建好之后，就不能再修改内部的属性值，要实现这个功能，我们就不能在类中暴露set()方法。构造函数配合set()方法来设置属性值的方式就不适用了。</li></ul><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h3><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型模式。</p><p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。所以，深拷贝比起浅拷贝来说，更加耗时，更加耗内存空间。</p><p>如果要拷贝的对象是不可变对象，浅拷贝共享不可变对象是没问题的，但对于可变对象来说，浅拷贝得到的对象和原始对象会共享部分数据，就有可能出现数据被修改的风险，也就变得复杂多了。操作非常耗时的情况下，我们比较推荐使用浅拷贝，否则，没有充分的理由，不要为了一点点的性能提升而使用浅拷贝。</p><h2 id="二、结构型设计模式"><a href="#二、结构型设计模式" class="headerlink" title="二、结构型设计模式"></a>二、结构型设计模式</h2><p>结构型模式主要总结了一些类或对象组合在一起的经典结构，这些经典的结构可以解决特定应用场景的问题。结构型模式包括：代理模式、桥接模式、装饰器模式、适配器模式、门面模式、组合模式、享元模式。</p><h3 id="1-代理模式"><a href="#1-代理模式" class="headerlink" title="1. 代理模式"></a>1. 代理模式</h3><p><strong><a href="https://blog.csdn.net/ShuSheng0007/article/details/80864854">代理模式</a>在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同</strong>。一般情况下，我们让代理类和原始类实现同样的接口。但是，如果原始类并没有定义接口，并且原始类代码并不是我们开发维护的。在这种情况下，我们可以通过让代理类继承原始类的方法来实现代理模式。</p><p>静态代理需要针对每个类都创建一个代理类，并且每个代理类中的代码都有点像模板式的“重复”代码，增加了维护成本和开发成本。对于静态代理存在的问题，我们可以通过动态代理来解决。我们不事先为每个原始类编写代理类，而是在运行的时候动态地创建原始类对应的代理类，然后在系统中用代理类替换掉原始类。</p><p>代理模式常用在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们将这些附加功能与业务功能解耦，放到代理类统一处理，让程序员只需要关注业务方面的开发。除此之外，代理模式还可以用在RPC、缓存等应用场景中。</p><h3 id="2-桥接模式"><a href="#2-桥接模式" class="headerlink" title="2.桥接模式"></a>2.桥接模式</h3><p><strong>将抽象部分与它的实现分离（实现指的是抽象类以及它的不同派生类组合起来用来实现自己的对象，例如手机既可以按照品牌分类，又可以按照功能分类），使它们都可以独立地变化。</strong></p><p>桥接模式的代码实现非常简单，但是理解起来稍微有点难度，并且应用场景也比较局限，所以，相对来说，桥接模式在实际的项目中并没有那么常用，你只需要简单了解，见到能认识就可以了，并不是我们学习的重点。</p><p>桥接模式有两种理解方式。第一种理解方式是“将抽象和实现解耦，让它们能独立开发”。这种理解方式比较特别，应用场景也不多。另一种理解方式更加简单，等同于“组合优于继承”设计原则，这种理解方式更加通用，应用场景比较多。不管是哪种理解方式，它们的代码结构都是相同的，都是一种类之间的组合关系。</p><p>对于第一种理解方式，弄懂定义中“抽象”和“实现”两个概念，是理解它的关键。定义中的“抽象”，指的并非“抽象类”或“接口”，而是被抽象出来的一套“类库”，它只包含骨架代码，真正的业务逻辑需要委派给定义中的“实现”来完成。而定义中的“实现”，也并非“接口的实现类”，而是的一套独立的“类库”。“抽象”和“实现”独立开发，通过对象之间的组合关系组装在一起。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/345126462">23种经典设计模式的原理、背后的思想、应用场景</a> 以及 <a href="https://blog.csdn.net/ShuSheng0007/article/details/115980889">永不磨灭的设计模式</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/i</summary>
      
    
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小覆盖子串</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html</id>
    <published>2021-09-16T15:06:53.000Z</published>
    <updated>2021-09-16T15:13:43.453Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-76-最小覆盖子串"><a href="#力扣-76-最小覆盖子串" class="headerlink" title="力扣 76. 最小覆盖子串"></a>力扣 <a href="https://leetcode-cn.com/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><ul><li><strong>提示：</strong><ul><li>对于 <code>t</code> 中重复字符，我们寻找的子字符串中该字符数量必须不少于 <code>t</code> 中该字符数量。</li><li>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ADOBECODEBANC&quot;, t = &quot;ABC&quot;</span><br><span class="line">输出：&quot;BANC&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;, t = &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;a&quot;, t = &quot;aa&quot;</span><br><span class="line">输出: &quot;&quot;</span><br><span class="line">解释: t 中两个字符 &#x27;a&#x27; 均应包含在 s 的子串中，</span><br><span class="line">因此没有符合条件的子字符串，返回空字符串。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用滑动窗口的方法，先向右延展确定一个最小符合右边界，然后收缩左边界</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 滑动窗口</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minWindow</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; needMap = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line">        Map&lt;Character, Integer&gt; windowsMap = <span class="keyword">new</span> HashMap&lt;Character, Integer&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将目标字符串的所有字符记录到needMap中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">            needMap.put(c, needMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口的左右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录窗口中符合 needMap 条件的字符数量</span></span><br><span class="line">        <span class="keyword">int</span> valid = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录最小覆盖子串的起始结尾索引和长度</span></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, len = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (right &lt; s.length()) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 找到入窗口的元素</span></span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(right);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 右移窗口</span></span><br><span class="line">            right++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新窗口内的数据</span></span><br><span class="line">            <span class="keyword">if</span> (needMap.containsKey(c)) &#123;</span><br><span class="line">                windowsMap.put(c, windowsMap.getOrDefault(c, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果该字符全部被涵盖，则 valid 加一</span></span><br><span class="line">                <span class="keyword">if</span> (windowsMap.get(c).equals(needMap.get(c))) &#123;</span><br><span class="line">                    valid++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 判断左侧窗口是否需要收缩</span></span><br><span class="line">            <span class="keyword">while</span> (valid == needMap.size()) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首先更新最小覆盖子串的索引和长度</span></span><br><span class="line">                <span class="comment">// right 自增过一次</span></span><br><span class="line">                <span class="keyword">if</span> (right - left &lt; len) &#123;</span><br><span class="line">                    len = right - left;</span><br><span class="line">                    start = left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 找到出窗口的元素</span></span><br><span class="line">                <span class="keyword">char</span> d = s.charAt(left);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 窗口右移</span></span><br><span class="line">                left++;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 更新窗口中的数据</span></span><br><span class="line">                <span class="keyword">if</span> (windowsMap.containsKey(d)) &#123;</span><br><span class="line">                    <span class="comment">// 刚好移除左端点元素后, 滑动窗口不包含目标字符串了</span></span><br><span class="line">                    <span class="keyword">if</span> (windowsMap.get(d).equals(needMap.get(d))) &#123;</span><br><span class="line">                        valid--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    windowsMap.put(d, windowsMap.getOrDefault(d, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start, start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210916231121253.png" alt="image-20210916231121253"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-76-最小覆盖子串&quot;&gt;&lt;a href=&quot;#力扣-76-最小覆盖子串&quot; class=&quot;headerlink&quot; title=&quot;力扣 76. 最小覆盖子串&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/mini</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="http://zhoushing.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>设计哈希映射</title>
    <link href="http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.html"/>
    <id>http://zhoushing.github.io/2021-09-16-%E8%AE%BE%E8%AE%A1%E5%93%88%E5%B8%8C%E6%98%A0%E5%B0%84.html</id>
    <published>2021-09-16T02:12:50.000Z</published>
    <updated>2021-09-16T02:52:03.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-706-设计哈希映射"><a href="#力扣-706-设计哈希映射" class="headerlink" title="力扣 706. 设计哈希映射"></a>力扣 <a href="https://leetcode-cn.com/problems/design-hashmap/">706. 设计哈希映射</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>不使用任何内建的哈希表库设计一个哈希映射（HashMap）。</p><p>实现 MyHashMap 类：</p><ul><li>MyHashMap() 用空映射初始化对象</li><li>void put(int key, int value) 向 HashMap 插入一个键值对 (key, value) 。如果 key 已经存在于映射中，则更新其对应的值 value 。</li><li>int get(int key) 返回特定的 key 所映射的 value ；如果映射中不包含 key 的映射，返回 -1 。</li><li>void remove(key) 如果映射中存在 key 的映射，则移除 key 和它所对应的 value 。</li></ul><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= key, value &lt;= 10^6</code></li><li>最多调用 <code>10^4</code> 次 <code>put</code>、<code>get</code> 和 <code>remove</code> 方法</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyHashMap&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;remove&quot;, &quot;get&quot;]</span><br><span class="line">[[], [1, 1], [2, 2], [1], [3], [2, 1], [2], [2], [2]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, 1, -1, null, 1, null, -1]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyHashMap myHashMap = new MyHashMap();</span><br><span class="line">myHashMap.put(1, 1); // myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.put(2, 2); // myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(1);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.get(3);    // 返回 -1（未找到），myHashMap 现在为 [[1,1], [2,2]]</span><br><span class="line">myHashMap.put(2, 1); // myHashMap 现在为 [[1,1], [2,1]]（更新已有的值）</span><br><span class="line">myHashMap.get(2);    // 返回 1 ，myHashMap 现在为 [[1,1], [2,1]]</span><br><span class="line">myHashMap.remove(2); // 删除键为 2 的数据，myHashMap 现在为 [[1,1]]</span><br><span class="line">myHashMap.get(2);    // 返回 -1（未找到），myHashMap 现在为 [[1,1]]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数据结构设计算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了链表数组的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 键值对内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Pair</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> key;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getKay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预定内存大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BASE = <span class="number">769</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链表数组, jdk 1.8 之前 HashMap 的主要实现方式</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算哈希值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num % BASE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        data = <span class="keyword">new</span> LinkedList[BASE];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化各个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">            data[i] = <span class="keyword">new</span> LinkedList&lt;Pair&gt;(); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** value will always be non-negative. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        <span class="comment">// 获取迭代器, AbstractSequentialList 定义的方法 iterator()</span></span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="comment">// 找到对应键值就改变</span></span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                pair.setValue(value);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没找到就添加</span></span><br><span class="line">        data[h].addLast(<span class="keyword">new</span> Pair(key, value));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                <span class="keyword">return</span> pair.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the mapping of the specified value key if this map contains a mapping for the key */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = hash(key);</span><br><span class="line">        Iterator&lt;Pair&gt; iter = data[h].iterator();</span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            Pair pair = iter.next();</span><br><span class="line">            <span class="keyword">if</span> (pair.getKay() == key) &#123;</span><br><span class="line">                data[h].remove(pair);</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyHashMap object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyHashMap obj = new MyHashMap();</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.remove(key);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210916105128403.png" alt="image-20210916105128403"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-706-设计哈希映射&quot;&gt;&lt;a href=&quot;#力扣-706-设计哈希映射&quot; class=&quot;headerlink&quot; title=&quot;力扣 706. 设计哈希映射&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/d</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="设计" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>最长有效括号</title>
    <link href="http://zhoushing.github.io/2021-09-15-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html"/>
    <id>http://zhoushing.github.io/2021-09-15-%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7.html</id>
    <published>2021-09-15T03:04:23.000Z</published>
    <updated>2021-09-15T03:10:25.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-32-最长有效括号"><a href="#力扣-32-最长有效括号" class="headerlink" title="力扣 32. 最长有效括号"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个只包含 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 的字符串，找出最长有效（格式正确且连续）括号子串的长度。</p><ul><li><strong>提示：</strong><ul><li><code>0 &lt;= s.length &lt;= 3 * 10^4</code></li><li><code>s[i]</code> 为 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(()&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：最长有效括号子串是 &quot;()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;)()())&quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最长有效括号子串是 &quot;()()&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接动态规划状态转移的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">// 根据右括号来判定</span></span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 当前一个符号为 ( 时, 说明此刻至少拥有一对括号, 可以从 i-2 的状态转移过来</span></span><br><span class="line">                <span class="comment">// 诸如 () 或者 ()() 的形式</span></span><br><span class="line">                <span class="keyword">if</span> (s.charAt(i - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = (i &gt;= <span class="number">2</span> ? dp[i - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="comment">// 当前一个符号为 ) 时, 判断前面对应的位置是不是 ( </span></span><br><span class="line">                <span class="comment">// 因为是从前往后计算的, 所以 (()) 这样的计算肯定在 ((())) 之前</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (i - dp[i - <span class="number">1</span>] &gt; <span class="number">0</span> &amp;&amp; s.charAt(i - dp[i - <span class="number">1</span>] - <span class="number">1</span>) == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + ((i - dp[i - <span class="number">1</span>]) &gt;= <span class="number">2</span> ? dp[i - dp[i - <span class="number">1</span>] - <span class="number">2</span>] : <span class="number">0</span>) + <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 累计最大值</span></span><br><span class="line">                max = Math.max(max, dp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915111008675.png" alt="image-20210915111008675"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-32-最长有效括号&quot;&gt;&lt;a href=&quot;#力扣-32-最长有效括号&quot; class=&quot;headerlink&quot; title=&quot;力扣 32. 最长有效括号&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/long</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>合并K个升序链表</title>
    <link href="http://zhoushing.github.io/2021-09-15-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-09-15-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-09-15T02:02:40.000Z</published>
    <updated>2021-09-15T02:06:34.458Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-23-合并K个升序链表"><a href="#力扣-23-合并K个升序链表" class="headerlink" title="力扣 23. 合并K个升序链表"></a>力扣 <a href="https://leetcode-cn.com/problems/merge-k-sorted-lists/">23. 合并K个升序链表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个链表数组，每个链表都已经按升序排列。</p><p>请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><ul><li><strong>提示：</strong><ul><li><code>k == lists.length</code></li><li><code>0 &lt;= k &lt;= 10^4</code></li><li><code>0 &lt;= lists[i].length &lt;= 500</code></li><li><code>-10^4 &lt;= lists[i][j] &lt;= 10^4</code></li><li><code>lists[i] 按 升序 排列</code></li><li><code>lists[i].length 的总和不超过 10^4</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[1,4,5],[1,3,4],[2,6]]</span><br><span class="line">输出：[1,1,2,3,4,4,5,6]</span><br><span class="line">解释：链表数组如下：</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line">将它们合并到一个有序链表中得到。</span><br><span class="line">1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：lists = [[]]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接采用了遍历链表并记录最小值的方法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     * 遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeKLists</span><span class="params">(ListNode[] lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = lists.length;</span><br><span class="line">        <span class="comment">// 链表数组为空</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只有一个链表</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line">        ListNode temp = result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (tick != n) &#123;</span><br><span class="line">            tick = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> min = <span class="number">10050</span>;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 记录最小值以及出现的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lists[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    tick++;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (lists[i].val &lt; min) &#123;</span><br><span class="line">                        min = lists[i].val;</span><br><span class="line">                        list.clear();</span><br><span class="line">                        list.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (lists[i].val == min) &#123;</span><br><span class="line">                        list.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 值记录以及链表移动</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i : list) &#123;</span><br><span class="line">                temp.next = lists[i];</span><br><span class="line">                temp = temp.next;</span><br><span class="line">                lists[i] = lists[i].next;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915100603081.png" alt="image-20210915100603081"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-23-合并K个升序链表&quot;&gt;&lt;a href=&quot;#力扣-23-合并K个升序链表&quot; class=&quot;headerlink&quot; title=&quot;力扣 23. 合并K个升序链表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>子集</title>
    <link href="http://zhoushing.github.io/2021-09-14-%E5%AD%90%E9%9B%86.html"/>
    <id>http://zhoushing.github.io/2021-09-14-%E5%AD%90%E9%9B%86.html</id>
    <published>2021-09-14T14:29:17.000Z</published>
    <updated>2021-09-14T14:32:50.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-10-正则表达式匹配"><a href="#力扣-10-正则表达式匹配" class="headerlink" title="力扣 10. 正则表达式匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数数组 <code>nums</code> ，数组中的元素 <strong>互不相同</strong> 。返回该数组所有可能的子集（幂集）。</p><p>解集 <strong>不能</strong> 包含重复的子集。你可以按 <strong>任意顺序</strong> 返回解集。</p><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= nums.length &lt;= 10</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有元素 <strong>互不相同</strong></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以直接向后遍历，遇到一个数就把所有子集加上该数组成新的子集，遍历完毕即是所有子集</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        List&lt;Integer&gt; temp = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> size = result.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先遍历result里的集合，取出来加上nums[i]作为一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; size; j++) &#123;</span><br><span class="line">            temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">            temp.addAll(result.get(j));</span><br><span class="line"></span><br><span class="line">            temp.add(nums[i]);</span><br><span class="line">            result.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历完result集合后，要把nums[i]本身也作为一个元素保存</span></span><br><span class="line">        temp = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        temp.add(nums[i]);</span><br><span class="line"></span><br><span class="line">        result.add(temp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后添加一个空元素</span></span><br><span class="line">    result.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210914223150479.png" alt="image-20210914223150479"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#力扣-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 10. 正则表达式匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/r</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式匹配</title>
    <link href="http://zhoushing.github.io/2021-09-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html"/>
    <id>http://zhoushing.github.io/2021-09-14-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D.html</id>
    <published>2021-09-14T13:17:53.000Z</published>
    <updated>2021-09-14T13:37:28.255Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-10-正则表达式匹配"><a href="#力扣-10-正则表达式匹配" class="headerlink" title="力扣 10. 正则表达式匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/regular-expression-matching/">10. 正则表达式匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 ‘.’ 和 ‘*’ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符</li><li>‘*’ 匹配零个或多个前面的那一个元素</li></ul><p>所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。</p><ul><li><strong>提示：</strong><ul><li>0 &lt;= s.length &lt;= 20</li><li>0 &lt;= p.length &lt;= 30</li><li>s 可能为空，且只包含从 a-z 的小写字母。</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</li><li>保证每次出现字符 * 时，前面都匹配到有效的字符</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a&quot;</span><br><span class="line">输出：false</span><br><span class="line">解释：&quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aa&quot; p = &quot;a*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &#x27;a&#x27;。因此，字符串 &quot;aa&quot; 可被视为 &#x27;a&#x27; 重复了一次。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ab&quot; p = &quot;.*&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：&quot;.*&quot; 表示可匹配零个或多个（&#x27;*&#x27;）任意字符（&#x27;.&#x27;）。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot; p = &quot;c*a*b&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：因为 &#x27;*&#x27; 表示零个或多个，这里 &#x27;c&#x27; 为 0 个, &#x27;a&#x27; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串匹配算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以使用动态规划来求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = s.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] cp = p.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dp[i][j]: 表示s的前i个字符, p的前j个字符是否能够匹配</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[cs.length + <span class="number">1</span>][cp.length + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// s, p 都为空的时候是匹配的, 而其他都预设是不匹配的</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当某位字符为 * 时, 它可以抵消前一个字符, 所以存在下述转移式</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cp.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cp[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 比较两个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= cs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= cp.length; j++) &#123;</span><br><span class="line">                <span class="comment">// 当两个字符相等 or p 字符串当前字符串是万能字符 .</span></span><br><span class="line">                <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">1</span>] || cp[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 可以直接抵消, 等于上次的结果</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当匹配到 * 时</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cp[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 字符串s * 的前一个字符能够跟字符串p 的末位匹配上时</span></span><br><span class="line">                    <span class="keyword">if</span> (cs[i - <span class="number">1</span>] == cp[j - <span class="number">2</span>] || cp[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 对应的两种状态:</span></span><br><span class="line">                        <span class="comment">// dp[i][j] = dp[i][j - 2] 匹配 0 次</span></span><br><span class="line">                        <span class="comment">// dp[i][j] = dp[i - 1][j] 匹配 1到多 次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>] || dp[i - <span class="number">1</span>][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 不能匹配</span></span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 只能匹配 0 次</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[cs.length][cp.length];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210914212852472.png" alt="image-20210914212852472"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-10-正则表达式匹配&quot;&gt;&lt;a href=&quot;#力扣-10-正则表达式匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 10. 正则表达式匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/r</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>初识设计模式</title>
    <link href="http://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
    <id>http://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</id>
    <published>2021-09-13T14:37:19.000Z</published>
    <updated>2021-09-17T13:25:54.006Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>想必大家都知道，在面向对象中，存在着三大特性和五大原则：</p><ul><li>三大原则<ul><li>封装</li><li>继承</li><li>多态</li></ul></li><li>五大原则<ul><li>单一职责原则（Single Responsibility Principle）</li><li>开放封闭原则（Open－Close Principle）</li><li>里氏替换原则（the Liskov Substitution Principle）</li><li>依赖倒置原则（the Dependency Inversion Principle）</li><li>接口分离原则（the Interface Segregation Principle）</li></ul></li></ul><p>今天，我们的主角不是面向对象，而是设计模式，在设计模式中同样也存在着六大原则，和上述的五大原有着重复：</p><ul><li>六大原则<ul><li>单一职责原则，实现类要职责单一；</li><li>开闭原则，要对扩展开放，对修改关闭；</li><li>里氏替换原则，所有引用父类的地方必须能透明地使用其子类的对象；</li><li>依赖倒置原则，要面向接口编程，不要面向实现编程；</li><li>接口隔离原则，使用多个专门的接口，而不使用单一的总接口，即调用方不应该依赖那些它不需要的接口；</li><li>迪米特原则，只与你的直接朋友交谈，不跟“陌生人”说话，要降低耦合。</li></ul></li></ul><p>下面我们来一一解释。</p><p>上述五大原则、六大原则仅是作者个人认为，还有包括诸如合成复用等原则，也是很有用的原则，请读者去自行了解。</p><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><h3 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h3><p><strong>定义</strong>：一个类只应该负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p><p><strong>问题由来：</strong>当类T负责两个不同的职责时，当由于职责1需求发生改变而需要修改类T时，有可能会导致原本运行正常的职责2功能发生故障。</p><p>单一职责原则告诉我们：<strong>一个类不应该担负太多的责任，就像996的你一样！</strong>在软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。</p><p>单一职责原则是实现<strong>高内聚、低耦合</strong>的指导方针，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。</p><p><strong>单一职责原的优点有：</strong></p><ol><li><p>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</p></li><li><p>提高类的可读性，提高系统的可维护性；</p></li><li><p>降低变更引起的风险，变更是不可避免的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</p></li></ol><h3 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h3><p><strong>定义：</strong>一个软件实体应当对扩展开放，对修改关闭。即<strong>软件实体应尽量在不修改原有代码的情况下进行功能扩展</strong>。</p><p><strong>问题由来：</strong>任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。因为变化，升级和维护等原因，如果需要对软件原有代码进行修改，可能会给旧代码引入错误，也有可能会使我们不得不对整个功能进行重构，并且需要对原有代码经过重新测试。所以当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现使我们需要的。</p><p>为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在Java、C#等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务功能即可，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。</p><p><strong>为什么使用开闭原则：</strong></p><p>第一：开闭原则非常有名</p><p>只要是面向对象编程，在开发时都会强调开闭原则。</p><p>第二：开闭原则是最基础的设计原则</p><p>其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，而开闭原则才是其精神领袖。依照Java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。</p><p>第三：开闭原则可以提高复用性</p><p>在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，而不是在一个类中独立实现一套业务逻辑。只有这样的代码才可以复用，逻辑粒度越小，被复用的可能性越大。为什么要复用呢？复用可以减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量以及系统变化时产生bug的机会。怎么才能提高复用率呢？设计者需要缩小逻辑粒度，直到一个逻辑不可以分为止。</p><p>第四：开闭原则可以提高维护性</p><p>一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，再进行修改，是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后再修改，那是对维护人员的折磨和摧残。</p><p>第五：面向对象开发的要求</p><p>万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到尽可能多变化的因素，然后留下接口，等待“可能”转变为“现实”。</p><p><strong>如何使用开闭原则</strong></p><p>第一：抽象约束<br>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：</p><p>1.通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。</p><p>2.参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求。</p><p>3.抽象层尽量保持稳定，一旦确定就不要修改。</p><p>第二：元数据(metadata)控件模块行为</p><p>编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p><p>第三：制定项目章程<br>在一个团队中，建立项目章程是非常重要的，因为章程是所有开发人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。</p><p>第四：封装变化</p><p>对变化封装包含两层含义：</p><p>(1)将相同的变化封装到一个接口或抽象类中。</p><p>(2)将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。 封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。</p><h3 id="里氏替换原则"><a href="#里氏替换原则" class="headerlink" title="里氏替换原则"></a>里氏替换原则</h3><p><strong>定义</strong>：里氏代换原则：<strong>所有引用基类（父类）的地方必须能透明地使用其子类的对象</strong>。</p><p><strong>继承优点</strong></p><p>代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；提高代码的重用性；子类可以形似父类，但又异于父类；提高代码的可扩展性，实现父类的方法就可以“为所欲为”了；提高产品或项目的开放性。</p><p><strong>继承缺点</strong></p><p><strong>继承是侵入性的。</strong>只要继承，就必须拥有父类的所有属性和方法；降低代码的灵活性。子类必须拥有父类的属性和方法；</p><p><strong>增强了耦合性。</strong>当父类的常量、变量和方法被修改时，必需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果，大片的代码需要重构。</p><p><strong>克服继承的缺点——里氏替换原则</strong></p><p>从整体上来看，利大于弊。</p><p>里氏代换原则告诉我们，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立，如果一个软件实体使用的是一个子类对象的话，那么它不一定能够使用基类对象。例如：我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢动物，因为我并不喜欢老鼠，虽然它也是动物。</p><p>里氏代换原则是实现开闭原则的重要方式之一，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。</p><p>在使用里氏代换原则时需要注意如下几个问题：</p><p>(1)子类的所有方法必须在父类中声明，或子类必须实现父类中声明的所有方法。根据里氏代换原则，为了保证系统的扩展性，在程序中通常使用父类来进行定义，如果一个方法只存在子类中，在父类中不提供相应的声明，则无法在以父类定义的对象中使用该方法。</p><p>(2) 我们在运用里氏代换原则时，尽量把父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法，运行时，子类实例替换父类实例，我们可以很方便地扩展系统的功能，同时无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。里氏代换原则是开闭原则的具体实现手段之一。</p><p>(3) Java语言中，在编译阶段，Java编译器会检查一个程序是否符合里氏代换原则，这是一个与实现无关的、纯语法意义上的检查，但Java编译器的检查是有局限的。</p><h3 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h3><p><strong>定义：</strong></p><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象，其核心思想是：<strong>要面向接口编程，不要面向实现编程</strong>。</p><p>依赖倒转原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。</p><p>在引入抽象层后，系统将具有很好的灵活性，在程序中尽量使用抽象层进行编程，而将具体类写在配置文件中，这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。</p><p>在实现依赖倒转原则时，我们需要针对抽象层编程，而将具体类的对象通过依赖注入(DependencyInjection, DI)的方式注入到其他对象中，依赖注入是指当一个对象要与其他对象发生依赖关系时，通过抽象来注入所依赖的对象。常用的注入方式有三种，分别是：构造注入，设值注入（Setter注入）和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。</p><p><strong>依赖倒置原则的作用</strong></p><p>（1）依赖倒置原则可以降低类间的耦合性。</p><p>（2）依赖倒置原则可以提高系统的稳定性。</p><p>（3）依赖倒置原则可以减少并行开发引起的风险。</p><p>（4）依赖倒置原则可以提高代码的可读性和可维护性。</p><p><strong>依赖倒置原则的实现方法</strong></p><p>依赖倒置原则的目的是通过要面向接口的编程来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。</p><p>（1）每个类尽量提供接口或抽象类，或者两者都具备。</p><p>（2）变量的声明类型尽量是接口或者是抽象类。</p><p>（3）任何类都不应该从具体类派生。</p><p>（4）使用继承时尽量遵循里氏替换原则。</p><h3 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h3><p><strong>定义：</strong>使用多个专门的接口，而不使用单一的总接口，即<strong>客户端不应该依赖那些它不需要的接口</strong>。</p><p>根据接口隔离原则，当一个接口太大时，我们需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”定义，有严格的定义和结构，比如Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义都有所不同：</p><p>(1) 当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以叫做“角色隔离原则”。</p><p>(2) 如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责不同分别放在不同的小接口中，以确保每个接口使用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。</p><p>接口隔离原则和单一职责都是为了提高类的内聚性、降低它们之间的耦合性，体现了封装的思想，但两者是不同的：</p><p>（1）单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</p><p>（2）单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。</p><p><strong>接口隔离原则的优点</strong></p><p>接口隔离原则是为了约束接口、降低类对接口的依赖性，遵循接口隔离原则有以下 5 个优点：</p><p>（1）将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>（2）接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</p><p>（3）如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</p><p>（4）使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</p><p>（5）能减少项目工程中的代码冗余。过大的大接口里面通常放置许多不用的方法，当实现这个接口的时候，被迫设计冗余的代码。</p><p><strong>接口隔离原则的实现方法</strong></p><p>在具体应用接口隔离原则时，应该根据以下几个规则来衡量：</p><p>（1）接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</p><p>（2）为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</p><p>（3）了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</p><p>（4）提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><h3 id="迪米特原则"><a href="#迪米特原则" class="headerlink" title="迪米特原则"></a>迪米特原则</h3><p><strong>定义：</strong>迪米特法则(Law of Demeter, LoD)：<strong>一个软件实体应当尽可能少地与其他实体发生相互作用。</strong></p><p>迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，产生于 1987 年美国东北大学（Northeastern University）的一个名为迪米特（Demeter）的研究项目，由伊恩·荷兰（Ian Holland）提出，被 UML 创始者之一的布奇（Booch）普及，后来又因为在经典著作《程序员修炼之道》（The Pragmatic Programmer）提及而广为人知。</p><p>迪米特法则的定义是：只与你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p><p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p><p>在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要与“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。</p><p>迪米特法则要求我们在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应当发生任何直接的相互作用，如果其中的一个对象需要调用另一个对象的某一个方法的话，可以通过第三者转发这个调用。简言之，就是通过引入一个合理的第三者来降低现有对象之间的耦合度。</p><p>在将迪米特法则运用到系统设计中时，要注意下面的几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，就越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大波及；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。</p><p><strong>迪米特法则的优点</strong></p><p>迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。</p><p>降低了类之间的耦合度，提高了模块的相对独立性。</p><p>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</p><p>但是，<strong>过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低</strong>。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。</p><p><strong>迪米特法则的实现方法</strong></p><p>从迪米特法则的定义和特点可知，它强调以下两点：</p><p>从依赖者的角度来说，只依赖应该依赖的对象。</p><p>从被依赖者的角度说，只暴露应该暴露的方法。</p><p>所以，在运用迪米特法则时要注意以下 6 点：</p><ol><li><p>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</p></li><li><p>在类的结构设计上，尽量降低类成员的访问权限。</p></li><li><p>在类的设计上，优先考虑将一个类设置成不变类。</p></li><li><p>在对其他类的引用上，将引用其他对象的次数降到最低。</p></li><li><p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p></li><li><p>谨慎使用序列化（Serializable）功能。</p></li></ol><h3 id="六大原则总结"><a href="#六大原则总结" class="headerlink" title="六大原则总结"></a>六大原则总结</h3><p>单一职责原则告诉我们实现类要职责单一；</p><p>里氏替换原则告诉我们不要破坏继承体系；</p><p>依赖倒置原则告诉我们要面向接口编程；</p><p>接口隔离原则告诉我们在设计接口的时候要精简单一；</p><p>迪米特原则告诉我们要降低耦合；</p><p>开闭原则是总纲，告诉我们要对扩展开放，对修改关闭。</p><p>但是在实际项目中出现问题都是不可避免的，使用<strong>六大原则的前提是要保证系统的稳定性，不可照本宣科造成系统设计过度或者影响系统运行</strong>。</p><h2 id="二十三种设计模式"><a href="#二十三种设计模式" class="headerlink" title="二十三种设计模式"></a>二十三种设计模式</h2><p>23种经典设计模式共分为3种类型，分别是创建型、结构型和行为型。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210915170151978.png" alt="image-20210915170151978"></p><p>具体的在之后的<a href="https://zhoushing.github.io/2021-09-13-%E5%88%9D%E8%AF%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html">设计模式入门</a>之中再继续讲解。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.html.cn/qa/other/22063.html">设计模式六大原则是什么</a>  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;想必大家都知道，在面向对象中，存在着三大特性和五大原则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三大原则&lt;ul&gt;
&lt;li&gt;封装&lt;/li&gt;
&lt;li&gt;继承&lt;</summary>
      
    
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://zhoushing.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>颜色分类</title>
    <link href="http://zhoushing.github.io/2021-09-13-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html"/>
    <id>http://zhoushing.github.io/2021-09-13-%E9%A2%9C%E8%89%B2%E5%88%86%E7%B1%BB.html</id>
    <published>2021-09-13T11:08:28.000Z</published>
    <updated>2021-09-13T11:14:52.362Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-75-颜色分类"><a href="#力扣-75-颜色分类" class="headerlink" title="力扣 75. 颜色分类"></a>力扣 <a href="https://leetcode-cn.com/problems/sort-colors/">75. 颜色分类</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，<strong>原地</strong>对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</p><p>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</p><ul><li><strong>提示：</strong><ul><li><code>n == nums.length</code></li><li><code>1 &lt;= n &lt;= 300</code></li><li><code>nums[i]</code> 为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,2,1,1,0]</span><br><span class="line">输出：[0,0,1,1,2,2]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,0,1]</span><br><span class="line">输出：[0,1,2]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以将 2 和 0 放在该在的位置，1 的位置自然也就确定了</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortColors</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 标记 0 和 2 的位置</span></span><br><span class="line">        <span class="keyword">int</span> tick0 = <span class="number">0</span>, tick2 = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将2和0放置到合适的位置后,1就在自己的位置了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= tick2; ++i) &#123;</span><br><span class="line">            <span class="comment">// 如果当前值等于2,就不断向数组尾部置换</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt;= tick2 &amp;&amp; nums[i] == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[tick2];</span><br><span class="line">                nums[tick2] = temp;</span><br><span class="line">                --tick2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 置换完之后,如果当前位置是 0, 则可以将它与 0 标志数交换</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[tick0];</span><br><span class="line">                nums[tick0] = temp;</span><br><span class="line">                ++tick0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210913191225466.png" alt="image-20210913191225466"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-75-颜色分类&quot;&gt;&lt;a href=&quot;#力扣-75-颜色分类&quot; class=&quot;headerlink&quot; title=&quot;力扣 75. 颜色分类&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/sort-color</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="http://zhoushing.github.io/2021-09-13-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-09-13-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-09-13T07:28:50.000Z</published>
    <updated>2021-09-13T07:34:54.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-98-验证二叉搜索树"><a href="#力扣-98-验证二叉搜索树" class="headerlink" title="力扣 98. 验证二叉搜索树"></a>力扣 <a href="https://leetcode-cn.com/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><ul><li>节点的左子树只包含 小于 当前节点的数。</li><li>节点的右子树只包含 大于 当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><ul><li><strong>提示：</strong><ul><li>树中节点数目范围在<code>[1, 10^4]</code> 内</li><li><code>-2^31 &lt;= Node.val &lt;= 2^31 - 1</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/tree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/tree2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,1,4,null,null,3,6]</span><br><span class="line">输出：false</span><br><span class="line">解释：根节点的值是 5 ，但是右子节点的值是 4 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道 BST 算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>直接使用了二叉搜索树的性质进行求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 中序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 单一节点</span></span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = dfs(list, root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 因为 BST 的中序遍历是有序的,所以我们可以利用这一特性来判断一棵树是不是 BST</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(List&lt;Integer&gt; list, TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> tick = dfs(list, root.left);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!list.isEmpty() &amp;&amp; root.val &lt;= list.get(list.size() - <span class="number">1</span>)) &#123;</span><br><span class="line">            tick = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        list.add(root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tick &amp;&amp; dfs(list, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率都一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210913153447970.png" alt="image-20210913153447970"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-98-验证二叉搜索树&quot;&gt;&lt;a href=&quot;#力扣-98-验证二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;力扣 98. 验证二叉搜索树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/v</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉搜索树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>什么是红黑树</title>
    <link href="http://zhoushing.github.io/2021-09-11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-09-11-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91.html</id>
    <published>2021-09-11T13:21:09.727Z</published>
    <updated>2021-09-12T14:24:36.523Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p><a href="https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413209?fr=aladdin">红黑树</a>（Red Black Tree） 是一种自平衡二叉查找树，是在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>科学中用到的一种<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>，典型的用途是实现<a href="https://baike.baidu.com/item/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84/3317025">关联数组</a>。</p><p>红黑树是一种特化的AVL树（<a href="https://baike.baidu.com/item/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/10421057">平衡二叉树</a>），都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。</p><p>它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在 O(log n) 时间内做查找，插入和删除，这里的 n 是树中元素的数目，这代表着它是<strong>牺牲编程效率提升性能</strong>的数据结构的代表。</p><p>在面试时，红黑树相关的问题也屡见不鲜，比如：红黑树的特性和优势，在什么情况需要变色，什么情况需要旋转？下面就对这些问题进行解读，要了解红黑树，我们需要先了解二叉查找树（Binary Search Tree）。</p><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p><a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91/10905079?fromtitle=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&fromid=7077965&fr=aladdin">二叉查找树</a>（BST），又称二叉排序树，亦称<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/7077855">二叉搜索树</a>。它是<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1450">数据结构</a>中的一类，在一般情况下，查询效率比链表结构要高。</p><p>定义：</p><p>一棵空树，或者是具有下列性质的<a href="https://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a>：</p><p>（1）若左子树不空，则左子树上所有<a href="https://baike.baidu.com/item/%E7%BB%93%E7%82%B9/9794643">结点</a>的值均小于或等于它的<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570">根结点</a>的值；</p><p>（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</p><p>（3）左、右子树也分别为二叉排序树；</p><p>不同的教材定义略微有些不同，但不影响使用，下图中的树，就是一颗典型的二叉搜索树：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912222434072.png" alt="image-20210912222434072"></p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>数组的搜索比较方便，可以直接用下标，但删除或者插入某些元素就比较麻烦；链表与之相反，删除和插入元素很快，但查找很慢。<br>而二叉排序树是一种比较有用的折衷方案，它就既有链表的好处，也有数组的好处，在处理大批量的动态的数据是比较有用。</p><p>从上面的图，我们可以轻松看出二叉排序树在查找元素时的方式正是二分查找的思想，同理，导致它可以在 O(log n) 时间内做查找，插入和删除操作。</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>但是二叉搜索树仍存在它的缺陷，缺陷在某些情况下插入新节点，会导致它退化成链表，例如下图的情况：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210911221255634.png" alt="image-20210911221255634"></p><p>这种形态的二叉树也符合二叉搜索树的特性，但相关操作的性能大打折扣，几乎退化成了线性O(n)，如何解决这种问题呢？红黑树这种数据结构就应运而生。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>如引入中说到的那样，红黑树是一种自平衡二叉查找树，说“自平衡”是因为它不严格保持平衡二叉树的性质，它的左右子树高差有可能大于 1。红黑树除了符合二叉查找树的基本特性外，它还有以下附加特性：</p><ol><li>节点分为红色和黑色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色的空节点（null）</li><li>每个红色节点的两个节点都是黑色（也就是从每个叶子到根的所有的根的所有路径上不能有两个连续的红色节点）</li><li>从任意一个节点到它的每个叶子节点的所有路径都包含相同数目的黑色节点（**最终是为了让任意节点到属于它的任意叶子结点的路径包含相同数目的黑色节点(根节点,叶子结点也算在数目内)**）</li></ol><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210911223814194.png" alt="image-20210911223814194"></p><p>上图就是一颗经典的红黑树。</p><p>上述的约束确保了红黑树的关键特性：<strong>从根到叶子的最长的可能路径不多于最短的可能路径的两倍长</strong>。结果是这个树大致上是平衡的。因为操作比如插入、删除和查找某个值的最坏情况时间都要求与树的高度成比例，这个在高度上的理论上限允许红黑树在最坏情况下都是高效的，而不同于普通的<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">二叉查找树</a>。</p><p>而在插入或者删除节点时，红黑树的规则可能会被打破。这个时候又需要做出一些调整，来继续维持红黑树的规则。争对这些变化，红黑树存在对节点的三种操作：</p><h3 id="变色"><a href="#变色" class="headerlink" title="变色"></a>变色</h3><p>为了重新符合红黑树的规则，尝试把将红黑树中红色节点变为黑色，或者把黑色节点变为红色。例如在插入一个节点21（<strong>如果插入节点是黑色，就一定会违背每条查找线上黑色节点个数一致的规则，插入红色，就可能不需要变色或者旋转，所以待插入节点都是红色</strong>）后，我们将节点22变成了黑色，避免了两个红色节点相邻：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912152002600.png" alt="image-20210912152002600"></p><p>但这是这一步操作并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912152126204.png" alt="image-20210912152126204"></p><p>此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912152256465.png" alt="image-20210912152256465"></p><p>要注意的是，上面的图只是红黑树的一部分，节点25也不是根节点，所以可以是红色，那如果是在一整棵上调整怎么办？那就要用到下面的旋转操作了；</p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><h4 id="左旋转"><a href="#左旋转" class="headerlink" title="左旋转"></a>左旋转</h4><p><strong>逆时针</strong>旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子，这就称作当前节点的左旋转，例如下图：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912153203841.png" alt="image-20210912153203841"></p><p>在上图中，身为右孩子的节点60取代了节点40的位置，而节点40变成了节点60的左孩子并且节点50按照大小移动到了节点40的右孩子。</p><h4 id="右旋转"><a href="#右旋转" class="headerlink" title="右旋转"></a>右旋转</h4><p>与左旋转相对应的就是左旋转，<strong>顺时针</strong>旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子，例如下图：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912153721325.png" alt="image-20210912153721325"></p><p>与之前的左旋转操作刚好相反，这里就不再赘述。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>我们以刚才插入节点21的情况为例：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912154457288.png" alt="image-20210912154457288"></p><p>在经过上面变色中举例的一系列操作后，红黑树变成了这样：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912154628759.png" alt="image-20210912154628759"></p><p>此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。</p><p>变色已无法解决问题，我们可以把节点13进行左旋转，像刚才的示意图那样进行<strong>左旋转</strong>：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912154831142.png" alt="image-20210912154831142"></p><p>左旋转后：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912154908801.png" alt="image-20210912154908801"></p><p>由于根节点必须是黑色节点，所以需要将节点17及左子树各节点进行<strong>变色</strong>，变色结果如下：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912154958520.png" alt="image-20210912154958520"></p><p>这样就结束了吗？并没有。因为其中两条路径(17 -&gt; 8 -&gt; 6 -&gt; NIL)的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。</p><p>这时候我们需要把节点13进行右旋转，像刚才的示意图那样进行<strong>右旋转</strong>：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912155445490.png" alt="image-20210912155445490"></p><p>最后根据规则来进行<strong>变色</strong>整理：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210912155529170.png" alt="image-20210912155529170"></p><p>在经过上面一系列变色和旋转组合的情况下，我们的红黑树变得重新符合规则，虽然操作看起来很复杂，但是在实际代码中，这样的操作耗费的时间量级并不大，不会影响到元素插入和删除的效率。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>红黑树是一种特殊的二叉搜索树，它牺牲了部分插入删除效率来避免了二叉搜索树退化成链表的情况，也避免了平衡二叉树过于追求平衡造成的频繁改动，总体还是比较高效方便的数据结构。它的应用场景比较经典的就是 JDK 集合类中的 TreeSet 和 TreeSet ，在JDK 1.8之后，HashMap 也变成了数组+链表/红黑树的实现方式，感兴趣的可以阅读相关的源码。</p><p>上述操作可以用比较通俗的话来说就是：<strong>在进行插入时，两个红色节点相邻就需要进行变色，当某一条查找线上黑节点多了就根据旋转规则把黑色节点从树分杈多的往树分杈少的地方转。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文参考了<a href="https://juejin.cn/post/6844903519632228365">什么是红黑树？</a> 和 <a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%BA%A2%E9%BB%91%E6%A0%91/2413</summary>
      
    
    
    
    <category term="数据结构系列" scheme="http://zhoushing.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="红黑树" scheme="http://zhoushing.github.io/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>合并区间</title>
    <link href="http://zhoushing.github.io/2021-09-11-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html"/>
    <id>http://zhoushing.github.io/2021-09-11-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4.html</id>
    <published>2021-09-11T03:01:30.000Z</published>
    <updated>2021-09-11T03:05:58.541Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-56-合并区间"><a href="#力扣-56-合并区间" class="headerlink" title="力扣 56. 合并区间"></a>力扣 <a href="https://leetcode-cn.com/problems/merge-intervals/">56. 合并区间</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</p><ul><li><strong>提示：</strong><ul><li><code>1 &lt;= intervals.length &lt;= 10^4</code></li><li><code>intervals[i].length == 2</code></li><li><code>0 &lt;= starti &lt;= endi &lt;= 10^4</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,3],[2,6],[8,10],[15,18]]</span><br><span class="line">输出：[[1,6],[8,10],[15,18]]</span><br><span class="line">解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：intervals = [[1,4],[4,5]]</span><br><span class="line">输出：[[1,5]]</span><br><span class="line">解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>先进行了排序，然后依次比较选择填入</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 合并区间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] merge(<span class="keyword">int</span>[][] intervals) &#123;</span><br><span class="line">        <span class="comment">// 先按照区间起始位置排序</span></span><br><span class="line">        Arrays.sort(intervals, (v1, v2) -&gt; v1[<span class="number">0</span>] - v2[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历区间</span></span><br><span class="line">        <span class="keyword">int</span>[][] res = <span class="keyword">new</span> <span class="keyword">int</span>[intervals.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> tick = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] interval: intervals) &#123;</span><br><span class="line">            <span class="comment">// 如果结果数组是空的，或者当前区间的起始位置 &gt; 结果数组中最后区间的终止位置，</span></span><br><span class="line">            <span class="comment">// 则不合并，直接将当前区间加入结果数组。</span></span><br><span class="line">            <span class="keyword">if</span> (tick == -<span class="number">1</span> || interval[<span class="number">0</span>] &gt; res[tick][<span class="number">1</span>]) &#123;</span><br><span class="line">                res[++tick] = interval;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 反之将当前区间合并至结果数组的最后区间</span></span><br><span class="line">                res[tick][<span class="number">1</span>] = Math.max(res[tick][<span class="number">1</span>], interval[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(res, tick + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210911110512241.png" alt="image-20210911110512241"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-56-合并区间&quot;&gt;&lt;a href=&quot;#力扣-56-合并区间&quot; class=&quot;headerlink&quot; title=&quot;力扣 56. 合并区间&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/merge-inte</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
