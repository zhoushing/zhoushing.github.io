<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2021-11-21T09:18:34.139Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</id>
    <published>2021-11-21T09:11:43.000Z</published>
    <updated>2021-11-21T09:18:34.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-236-二叉树的最近公共祖先"><a href="#力扣-236-二叉树的最近公共祖先" class="headerlink" title="力扣 236. 二叉树的最近公共祖先"></a>力扣 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [2, 10^5] 内。</li><li>-10^9 &lt;= Node.val &lt;= 10^9</li><li>所有 Node.val 互不相同 。</li><li>p != q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以通过分别判断左支右支包含目标两个节点的情况来判断公共祖宗节点的位置</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前根节点等于其中一个节点，直接得出当前节点是最近公共祖先节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果两个节点都在左支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都在右支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121171647061.png" alt="image-20211121171647061"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#力扣-236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;力扣 236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html</id>
    <published>2021-11-21T09:05:22.000Z</published>
    <updated>2021-11-21T09:11:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-287-寻找重复数"><a href="#力扣-287-寻找重复数" class="headerlink" title="力扣 287. 寻找重复数"></a>力扣 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= n &lt;= 10^5</li><li>nums.length == n + 1</li><li>1 &lt;= nums[i] &lt;= n</li><li>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现题目要求的是至少出现一个，所以就不能使用位运算了，这里可以将这个数组看成循环数组，然后使用快慢指针求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将出现重复元素的数组看成环，用快慢指针来查找重复出现的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast || fast == <span class="number">0</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[slow];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121170916265.png" alt="image-20211121170916265"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-287-寻找重复数&quot;&gt;&lt;a href=&quot;#力扣-287-寻找重复数&quot; class=&quot;headerlink&quot; title=&quot;力扣 287. 寻找重复数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/find</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>最长和谐子序列</title>
    <link href="http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-11-20T09:35:00.000Z</published>
    <updated>2021-11-20T09:39:48.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-594-最长和谐子序列"><a href="#力扣-594-最长和谐子序列" class="headerlink" title="力扣 594. 最长和谐子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,5,2,3,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的和谐子序列是 [3,2,2,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现因为本题不要求是子数组，所以可以直接对元素进行统计</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个元素出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sub = map.getOrDefault(key - <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> add = map.getOrDefault(key + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加一减一的数都没出现过就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sub == -<span class="number">1</span> &amp;&amp; add == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, value + Math.max(sub, add));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211120173839981.png" alt="image-20211120173839981"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-594-最长和谐子序列&quot;&gt;&lt;a href=&quot;#力扣-594-最长和谐子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 594. 最长和谐子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashMap" scheme="http://zhoushing.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>单词拆分</title>
    <link href="http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html"/>
    <id>http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html</id>
    <published>2021-11-18T13:44:22.000Z</published>
    <updated>2021-11-18T14:04:32.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-139-单词拆分"><a href="#力扣-139-单词拆分" class="headerlink" title="力扣 139. 单词拆分"></a>力扣 <a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 300</li><li>1 &lt;= wordDict.length &lt;= 1000</li><li>1 &lt;= wordDict[i].length &lt;= 20</li><li>s 和 wordDict[i] 仅有小写英文字母组成</li><li>wordDict 中的所有字符串 互不相同</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>需要注意题目中要求源字符串的匹配方式，在这里我们采取向后遍历所有字符串可能的方式，采用动态规划向后记录的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 代表空串都是匹配的</span></span><br><span class="line">        ticks[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接逐长度匹配字典，通过动态规划来向后传递组合的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticks[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    ticks[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ticks[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211118214949077.png" alt="image-20211118214949077"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-139-单词拆分&quot;&gt;&lt;a href=&quot;#力扣-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;力扣 139. 单词拆分&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/word-br</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长连续序列</title>
    <link href="http://zhoushing.github.io/2021-11-17-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-11-17-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html</id>
    <published>2021-11-17T08:40:42.000Z</published>
    <updated>2021-11-17T08:44:04.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-128-最长连续序列"><a href="#力扣-128-最长连续序列" class="headerlink" title="力扣 128. 最长连续序列"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>使用了HashSet来存储数组中数，利用他的contains方法来判断当前元素是否有后继</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * 向后延展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 其一是利用set的contains方法，也可以避免出现重复数值</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向后延展寻找是否有后继</span></span><br><span class="line">                <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result = Math.max(result, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211117164251562.png" alt="image-20211117164251562"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-128-最长连续序列&quot;&gt;&lt;a href=&quot;#力扣-128-最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 128. 最长连续序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/l</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashSet" scheme="http://zhoushing.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>最大单词长度乘积</title>
    <link href="http://zhoushing.github.io/2021-11-17-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.html"/>
    <id>http://zhoushing.github.io/2021-11-17-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.html</id>
    <published>2021-11-17T07:44:11.000Z</published>
    <updated>2021-11-17T07:52:08.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-318-最大单词长度乘积"><a href="#力扣-318-最大单词长度乘积" class="headerlink" title="力扣 318. 最大单词长度乘积"></a>力扣 <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个字符串数组 <code>words</code>，找到 <code>length(word[i]) * length(word[j])</code> 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 1000</code></li><li><code>words[i]</code> 仅包含小写字母</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>一开始就打算使用数组字母表来记录字符，后来发现题目中约束为小写字母，所以我们可以用二进制位数来代表字符串中对应的字符是否出现，再通过对应的记录数想与来判断两个字符串是否有重复字符</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 位运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个字符，用对应的二进制位来代表这个字母是否出现</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当两个数相遇等于0，代表这两个字符串没有字符相交</span></span><br><span class="line">                <span class="keyword">if</span> ((hash[i] &amp; hash[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(words[i].length() * words[j].length(), max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211117154720696.png" alt="image-20211117154720696"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-318-最大单词长度乘积&quot;&gt;&lt;a href=&quot;#力扣-318-最大单词长度乘积&quot; class=&quot;headerlink&quot; title=&quot;力扣 318. 最大单词长度乘积&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="位运算" scheme="http://zhoushing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="http://zhoushing.github.io/2021-11-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-11-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-11-16T07:03:19.000Z</published>
    <updated>2021-11-16T07:40:01.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-114-二叉树展开为链表"><a href="#力扣-114-二叉树展开为链表" class="headerlink" title="力扣 114. 二叉树展开为链表"></a>力扣 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现本题可以采用回溯的思想，前序遍历的顺序是根左右，所以我们选择按照最右、最左、根的顺序倒序回溯操作</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预先操作最右节点</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照右 左 根的顺序倒序操作，以尾指针标记最后操作节点</span></span><br><span class="line">        root.right = last;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        last = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211116152058590.png" alt="image-20211116152058590"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-114-二叉树展开为链表&quot;&gt;&lt;a href=&quot;#力扣-114-二叉树展开为链表&quot; class=&quot;headerlink&quot; title=&quot;力扣 114. 二叉树展开为链表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>完美矩形</title>
    <link href="http://zhoushing.github.io/2021-11-16-%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2.html"/>
    <id>http://zhoushing.github.io/2021-11-16-%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2.html</id>
    <published>2021-11-16T01:15:06.000Z</published>
    <updated>2021-11-16T07:40:39.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-391-完美矩形"><a href="#力扣-391-完美矩形" class="headerlink" title="力扣 391. 完美矩形"></a>力扣 <a href="https://leetcode-cn.com/problems/perfect-rectangle/">391. 完美矩形</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个数组 rectangles ，其中 rectangles[i] = [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= rectangles.length &lt;= 2 * 10^4</li><li>rectangles[i].length == 4</li><li>-10^5 &lt;= xi, yi, ai, bi &lt;= 10^5</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perectrec1-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfectrec2-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfectrec3-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：图形顶端留有空缺，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfecrrec4-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现在判断时，完美矩形的点中，除了外圈顶点之外其他点都是成对存在，而且所有小矩形的总面积等于外圈大矩形的面积</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleCover</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> top = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> bottom = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = rectangles.length;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sumArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempLeft = rectangles[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tempBottom = rectangles[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> tempRight = rectangles[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> tempTop = rectangles[i][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记最外圈的顶点，完美矩形的顶点总应该在最外圈</span></span><br><span class="line">            left = Math.min(left, tempLeft);</span><br><span class="line">            bottom = Math.min(bottom, tempBottom);</span><br><span class="line">            right = Math.max(right, tempRight);</span><br><span class="line">            top = Math.max(top, tempTop);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计每个小矩形的面积</span></span><br><span class="line">            sumArea += (tempTop - tempBottom) * (tempRight - tempLeft);</span><br><span class="line"></span><br><span class="line">            String lt = tempLeft + <span class="string">&quot;_&quot;</span> + tempTop;</span><br><span class="line">            String lb = tempLeft + <span class="string">&quot;_&quot;</span> + tempBottom;</span><br><span class="line">            String rt = tempRight + <span class="string">&quot;_&quot;</span> + tempTop;</span><br><span class="line">            String rb = tempRight + <span class="string">&quot;_&quot;</span> + tempBottom;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录每个点，完美矩形除了外圈四个顶点外，其他点应该是成对出现的</span></span><br><span class="line">            handlePoint(set, lt);</span><br><span class="line">            handlePoint(set, lb);</span><br><span class="line">            handlePoint(set, rt);</span><br><span class="line">            handlePoint(set, rb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当且仅当set集合只剩下四个顶点，而且刚好是最外圈的四个点时</span></span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">4</span> &amp;&amp; </span><br><span class="line">                set.contains(left + <span class="string">&quot;_&quot;</span> + top) &amp;&amp; set.contains(left + <span class="string">&quot;_&quot;</span> + bottom) &amp;&amp;</span><br><span class="line">                set.contains(right + <span class="string">&quot;_&quot;</span> + bottom) &amp;&amp; set.contains(right + <span class="string">&quot;_&quot;</span> + top)) &#123;</span><br><span class="line">            <span class="comment">// 而且所有小矩形的面积和等于外圈大矩形的面积时</span></span><br><span class="line">            <span class="keyword">return</span> sumArea == (right - left) * (top - bottom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作点，保存不重复点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePoint</span><span class="params">(HashSet&lt;String&gt; set, String point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(point)) &#123;</span><br><span class="line">            set.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211116091941567.png" alt="image-20211116091941567"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-391-完美矩形&quot;&gt;&lt;a href=&quot;#力扣-391-完美矩形&quot; class=&quot;headerlink&quot; title=&quot;力扣 391. 完美矩形&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/perfect</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>从前序与中序遍历序列构造二叉树</title>
    <link href="http://zhoushing.github.io/2021-11-15-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-11-15-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2021-11-15T07:44:22.000Z</published>
    <updated>2021-11-15T07:50:33.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-105-从前序与中序遍历序列构造二叉树"><a href="#力扣-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="力扣 105. 从前序与中序遍历序列构造二叉树"></a>力扣 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= preorder.length &lt;= 3000</li><li>inorder.length == preorder.length</li><li>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</li><li>preorder 和 inorder 均无重复元素</li><li>inorder 均出现在 preorder</li><li>preorder 保证为二叉树的前序遍历序列</li><li>inorder 保证为二叉树的中序遍历序列</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要分治构建节点以及左右子树即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line"></span><br><span class="line">        TreeNode result = buildNode(<span class="number">0</span>, n, <span class="number">0</span>, n, preorder, inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preLeft  前序左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preRight 前序右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inLeft   中序左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inRight  中序右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preorder 前序序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inorder  中序序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildNode</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右区间重合，无节点</span></span><br><span class="line">        <span class="keyword">if</span> (preLeft == preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前根节点</span></span><br><span class="line">        <span class="keyword">int</span> now = preorder[preLeft];</span><br><span class="line">        TreeNode result = <span class="keyword">new</span> TreeNode(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inLeft; i &lt; inRight; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == now) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别构建左右节点</span></span><br><span class="line">        result.left = buildNode(preLeft + <span class="number">1</span>, preLeft + tick + <span class="number">1</span>, inLeft, inLeft + tick, preorder, inorder);</span><br><span class="line">        result.right = buildNode(preLeft + tick + <span class="number">1</span>, preRight, inLeft + tick + <span class="number">1</span>, inRight, preorder, inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211115154932442.png" alt="image-20211115154932442"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#力扣-105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;力扣 105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>灯泡开关</title>
    <link href="http://zhoushing.github.io/2021-11-15-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3.html"/>
    <id>http://zhoushing.github.io/2021-11-15-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3.html</id>
    <published>2021-11-15T02:08:36.000Z</published>
    <updated>2021-11-15T02:15:57.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-319-灯泡开关"><a href="#力扣-319-灯泡开关" class="headerlink" title="力扣 319. 灯泡开关"></a>力扣 <a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。</p><p>第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。</p><p>找出并返回 n 轮后有多少个亮着的灯泡。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/bulb.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：1 </span><br><span class="line">解释：</span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 1，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道脑筋急转弯算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题明白原理后就豁然开朗了，我们可以看到题目n的范围是9次幂级的，所以平常的解决办法通常是不行的，我们可以仔细阅读题目再写几组数字，仔细想一下规律</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数学</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 第i个灯泡的反转次数等于它所有因子（包括1和i）的个数，</span></span><br><span class="line"><span class="comment">         * 一开始所有的灯泡都是灭的，只有当他反转奇数次才会变成亮，</span></span><br><span class="line"><span class="comment">         * 所以只有因子总个数为奇数的序号的灯泡才会亮，而且只有平方数的因子数为奇数</span></span><br><span class="line"><span class="comment">         * （比如6=1*6,2*3，它们的因子总是成对出现的，而4=1*4,2*2，平方数的平方根因子会出现1次），</span></span><br><span class="line"><span class="comment">         * 所以最终答案等于n以内（包括n和1）的平方数总数量，所以只需要计算sqrt(n)即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211115101227712.png" alt="image-20211115101227712"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-319-灯泡开关&quot;&gt;&lt;a href=&quot;#力扣-319-灯泡开关&quot; class=&quot;headerlink&quot; title=&quot;力扣 319. 灯泡开关&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/bulb-sw</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL入门</title>
    <link href="http://zhoushing.github.io/2021-10-13-MySQL%E5%85%A5%E9%97%A8.html"/>
    <id>http://zhoushing.github.io/2021-10-13-MySQL%E5%85%A5%E9%97%A8.html</id>
    <published>2021-10-13T02:16:09.000Z</published>
    <updated>2021-10-17T09:42:30.372Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>上篇文章中我们简单介绍了数据库以及 MySQL 的介绍及安装，本篇文章我们主要要介绍一下 MySQL 的相关规则和语法。</p><h2 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h2><h3 id="连接DBMS"><a href="#连接DBMS" class="headerlink" title="连接DBMS"></a>连接DBMS</h3><p>​    MySQL与所有客户机-服务器DBMS一样，要求执行命令之前登录到DBMS。MySQL在内部保存自己的用户列表，并且把每个用户与各种权限关联起来。</p><p>​    在上篇文章安装MySQL过程中，我们的账号为<code>root</code>，密码为<code>123456</code>。在自己本地使用时，可以这样简单设置一下。但是在现实生产或者工作时，管理登录受到密切保护（因为对它的访问授予了创建表、<strong>删除整个数据库</strong>、更改登录和口令等完全的操作）。</p><p>在连接MySQL时，需要以下信息：</p><ul><li>主机名（计算机名）——如果连接到本地MySQL服务器，为Localhost；</li><li>端口（如果使用默认端口3306之外的端口）；</li><li>一个合法的用户名；</li><li>用户口令（也就是密码）。</li></ul><p>例如在SQLyog中登录：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211013105422565.png" alt="image-20211013105422565"></p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>​    在你最初连接到MySQL时，没有数据库打开供你使用。在你能执行任何数据库操作之前，需要选择一个数据库。为此，我们可以使用<code>USE</code>关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE 表名</span><br><span class="line"># 将当前数据库转到目的数据库，一般的mysql可视化程序都会输入一句“Database changed”</span><br></pre></td></tr></table></figure><p>​    记住，要先使用<code>USE</code>打开指定数据库，才能读取其中的数据并操作。</p><blockquote><p>小Tip：在Windows系统上MySQL关键字一般不区分大小写（linux上就会区分，Windows上可以设置区分），所以上述例子中使用USE和use甚至是其他的组合都可以，不过MySQL语句规范: </p><p>   1: 关键字与函数名称全部大写;</p><p>   2: 数据库名称,表名称,字段名称全部小写;</p><p>所以在给数据库或者表等起名时，推荐使用下划线划分的形式，例如 person_table 。</p></blockquote><h3 id="了解数据库和表"><a href="#了解数据库和表" class="headerlink" title="了解数据库和表"></a>了解数据库和表</h3><p>​    在建立数据库之后或者打开一个别人创建的数据库时，而且我们不知道或者忘记可以使用的数据库名怎么办？</p><p>​    数据库、表、列、用户、权限等的信息被存储在数据库和表中。不过，内部的表一般不直接访问。可用的MySQL的<code>SHOW</code>命令来显示这些信息（由MySQL来负责将这些信息提取出来）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> school             <span class="operator">|</span>                                                          </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)    </span><br></pre></td></tr></table></figure><p>​    上面展示的就是<code>SHOW DATABASES</code>命令的效果，返回可用数据库的一个列表。需要注意的是，<strong>MySQL用<code>;</code>来标志着一条命令的结束，当读者在运行sql语句没反应时，不妨检查下是不是缺少<code>;</code>的原因。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE SCHOOL;                                                                  </span><br><span class="line">Database changed                                                                    </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;                                                                 </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="operator">|</span> Tables_in_school <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="operator">|</span> normaluser       <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">|</span> student          <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    上面展示的就是<code>SHOW TABLES</code>命令的效果，返回可用数据库的一个列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> student;                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type            <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>      <span class="operator">|</span> Extra <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="operator">|</span> Sno      <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> pwd      <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> Sname    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">30</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> sex      <span class="operator">|</span> <span class="type">char</span>(<span class="number">2</span>)         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> 男           <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> grade    <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>) unsigned <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> phone    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> address  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">255</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> 地址不详      <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> birthday <span class="operator">|</span> datetime        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> email    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> idCard   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>)     <span class="operator">|</span> YES  <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>​    <code>SHOW COLUMNS</code>要求给出一个表名（例如上面的<code>FROM student</code>），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（例如当字段自增时在<code>Extra</code>一栏会显示<code>auto_increment</code>）。</p><blockquote><p><strong>什么是 auto_increment ？</strong> auto_increment 也就是自动增量，某些表的列需要唯一值，例如，订单编号、雇员ID等。在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须要在用CREATE语句创建表时把它作为表定义的组成部分，我们在后面会再提到。</p></blockquote><blockquote><p>小Tip：上述的 SHOW COLUMNS FROM student 可以替换成 DESCRIBE student；简而言之，DESCRIBE 是 SHOW COLUMNS FROM 的一种简写，其实还可以写成 DESC（偷懒Plus）。</p></blockquote><p>其他所支持的SHOW命令还有：</p><ul><li>SHOW STATUS，用于显示广泛的服务器状态信息；</li><li>SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；</li><li>SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；</li><li>SHOW ERRORS 和 SHOW WARNINGS，用来显示服务器错误或警告信息。</li></ul><h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><h4 id="检索列"><a href="#检索列" class="headerlink" title="检索列"></a>检索列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser;                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>​    上述语句利用SELECT语句从normaluser表中检索出了所有列（<code>*</code>指代所有字段），等同于 <code>SELECT user_account, user_password, money FROM normaluser</code>。所需的的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p><blockquote><p>小Tip：在SQLyog中操作时，可以通过操作图形化界面的方式创建数据库、表以及添加数据，可以参考这篇博文：<a href="https://blog.csdn.net/su2231595742/article/details/107967198">SQLyog使用教程</a>。命令行创建的方式之后才会讲解。</p></blockquote><h4 id="检索不同行"><a href="#检索不同行" class="headerlink" title="检索不同行"></a>检索不同行</h4><p>当我们想知道用户的常用密码是什么时，我们可以对密码进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT user_password FROM normaluser;                                        </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">| user_password |                                                                   </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">| 123456        |                                                                   </span><br><span class="line">| 123456        |                                                                   </span><br><span class="line">| 654321        |                                                                   </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">3 rows in set (0.00 sec) </span><br></pre></td></tr></table></figure><p>​    这时候我们发现出现了重复的数据，当我们不想结果出现重复数据时，我们可以使用<code>DISTINCT</code>关键字，顾名思义，这个关键字将结果进行筛选，最后只剩下结果不同的列表，例如下面的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> user_password <span class="keyword">FROM</span> normaluser;                              </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> user_password <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>小Tip：不能部分使用DISTINCT，DISTINCT会作用于目标的所有列而不仅是前置他的列。比如给出 <code>SELECT DISTINCT user_account, user_password FROM normaluser </code>时，就要求除非账号和密码都相同，否则就会被检索出来。</p></blockquote><h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p><code>SELECT</code>语句返回所有匹配的行，它们可能是指定表中的所有行。为了返回指定条数的数据，可以使用<code>LIMIT</code>关键字。例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser LIMIT <span class="number">3</span>;                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    上述语句使用<code>SELECT</code>语句检索了所有列。<code>LIMIT 3</code>指示MySQL返回<strong>不多于</strong>3行。当我们想知道某一行开始的后三行时，我们可以指定要检索的开始行和行数，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser LIMIT <span class="number">2</span>, <span class="number">3</span>;                                         </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> zhangsi      <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> liwu         <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   </span><br></pre></td></tr></table></figure><p><code>LIMIT 2, 3</code>表示返回第二行以及后面的两行，也就是从第二行开始到第四行。第一个数表示开始位置，第二个数表示要返回的行数。</p><blockquote><p><strong>行 0</strong> 可能有读者奇怪上述例子中为什么第三行数据却是第二行，因为数据表中的第一行是行0而不是行1。因此，LIMIT 1, 1检索出来的是第二行数据而不是第一行数据。</p></blockquote><blockquote><p><strong>当行数不够时</strong> LIMIT中指定要检索出的数据为检索的最大行数。如果没有足够的行时，MySQL将只会返回他能返回的那么多行。</p></blockquote><blockquote><p><strong>MySQL 5 中的 LIMIT 语法</strong> 从MySQL 5 开始出现一种LIMIT的另一种替代语法。<code>LIMIT 4 OFFSET 3</code> 意思是从行3开始取四行，就像<code>LIMIT 3, 4</code> 一样。</p></blockquote><h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>​    到目前为止的例子中，我们只使用了列名来引用列。在某些情况下，我们也可以使用全限定的名字来引用列（同时使用表名和列名）。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> normaluser.user_password <span class="keyword">FROM</span> school.normaluser;                      </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> user_password <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    在这条语句中，我们将user_password限定为normaluser表中的user_password字段，normaluser限定为school数据库中的normaluser表，等价于<code>SELECT user_password FROM normaluser</code>，在之后某些场景需要使用完全限定名。现在需要注意一下这个语法，以便到时候知道它的作用。</p><h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><p>​    在上面许多的操作时，我们可以看出检索的数据并没有什么严格的顺序。其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的数据顺序。但是，如果数据后来进行过更新或者删除操作时，则此时将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖排序顺序。<strong>在关系数据库设计理论中认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</strong></p><blockquote><p><strong>子句</strong> SQL语句由子句构成，有些子句是必需的，而有些是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有<code>SELECT</code>语句的<code>FROM</code>子句，我们在之前的例子中看到了这个子句的作用。</p></blockquote><p>​    当我们需要明确使用排序用<code>SELECT</code>语句检索出的数据，可以使用<code>ORDER BY</code>子句。<code>OEDER BY</code>子句取一个或者多个列的名字，据此对输出进行排序。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_account;                   </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)  </span><br></pre></td></tr></table></figure><p>​    可以看到上述操作将用户账号以字母顺序排序（默认是升序的）展示了表中的数据，如果想要降序输出，加上<code>DESC</code>关键字即可。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_account <span class="keyword">DESC</span>;              </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><h4 id="按多个列进行排序"><a href="#按多个列进行排序" class="headerlink" title="按多个列进行排序"></a>按多个列进行排序</h4><p>​    在实际使用时，经常需要不止一个列进行数据排序，因为可能有些数据是相等的，所以就需要多个列进行排序。为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样），例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account, money <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> money <span class="keyword">DESC</span>, user_account;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span> money <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   </span><br></pre></td></tr></table></figure><p>​    上述例子中，我们将用户按照余额进行了降序排序，当所持金额相同时按照名字升序排列。这就是实现了对排序规则的排序。</p><blockquote><p><strong>在每个列上降序排序</strong> 如果想在多个列上进行降序排序，必须对每个列指定<code>DESC</code>关键字。</p></blockquote><blockquote><p>小Tip：有细心的读者可能发现了，在前面还出现过一次<code>DESC</code>关键字</p><p>DESC table_name；</p><p>PS：此处desc是describe的缩写，用法： desc 表名/查询语句 </p><p>SELECT user_account FROM normaluser ORDER BY user_account DESC;        </p><p>PS：此处desc是descend的缩写， 用法：select * from 表 order by 字段 desc</p></blockquote><blockquote><p><strong>ORDER BY子句的位置</strong> 在给出<code>ORDER BY</code>子句时，应该保证它位于<code>FROM</code>子句之后。如果使用<code>LIMIT</code>，它必须位于<code>ORDER BY</code>之后。使用子句的次序不当讲产生错误消息。关于子句的顺序，后面我们应该还会提到。</p></blockquote><h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><h4 id="使用-WHERE-子句"><a href="#使用-WHERE-子句" class="headerlink" title="使用 WHERE 子句"></a>使用 WHERE 子句</h4><p>​    数据库表中通常包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（也叫过滤条件）。</p><p>​    在<code>SELECT</code>语句中，数据根据<code>WHERE</code>子句中指定的搜索条件进行过滤。<code>WHERE</code>子句在表名（<code>FROM</code>子句）之后给出，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser <span class="keyword">WHERE</span> money <span class="operator">=</span> <span class="number">250</span>;                                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> wangliu      <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>​    上面展示了一个简单的筛选：它检查一个列是否有指定的值，据此进行筛选。但是SQL支持的不仅仅是这样的简单筛选。</p><blockquote><p><strong>WHERE 子句的位置</strong> 在同时使用<code>ORDER BY</code>位于<code>WHERE</code>之后，否则将会产生错误。</p></blockquote><h4 id="WHERE-子句操作符"><a href="#WHERE-子句操作符" class="headerlink" title="WHERE 子句操作符"></a>WHERE 子句操作符</h4><table><thead><tr><th align="center">操作数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定两个数之间</td></tr></tbody></table><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考《MySQL必知必会》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;上篇文章中我们简单介绍了数据库以及 MySQL 的介绍及安装，本篇文章我们主要要介绍一下 MySQL 的相关规则和语法。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="MySQL系列" scheme="http://zhoushing.github.io/categories/MySQL%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="数据库" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://zhoushing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="http://zhoushing.github.io/2021-10-11-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-10-11-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-10-11T15:06:27.000Z</published>
    <updated>2021-10-11T15:10:37.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-96-不同的二叉搜索树"><a href="#力扣-96-不同的二叉搜索树" class="headerlink" title="力扣 96. 不同的二叉搜索树"></a>力扣 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道动态规划算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要依次讨论 2 - n 个节点的可能即可，每个可能只需要讨论 左子树的可能和右子树可能的乘积 即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     * 左右划分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sums[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 排列组合</span></span><br><span class="line">                <span class="comment">// sums[j] 左子树的可能</span></span><br><span class="line">                <span class="comment">// sums[i - j - 1] 右子树的可能</span></span><br><span class="line">                sums[i] = sums[i] + sums[j] * sums[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sums[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211011230838760.png" alt="image-20211011230838760"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#力扣-96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;力扣 96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>单词搜索</title>
    <link href="http://zhoushing.github.io/2021-10-11-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html"/>
    <id>http://zhoushing.github.io/2021-10-11-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html</id>
    <published>2021-10-11T14:59:07.000Z</published>
    <updated>2021-10-11T15:06:06.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-79-单词搜索"><a href="#力扣-79-单词搜索" class="headerlink" title="力扣 79. 单词搜索"></a>力扣 <a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>提示：</strong></p><ul><li>m == board.length</li><li>n = board[i].length</li><li>1 &lt;= m, n &lt;= 6</li><li>1 &lt;= word.length &lt;= 15</li><li>board 和 word 仅由大小写英文字母组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们直接DFS进行判断即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转向</span></span><br><span class="line">    <span class="keyword">int</span>[] turnX = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] turnY = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == words[<span class="number">0</span>]) &#123;</span><br><span class="line">                    ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(board, words, <span class="number">1</span>, i, j, ticks)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticks[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> now, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] ticks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> (now == words.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            i += turnX[k]; j += turnY[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不符合要求排除</span></span><br><span class="line">            <span class="keyword">if</span> (!judge(i, j) &amp;&amp; !ticks[i][j] &amp;&amp; board[i][j] == words[now]) &#123;</span><br><span class="line">                ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                result |= dfs(board, words, now + <span class="number">1</span>, i, j, ticks);</span><br><span class="line">                ticks[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i -= turnX[k]; j -= turnY[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下标是否越界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || (i - m) * (j - n) &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211011230603362.png" alt="image-20211011230603362"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-79-单词搜索&quot;&gt;&lt;a href=&quot;#力扣-79-单词搜索&quot; class=&quot;headerlink&quot; title=&quot;力扣 79. 单词搜索&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/word-searc</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>重排链表</title>
    <link href="http://zhoushing.github.io/2021-10-02-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-10-02-%E9%87%8D%E6%8E%92%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-10-02T13:50:00.000Z</published>
    <updated>2021-10-02T13:53:24.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-143-重排链表"><a href="#力扣-143-重排链表" class="headerlink" title="力扣 143. 重排链表"></a>力扣 <a href="https://leetcode-cn.com/problems/reorder-list/">143. 重排链表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p><p> L0 → L1 → … → Ln-1 → Ln<br>请将其重新排列后变为：</p><p>L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → …</p><p>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><p><strong>提示：</strong></p><ul><li>链表的长度范围为 <code>[1, 5 * 10^4]</code></li><li><code>1 &lt;= node.val &lt;= 1000</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/1626420311-PkUiGI-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [1,2,3,4]</span><br><span class="line">输出: [1,4,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/1626420320-YUiulT-image.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [1,2,3,4,5]</span><br><span class="line">输出: [1,5,2,4,3]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以找出后半截链表再翻转最后再合并</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     * 翻转</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reorderList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 快慢指针求出中间节点</span></span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="keyword">null</span> &amp;&amp; fast.next.next != <span class="keyword">null</span> ) &#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取出后面那条链并截断</span></span><br><span class="line">        ListNode another = slow.next;</span><br><span class="line">        slow.next = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 翻转后半截链表</span></span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode now = another;</span><br><span class="line">        ListNode last = now;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (now != <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = now.next;</span><br><span class="line">            now.next = pre;</span><br><span class="line">            pre = now;</span><br><span class="line">            now = last;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 保存翻转的链表</span></span><br><span class="line">        another = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 两链表合并</span></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="keyword">null</span> &amp;&amp; another != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 要链接的下一个节点</span></span><br><span class="line">            ListNode curNext = another;</span><br><span class="line">            another = another.next;</span><br><span class="line">            <span class="comment">// 主链表的下一个节点</span></span><br><span class="line">            ListNode nextNode = cur.next;</span><br><span class="line">            curNext.next = cur.next;</span><br><span class="line">            cur.next = curNext;</span><br><span class="line"></span><br><span class="line">            cur = nextNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211002215244862.png" alt="image-20211002215244862"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-143-重排链表&quot;&gt;&lt;a href=&quot;#力扣-143-重排链表&quot; class=&quot;headerlink&quot; title=&quot;力扣 143. 重排链表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/reorder</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>将有序数组转换为二叉搜索树</title>
    <link href="http://zhoushing.github.io/2021-10-02-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-10-02-%E5%B0%86%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E8%BD%AC%E6%8D%A2%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-10-02T03:34:22.000Z</published>
    <updated>2021-10-02T03:39:18.624Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-108-将有序数组转换为二叉搜索树"><a href="#力扣-108-将有序数组转换为二叉搜索树" class="headerlink" title="力扣 108. 将有序数组转换为二叉搜索树"></a>力扣 <a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。</p><p>高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li><li><code>nums</code> 按 <strong>严格递增</strong> 顺序排列</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/btree1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-10,-3,0,5,9]</span><br><span class="line">输出：[0,-3,9,-10,null,5]</span><br><span class="line">解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：</span><br></pre></td></tr></table></figure><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/btree2.jpg" alt="img"></p><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/btree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3]</span><br><span class="line">输出：[3,1]</span><br><span class="line">解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要每次去找区间中间的值作为根节点，再左右区间作为左右子树即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * 二分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">sortedArrayToBST</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode result = buildTree(nums, <span class="number">0</span>, n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出区间的中点作为根节点</span></span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        TreeNode node = <span class="keyword">new</span> TreeNode(nums[mid]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将区间二分分别作为左右子树</span></span><br><span class="line">        node.left = buildTree(nums, left, mid);</span><br><span class="line">        node.right = buildTree(nums, mid + <span class="number">1</span>, right);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211002113811880.png" alt="image-20211002113811880"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-108-将有序数组转换为二叉搜索树&quot;&gt;&lt;a href=&quot;#力扣-108-将有序数组转换为二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;力扣 108. 将有序数组转换为二叉搜索树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetc</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="分治" scheme="http://zhoushing.github.io/tags/%E5%88%86%E6%B2%BB/"/>
    
  </entry>
  
  <entry>
    <title>移除无效的括号</title>
    <link href="http://zhoushing.github.io/2021-10-02-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html"/>
    <id>http://zhoushing.github.io/2021-10-02-%E7%A7%BB%E9%99%A4%E6%97%A0%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7.html</id>
    <published>2021-10-02T02:08:42.000Z</published>
    <updated>2021-10-02T02:12:20.742Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1249-移除无效的括号"><a href="#力扣-1249-移除无效的括号" class="headerlink" title="力扣 1249. 移除无效的括号"></a>力扣 <a href="https://leetcode-cn.com/problems/minimum-remove-to-make-valid-parentheses/">1249. 移除无效的括号</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个由 ‘(‘、’)’ 和小写字母组成的字符串 s。</p><p>你需要从字符串中删除最少数目的 ‘(‘ 或者 ‘)’ （可以删除任意位置的括号)，使得剩下的「括号字符串」有效。</p><p>请返回任意一个合法字符串。</p><p>有效「括号字符串」应当符合以下 任意一条 要求：</p><ul><li>空字符串或只包含小写字母的字符串</li><li>可以被写作 AB（A 连接 B）的字符串，其中 A 和 B 都是有效「括号字符串」</li><li>可以被写作 (A) 的字符串，其中 A 是一个有效的「括号字符串」</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 10^5</code></li><li><code>s[i]</code> 可能是 <code>&#39;(&#39;</code>、<code>&#39;)&#39;</code> 或英文小写字母</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;lee(t(c)o)de)&quot;</span><br><span class="line">输出：&quot;lee(t(c)o)de&quot;</span><br><span class="line">解释：&quot;lee(t(co)de)&quot; , &quot;lee(t(c)ode)&quot; 也是一个可行答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a)b(c)d&quot;</span><br><span class="line">输出：&quot;ab(c)d&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;))((&quot;</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：空字符串也是有效的</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(a(b(c)d)&quot;</span><br><span class="line">输出：&quot;a(b(c)d)&quot;</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要注意当前括号是否能被放进结果字符串中即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">minRemoveToMakeValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> n = chars.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记当前位是不是多余的，初始为 false</span></span><br><span class="line">        <span class="keyword">boolean</span>[] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="comment">// 栈来保存括号位置，方便配对标记</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stack.push(i);</span><br><span class="line">                ticks[i] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// 这时候出现一对括号对了，将前一个括号的标记置为 false，表示可以存在</span></span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    ticks[stack.pop()] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    ticks[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ticks[i]) &#123;</span><br><span class="line">                result.append(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211002101121275.png" alt="image-20211002101121275"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1249-移除无效的括号&quot;&gt;&lt;a href=&quot;#力扣-1249-移除无效的括号&quot; class=&quot;headerlink&quot; title=&quot;力扣 1249. 移除无效的括号&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="栈" scheme="http://zhoushing.github.io/tags/%E6%A0%88/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>两两交换链表中的节点</title>
    <link href="http://zhoushing.github.io/2021-09-26-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html"/>
    <id>http://zhoushing.github.io/2021-09-26-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.html</id>
    <published>2021-09-26T13:27:34.000Z</published>
    <updated>2021-09-26T13:30:58.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-24-两两交换链表中的节点"><a href="#力扣-24-两两交换链表中的节点" class="headerlink" title="力扣 24. 两两交换链表中的节点"></a>力扣 <a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</p><p><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目在范围 <code>[0, 100]</code> 内</li><li><code>0 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4]</span><br><span class="line">输出：[2,1,4,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1]</span><br><span class="line">输出：[1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以用一个头节点，然后将节点两两交换即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     * 遍历交换</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 头节点</span></span><br><span class="line">        ListNode result = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        result.next = head;</span><br><span class="line"></span><br><span class="line">        ListNode temp = result;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 还有交换的机会</span></span><br><span class="line">        <span class="keyword">while</span> (temp != <span class="keyword">null</span> &amp;&amp; temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 当前节点和下一个节点</span></span><br><span class="line">            ListNode now = temp.next;</span><br><span class="line">            ListNode after = temp.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 后一个节点不为空时交换</span></span><br><span class="line">            <span class="keyword">if</span> (after != <span class="keyword">null</span>) &#123;</span><br><span class="line">                now.next = after.next;</span><br><span class="line">                after.next = now;</span><br><span class="line">                temp.next = after;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移动节点</span></span><br><span class="line">            temp = now;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210926213005148.png" alt="image-20210926213005148"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#力扣-24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;力扣 24. 两两交换链表中的节点&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>二叉树中的最大路径和</title>
    <link href="http://zhoushing.github.io/2021-09-25-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.html"/>
    <id>http://zhoushing.github.io/2021-09-25-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%AF%E5%BE%84%E5%92%8C.html</id>
    <published>2021-09-25T03:41:22.000Z</published>
    <updated>2021-09-25T03:48:10.918Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-124-二叉树中的最大路径和"><a href="#力扣-124-二叉树中的最大路径和" class="headerlink" title="力扣 124. 二叉树中的最大路径和"></a>力扣 <a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p><p>路径和 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p><p><strong>提示：</strong></p><ul><li>树中节点数目范围是 <code>[1, 3 * 10^4]</code></li><li><code>-1000 &lt;= Node.val &lt;= 1000</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/exx1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/exx2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以递归尝试链接路径，并将分支总值较大的分支传回给上级</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     * 二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> result = Integer.MIN_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 递归寻找线路</span></span><br><span class="line">        getMax(root);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(TreeNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 无节点可连接</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 左边的链路</span></span><br><span class="line">        <span class="keyword">int</span> left = Math.max(<span class="number">0</span>, getMax(node.left));</span><br><span class="line">        <span class="comment">// 右边的链路</span></span><br><span class="line">        <span class="keyword">int</span> right = Math.max(<span class="number">0</span>, getMax(node.right));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录链路最大值，这里 node.val + left + right 代表着一条完整链路</span></span><br><span class="line">        result = Math.max(result, node.val + left + right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 选择左右链路的较大值与当前节点链接并返回 Math.max(left, right) + node.val </span></span><br><span class="line">        <span class="comment">// 代表着当前节点构成的链路一边</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210925114543145.png" alt="image-20210925114543145"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-124-二叉树中的最大路径和&quot;&gt;&lt;a href=&quot;#力扣-124-二叉树中的最大路径和&quot; class=&quot;headerlink&quot; title=&quot;力扣 124. 二叉树中的最大路径和&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="递归" scheme="http://zhoushing.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>环形链表II</title>
    <link href="http://zhoushing.github.io/2021-09-24-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html"/>
    <id>http://zhoushing.github.io/2021-09-24-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html</id>
    <published>2021-09-24T07:21:10.000Z</published>
    <updated>2021-09-24T07:24:29.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-142-环形链表-II"><a href="#力扣-142-环形链表-II" class="headerlink" title="力扣 142. 环形链表 II"></a>力扣 <a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</p><p>为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，pos 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</p><p>说明：不允许修改给定的链表。</p><p><strong>提示：</strong></p><ul><li>链表中节点的数目范围在范围 <code>[0, 10^4]</code> 内</li><li><code>-10^5 &lt;= Node.val &lt;= 10^5</code></li><li><code>pos</code> 的值为 <code>-1</code> 或者链表中的一个有效索引</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：返回索引为 1 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist_test2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：返回索引为 0 的链表节点</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/circularlinkedlist_test3.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1], pos = -1</span><br><span class="line">输出：返回 null</span><br><span class="line">解释：链表中没有环。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道链表算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以直接用双指针进行追击，如果通过起点和追击点来确定环入口</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123;</span></span><br><span class="line"><span class="comment"> *         val = x;</span></span><br><span class="line"><span class="comment"> *         next = null;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">detectCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 快慢指针</span></span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 追击成功</span></span><br><span class="line">            <span class="keyword">if</span> (fast == slow) &#123;</span><br><span class="line">                ListNode temp = head;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 从起点和追击点同时出发，相遇点为环入口</span></span><br><span class="line">                <span class="keyword">while</span> (temp != fast) &#123;</span><br><span class="line">                    temp = temp.next;</span><br><span class="line">                    fast = fast.next;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210924152354346.png" alt="image-20210924152354346"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-142-环形链表-II&quot;&gt;&lt;a href=&quot;#力扣-142-环形链表-II&quot; class=&quot;headerlink&quot; title=&quot;力扣 142. 环形链表 II&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="链表" scheme="http://zhoushing.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>初识计算机网络</title>
    <link href="http://zhoushing.github.io/2021-09-23-%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html"/>
    <id>http://zhoushing.github.io/2021-09-23-%E5%88%9D%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C.html</id>
    <published>2021-09-23T06:46:06.000Z</published>
    <updated>2021-09-23T10:10:01.035Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    随着时代的发展，计算机已经对我们社会和生活产生了深远的影响。计算机相关技术也被应用于各种各样的领域，有些人因此提出了“20世纪最伟大的发明就是计算机”。在笔者看来，到21世纪甚至以后的世界，计算机也会产生巨大的作用。</p><p>​    前段时间的华为的鸿蒙系统比较火，而鸿蒙系统就是打通手机、电脑、平板、电视、汽车和智能穿戴等多种设备的统一操作系统。</p><p>​    “万物互联时代，没有人会是一座孤岛。无论经历多大的困难，华为为全球消费者提供更好的用户体验、更好的产品的决心不会改变。我们希望与更多合作伙伴、开发者共同繁荣鸿蒙生态，为全球消费者提供更好的体验、更好的产品、更好的服务。”华为常务董事、消费者业务CEO余承东在发布会接近尾声时上台致辞说了这样一段话。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923151609804.png" alt="image-20210923151609804"></p><p>​    上图就是新一代物联网应用场景图，想必读者很直观的可以看到万物互联时代带来的便利和美好，而今天我们就来聊聊最开始的“互联”——计算机互联。</p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>​    最开始的时候，计算机总是以单机模式被广泛使用。但是随着计算机技术的不断发展，人们就不满足于只能单机工作的计算机了，可能是一段迫切分享的信息，可能是一件需要协调的工作，导致了计算机互联的诞生。一台台计算机的连接，最后构成了网络状的计算机联系，这就形成了最早的计算机网络。</p><p>​    <a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a>，在维基百科中，将其称为是指容许<a href="https://zh.wikipedia.org/wiki/%E8%8A%82%E7%82%B9_(%E7%94%B5%E4%BF%A1%E7%BD%91%E7%BB%9C)">节点</a>分享资源的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7">数字</a>电信网络。笔者认为计算机网络正如其名，由计算机设备或者其他电子设备组成的一个网络状的连接关系。随着互联网的爆发式发展和普及，信息网络已经随处可见，现如今的计算机网络也发展成了一个庞大的体系了。</p><p>​    一个体系的诞生通常伴随着各种规范和协议的诞生，谈及计算机网络，就不得不谈最家喻户晓的 <code>OSI</code> 模型和 <code>TCP/IP</code>模型。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><h3 id="OSI-模型"><a href="#OSI-模型" class="headerlink" title="OSI 模型"></a>OSI 模型</h3><p>​    <code>OSI</code> 模型是由<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p><p>​    从下图可以看出该模型将通信系统中的数据流划分为七个层。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923153708838.png" alt="image-20210923153708838"></p><h3 id="TCP-IP-模型"><a href="#TCP-IP-模型" class="headerlink" title="TCP/IP 模型"></a>TCP/IP 模型</h3><p>​    如下图所示 <code>TCP/IP</code> 模型只有四层，相当于 <code>OSI</code> 模型中应用、表示和会话层合并成应用层，数据链路层和物理层合并为网络接口层，TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923154023773.png" alt="image-20210923154023773"></p><p>​    <strong>TCP/IP 参考模型</strong>是一个抽象的分层模型，这个模型中，所有的 <a href="https://zh.wikipedia.org/wiki/TCP/IP">TCP/IP</a> 系列 <a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a> 都归类到4个抽象的“层”中。每一抽象层创建在低一层提供的服务上，并且为高一层提供服务。 完成一些特定的任务需要众多的协议协同工作，这些协议分布在参考模型的不同层中的，因此有时称它们为一个<em>协议栈</em>。</p><p>​    由于现在网络中用的都是TCP/IP 参考模型，所以接下来我们着重讲 <strong>TCP/IP协议族</strong> 中的重要协议。</p><h2 id="TCP-IP-协议族主要协议"><a href="#TCP-IP-协议族主要协议" class="headerlink" title="TCP/IP 协议族主要协议"></a>TCP/IP 协议族主要协议</h2><p>​    下图中就是TCP/IP 协议族中的主要协议了，这些协议相互协作，共同工作完成了我们日常生活中的许多需求，例如 HTTP （超文本传输协议），FTP（文件传输协议），DHCP（动态主机设定协议）等等。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923154652668.png" alt="image-20210923154652668"></p><p>​    因为该协议家族的两个核心协议：<strong>TCP（<a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AE">传输控制协议</a>）</strong>和<strong>IP（<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE">网际协议</a>）</strong>，为该家族中最早通过的标准[<a href="https://zh.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE%E6%97%8F#cite_note-3">3]</a>。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的<a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%A0%88">堆栈</a>，因此又称为<strong>TCP/IP协议栈</strong>。</p><p>​    在本篇文章中会先对最核心的 TCP 协议进行论述，其他还有许多重要的协议会放到之后的文章进行讲解。</p><h2 id="TCP-协议"><a href="#TCP-协议" class="headerlink" title="TCP 协议"></a>TCP 协议</h2><p>​    <strong>传输控制协议</strong>（英语：<strong>T</strong>ransmission <strong>C</strong>ontrol <strong>P</strong>rotocol，缩写：<strong>TCP</strong>）是一种面向连接的、可靠的、基于<a href="https://zh.wikipedia.org/wiki/%E5%AD%97%E7%AF%80%E6%B5%81">字节流</a> 的 <a href="https://zh.wikipedia.org/wiki/%E4%BC%A0%E8%BE%93%E5%B1%82">传输层</a>通信协议。在简化的计算机网络<a href="https://zh.wikipedia.org/wiki/OSI%E6%A8%A1%E5%9E%8B">OSI模型</a>中，它完成第四层传输层所指定的功能。<a href="https://zh.wikipedia.org/wiki/%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AE">用户数据报协议</a>（UDP）是同一层内另一个与 TCP 相对的 无连接、不可靠 的重要传输协议，在之后我们还会再提到。</p><p>​    提到 TCP 就不免提到它的三次握手和四次挥手，还有随之而来的许多扩展问题：可不可以是两次握手？可不可以是三次挥手？</p><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>三次握手协议的过程：</p><p>​    第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。</p><p>​    第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。</p><p>​    第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923163513140.png" alt="image-20210923163513140"></p><p>在上图中我们可以看出，三次握手就像张三和李四建立友好关系一样，但是这两个人文邹邹的，故事如下：</p><p>​    张三：你好！我叫张三，<strong>我能和你做朋友吗</strong>？</p><p>​    李四今天正好心情不错，看见张三这个陌生人打招呼也回了句：张三你好，<strong>我知道你要和我做朋友了</strong>，我叫李四。</p><p>​    张三一看李四的回应，心想，“有戏，又认识一个朋友”，俗话说得好，“多一个朋友多一条路”嘛，就又回到：<strong>我知道我们是朋友了</strong>，现在我们可以开始聊天（che dan）了。</p><p>然后张三和李四就开始了快乐的交流。</p><p>在网络中的两台计算机就像这样进行交流然后建立连接关系之后再进行数据交换，正如上面所提到的那个问题，可不可以是两次握手？</p><h3 id="两次握手或者其他次握手行不行"><a href="#两次握手或者其他次握手行不行" class="headerlink" title="两次握手或者其他次握手行不行"></a>两次握手或者其他次握手行不行</h3><p>答案是不可以！</p><p>TCP作为一种可靠传输控制协议，其<strong>核心思想</strong>：既要保证数据可靠传输，又要提高传输的效率，而用<strong>三次恰恰可以满足以上两方面的需求！</strong>通俗的来说就是两次无法保证可靠，而四次或者更多次握手又没有必要，所以TCP是三次握手。</p><p>在网上有许多说法关于三次握手的必要性：</p><ul><li><a href="https://blog.csdn.net/b954960630/article/details/81861579">检测双方的能力</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923171915643.png" alt="image-20210923171915643"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/114731254">三次握手实质上是四次，是双向握手+双向确认的过程</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172116772.png" alt="image-20210923172116772"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/254224088">三次握手保证失效的连接请求不会产生影响</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172323991.png" alt="image-20210923172323991"></p><ul><li><a href="https://www.zhihu.com/question/24853633/answer/573627478">需要三次握手来确定序列号</a></li></ul><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923172526005.png" alt="image-20210923172526005"></p><h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><p>如果说三次握手代表着关系的建立，那么对应的四次挥手就代表着关系的结束，也就是网络中的断连。</p><p>​    第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</p><p>​    即发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p><p>​    第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</p><p>​    即服务端收到连接释放报文段后即发出确认报文段（ACK=1，确认号ack=u+1，序号seq=v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p><p>​    第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</p><p>​    即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN=1，ACK=1，序号seq=w，确认号ack=u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p><p>​    第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210923173243645.png" alt="image-20210923173243645"></p><p>可以从上面看出来，四次挥手其实是双方要断开连接时的一个协商过程：</p><p>​    张三：李四啊，你看我们也聊了这么久了，天色也不早了，<strong>我也说了不少了，该回家了</strong>？</p><p>​    李四聊的正在兴头上，但是天色确实不早了，于是说：<strong>我知道你说完了，但是我还有一些事没说完</strong>。</p><p>​    于是李四：巴拉巴拉巴拉。。。</p><p>​    李四觉得说的差不多了，也打算结束这次交流了：张三，<strong>我说完了，再见吧</strong>，有机会再聊。</p><p>​    张三一看李四终于说完了：<strong>再见李四</strong>。</p><p>然后张三和李四就开始了快乐的各回各家各找各妈了。</p><h3 id="可不可以是三次挥手或者更少次"><a href="#可不可以是三次挥手或者更少次" class="headerlink" title="可不可以是三次挥手或者更少次"></a>可不可以是三次挥手或者更少次</h3><p>答案同样是不可以！</p><p>在上面的描述和演示图中我们可以看出来，四次挥手都很重要：</p><p>第一次是率先离开的甲方告诉另一方自己结束传输了；第二次是另一方的乙方回复甲方知道了，但是一般还会有数据需要传输，在这些或多或少的传输结束后；第三次乙方告诉甲方自己这边也结束传输了；最后一次甲方给乙方的回复是<strong>为了确保乙方知道  自己（甲方）已经收到乙方发出的结束传输报文了</strong>。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考 <a href="https://www.cyc2018.xyz/">CS-Notes</a> 以及 <a href="https://zh.wikipedia.org/">维基百科</a>、<a href="https://zhuanlan.zhihu.com/p/86426969">三次握手和四次挥手</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;​    随着时代的发展，计算机已经对我们社会和生活产生了深远的影响。计算机相关技术也被应用于各种各样的领域，有些人因此提出了“20世纪最伟</summary>
      
    
    
    
    <category term="计算机网络" scheme="http://zhoushing.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://zhoushing.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
