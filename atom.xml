<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>徐年の博客</title>
  
  
  <link href="https://blog.xuyicheng.top/atom.xml" rel="self"/>
  
  <link href="https://blog.xuyicheng.top/"/>
  <updated>2022-03-14T15:02:17.371Z</updated>
  <id>https://blog.xuyicheng.top/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>单例模式</title>
    <link href="https://blog.xuyicheng.top/2022-03-14-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://blog.xuyicheng.top/2022-03-14-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</id>
    <published>2022-03-14T14:41:45.000Z</published>
    <updated>2022-03-14T15:02:17.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在之前的文章中我们介绍了常见的设计模式，今天我们来使用 Java 语言对单例模式进行具体实现举例。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在下面的例子中，我们使用单例模式来保证每次生成的对象都是唯一的。</p><h3 id="统一接口"><a href="#统一接口" class="headerlink" title="统一接口"></a>统一接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单例对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">SingletonObject</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hungry</span> <span class="keyword">implements</span> <span class="title">SingletonObject</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Hungry instance = <span class="keyword">new</span> Hungry();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造，避免外部利用 new 创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Hungry</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到实例通过饿汉式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Singleton&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Hungry <span class="title">getInstanceByHungry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LazyBones</span> <span class="keyword">implements</span> <span class="title">SingletonObject</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazyBones instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造，避免外部利用 new 创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazyBones</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到实例通过懒汉式</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Singleton&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> LazyBones <span class="title">getInstanceByLazyBones</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazyBones();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双重锁检测"><a href="#双重锁检测" class="headerlink" title="双重锁检测"></a>双重锁检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Double-checked locking</span></span><br><span class="line"><span class="comment"> * 双重锁检测</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DCL</span> <span class="keyword">implements</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DCL instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造，避免外部利用 new 创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DCL</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到实例通过双重锁检测</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Singleton&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> DCL <span class="title">getInstanceByDCL</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 第一重检测，检测实例是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 此处锁住DCL类以保证对象唯一性</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCL.class) &#123;</span><br><span class="line">                <span class="comment">// 第二重检测，避免在锁争夺时重复生成实例</span></span><br><span class="line">                <span class="comment">// 例如：A、B都在争抢锁</span></span><br><span class="line">                <span class="comment">// A率先拿到锁，生成实例并获取后释放锁</span></span><br><span class="line">                <span class="comment">// B拿到锁，假如没有第二重检测，B会再度创建一个实例破坏单例性</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DCL();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> <span class="keyword">implements</span> <span class="title">SingletonObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有构造，避免外部利用 new 创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到实例通过静态内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> StaticInnerClass&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClass <span class="title">getInstanceByStaticInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span></span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 实例</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClass INSTANCE = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/03/10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Enum</span> <span class="keyword">implements</span> <span class="title">SingletonObject</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Enum <span class="title">getInstanceByEnum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h3><p>笔者在进行测试时将上面的所有接口及类以及下面的测试类写在一个java文件中，测试结果在不同电脑不同时间上可能有所不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Object o1 = <span class="keyword">new</span> Object();</span><br><span class="line">    Object o2 = <span class="keyword">new</span> Object();</span><br><span class="line">    printInfo(<span class="string">&quot;普通创建&quot;</span>, o1, o2);</span><br><span class="line"></span><br><span class="line">    SingletonObject s1 = Hungry.getInstanceByHungry();</span><br><span class="line">    SingletonObject s2 = Hungry.getInstanceByHungry();</span><br><span class="line">    printInfo(<span class="string">&quot;饿汉式&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    s1 = LazyBones.getInstanceByLazyBones();</span><br><span class="line">    s2 = LazyBones.getInstanceByLazyBones();</span><br><span class="line">    printInfo(<span class="string">&quot;懒汉式&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    s1 = DCL.getInstanceByDCL();</span><br><span class="line">    s2 = DCL.getInstanceByDCL();</span><br><span class="line">    printInfo(<span class="string">&quot;双重锁检测&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    s1 = StaticInnerClass.getInstanceByStaticInnerClass();</span><br><span class="line">    s2 = StaticInnerClass.getInstanceByStaticInnerClass();</span><br><span class="line">    printInfo(<span class="string">&quot;静态内部类&quot;</span>, s1, s2);</span><br><span class="line"></span><br><span class="line">    s1 = Enum.getInstanceByEnum();</span><br><span class="line">    s2 = Enum.getInstanceByEnum();</span><br><span class="line">    printInfo(<span class="string">&quot;枚举类&quot;</span>, s1, s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printInfo</span><span class="params">(String way, Object s1, Object s2)</span> </span>&#123;</span><br><span class="line">    System.out.println(way + <span class="string">&quot;: &quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;s1 = &quot;</span> + s1);</span><br><span class="line">    System.out.println(<span class="string">&quot;s2 = &quot;</span> + s2);</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">普通创建: </span><br><span class="line">s1 = java.lang.Object@404b9385</span><br><span class="line">s2 = java.lang.Object@6d311334</span><br><span class="line"></span><br><span class="line">饿汉式: </span><br><span class="line">s1 = designPattern.Hungry@682a0b20</span><br><span class="line">s2 = designPattern.Hungry@682a0b20</span><br><span class="line"></span><br><span class="line">懒汉式: </span><br><span class="line">s1 = designPattern.LazyBones@3d075dc0</span><br><span class="line">s2 = designPattern.LazyBones@3d075dc0</span><br><span class="line"></span><br><span class="line">双重锁检测: </span><br><span class="line">s1 = designPattern.DCL@214c265e</span><br><span class="line">s2 = designPattern.DCL@214c265e</span><br><span class="line"></span><br><span class="line">静态内部类: </span><br><span class="line">s1 = designPattern.StaticInnerClass@448139f0</span><br><span class="line">s2 = designPattern.StaticInnerClass@448139f0</span><br><span class="line"></span><br><span class="line">枚举类: </span><br><span class="line">s1 = INSTANCE</span><br><span class="line">s2 = INSTANCE</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;在之前的文章中我们介绍了常见的设计模式，今天我们来使用 Java 语言对单例模式进行具体实现举例。&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.xuyicheng.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.xuyicheng.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>数据库表中的salt是什么</title>
    <link href="https://blog.xuyicheng.top/2022-03-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84salt%E6%98%AF%E4%BB%80%E4%B9%88.html"/>
    <id>https://blog.xuyicheng.top/2022-03-04-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%A1%A8%E4%B8%AD%E7%9A%84salt%E6%98%AF%E4%BB%80%E4%B9%88.html</id>
    <published>2022-03-04T12:49:49.000Z</published>
    <updated>2022-03-04T14:33:48.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在数据库的user表中我们通常可以看到一个叫做salt的字段，salt大家很容易就知道意思是盐，大家一开始接触可能感觉很奇怪，为何用户要有一个“盐”属性？我们可以上维基查一下定义：</p><blockquote><p>盐（Salt）</p><p>在密码学中，是指通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符，这种过程称之为“加盐”。</p></blockquote><p>以上这段话是维基百科上中对于 Salt 的定义，但是仅凭这句话还是很难理解什么叫 Salt，以及它究竟在用户表里面会起到什么样的作用。接下来我们就以用户表的设计开始来揭示“salt”的必要性。</p><h2 id="数据表设计"><a href="#数据表设计" class="headerlink" title="数据表设计"></a>数据表设计</h2><h3 id="直接设计"><a href="#直接设计" class="headerlink" title="直接设计"></a>直接设计</h3><p>我们在设计用户表时，首当其冲需要设计用户名（或账号）以及密码，这两个字段可以说是用户表的核心，一个表示用户的唯一身份，一个表示和唯一身份相匹配的登录凭证。所以我们的用户表至少要设计成这样：</p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">是否为空</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">username</td><td align="center">varchar(50)</td><td align="center">no</td><td align="center">用户名</td></tr><tr><td align="center">password</td><td align="center">varchar(100)</td><td align="center">no</td><td align="center">密码</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><blockquote><p>PS：这里设计的数据表默认为MySQL中的表，下同</p></blockquote><p>在这样的数据表中，我们可以直接存储用户名和密码，在进行验证时也可以直接根据用户名匹配密码即可。但是随之带来了安全问题，例如在数据库中存储的是如下数据：</p><table><thead><tr><th align="center">……</th><th align="center">username</th><th align="center">password</th><th align="center">……</th></tr></thead><tbody><tr><td align="center">……</td><td align="center">zhangsan</td><td align="center">123456</td><td align="center">……</td></tr><tr><td align="center">……</td><td align="center">lisi</td><td align="center">lisi</td><td align="center">……</td></tr></tbody></table><p>一旦数据中的数据被违法获取或者因为机制泄漏，那么用户的密码就形同虚设，数据盗用者可以利用用户名和密码进行各种操作，损害用户的权益。</p><p>看到这里，读者想必也能意识到在数据库存储明文密码的危害了。</p><h3 id="转化密文"><a href="#转化密文" class="headerlink" title="转化密文"></a>转化密文</h3><p>可能有读者会想，明文不行，我用加密算法（下面演示采用md5加密）加密成密文再存不就行了，那我们继续来看：</p><p>稍稍对表进行修改，</p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">是否为空</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">username</td><td align="center">varchar(50)</td><td align="center">no</td><td align="center">用户名</td></tr><tr><td align="center">pwd_hash</td><td align="center">varchar(100)</td><td align="center">no</td><td align="center">hash运算之后的密码</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><p>然后其中的数据变成了：</p><table><thead><tr><th align="center">……</th><th align="center">username</th><th align="center">pass_hash</th><th align="center">……</th></tr></thead><tbody><tr><td align="center">……</td><td align="center">zhangsan</td><td align="center">e10adc3949ba59abbe56e057f20f883e</td><td align="center">……</td></tr><tr><td align="center">……</td><td align="center">lisi</td><td align="center">dc3a8f1670d65bea69b7b65048a0ac40</td><td align="center">……</td></tr><tr><td align="center">……</td><td align="center">wangwu</td><td align="center">e10adc3949ba59abbe56e057f20f883e</td><td align="center">……</td></tr></tbody></table><p>这样是不是看起来比原来存的密文是不是安全多了，不过细心的读者可能发现了，用户zhangsan和wangwu进行md5运算之后的密码是一样的，代表他们原来的密码也是一样的。那么如果数据盗用者有一本小本本，记录着很多很多的加密前的密码和加密后的值的对应记录，现在计算机的运行速度那么快，简单的密码在被盗取后，也就比原来明文的获取多了一点破解时间而已。这样看来单纯的明文还是不能保证用户的密码安全性。</p><h3 id="“加盐”"><a href="#“加盐”" class="headerlink" title="“加盐”"></a>“加盐”</h3><p>正如炒菜的味道不够需要加盐一样，原来简单的加密不再能保证100%的安全了，毕竟谁也不知道你的密码没有别人用过或者没有以前被人破解记录过。于是salt应运而生，正如上述维基百科中所述“通过在密码任意固定位置插入特定的字符串，让散列后的结果和使用原始密码的散列结果不相符”，这句话可能还是不太好理解，直接上例子：</p><table><thead><tr><th align="center">字段名</th><th align="center">类型</th><th align="center">是否为空</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr><tr><td align="center">username</td><td align="center">varchar(50)</td><td align="center">no</td><td align="center">用户名</td></tr><tr><td align="center">pwd_hash</td><td align="center">varchar(100)</td><td align="center">no</td><td align="center">hash运算之后的密码</td></tr><tr><td align="center">salt</td><td align="center">varchar(30)</td><td align="center">no</td><td align="center">加密用盐值</td></tr><tr><td align="center">……</td><td align="center">……</td><td align="center">……</td><td align="center">……</td></tr></tbody></table><p>Salt 可以是任意字母、数字、或是字母或数字的组合，但必须是随机产生的，每个用户的 Salt 都不一样，用户注册的时候，数据库中存入的不是明文密码，也不是简单的对明文密码进行散列，而是 加密(明文密码 + Salt)，salt所在的位置任意，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MD5(&#x27;123456&#x27; + &#x27;2blfq0jgqus6ki13mkf81xt7dg&#x27;) = &#x27;a69b7f5a9c65a35eb3d9b826d3bf05b2&#x27;</span><br><span class="line">MD5(&#x27;lisi&#x27; + &#x27;t5s198thbqveyjactdt7h91bwa&#x27;) = &#x27;e6e21083351279c61bbe742e536525f4&#x27;</span><br><span class="line">MD5(&#x27;123456&#x27; + &#x27;dflhsgyu5flnmwn2qpzoa2mmwq&#x27;) = &#x27;8da7d8f7f313b8adbc82d99bfb98528c&#x27;</span><br></pre></td></tr></table></figure><p>这种方法相对就已经很保险了，因为数据盗用者无从得知你的盐值到底加在何处，你甚至可以在服务器代码上自定义序列，然后在对应序列位置交错穿插盐值（序列的第n位就是密码第n位插入盐值的位置），例如序列为斐波那契数列{1，1，2，3，5，8，13，……}，那么按照密码长度将其穿插进盐值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MD5(2[12]b[3]lf[4]q0[5]jgq[6]us6ki13mkf81xt7dg) = &#x27;c13e8cb039e818b933d4b30e7c348330&#x27;</span><br></pre></td></tr></table></figure><blockquote><p>程序设计时应根据业务需求灵活调整，以上序列穿插法仅供参考。</p></blockquote><p>这样一来，破解难度就大大提升，最大程度的保证了用户的密码安全性。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>相信读者看到这里，大概心里已经对用户表中salt的存在已经掌握，但是笔者在这里还是要提个醒，虽然进行更严密更复杂的加密手段可以保护用户密码，但是随之而来还有进行解密时的复杂性，会造成用户登录的时间影响，所以建议笔者还是根据实际需求，在验证时间和加密程度中做一个平衡。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>本文部分内容参考 <a href="https://blog.csdn.net/yang1982_0907/article/details/43483205">密码学中的“盐值 Salt”</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;在数据库的user表中我们通常可以看到一个叫做salt的字段，salt大家很容易就知道意思是盐，大家一开始接触可能感觉很奇怪，为何用户要有一</summary>
      
    
    
    
    <category term="数据库系列" scheme="https://blog.xuyicheng.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="数据库" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>黄金矿工</title>
    <link href="https://blog.xuyicheng.top/2022-02-05-%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5.html"/>
    <id>https://blog.xuyicheng.top/2022-02-05-%E9%BB%84%E9%87%91%E7%9F%BF%E5%B7%A5.html</id>
    <published>2022-02-05T02:58:13.000Z</published>
    <updated>2022-02-05T03:05:05.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1219-黄金矿工"><a href="#力扣-1219-黄金矿工" class="headerlink" title="力扣 1219. 黄金矿工"></a>力扣 <a href="https://leetcode-cn.com/problems/path-with-maximum-gold/">1219. 黄金矿工</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 <code>m * n</code> 的网格 <code>grid</code> 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 <code>0</code>。</p><p>为了使收益最大化，矿工需要按以下规则来开采黄金：</p><ul><li>每当矿工进入一个单元，就会收集该单元格中的所有黄金。</li><li>矿工每次可以从当前位置向上下左右四个方向走。</li><li>每个单元格只能被开采（进入）一次。</li><li><strong>不得开采</strong>（进入）黄金数目为 <code>0</code> 的单元格。</li><li>矿工可以从网格中 <strong>任意一个</strong> 有黄金的单元格出发或者是停止。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= grid.length, grid[i].length &lt;= 15</code></li><li><code>0 &lt;= grid[i][j] &lt;= 100</code></li><li>最多 <strong>25</strong> 个单元格中有黄金。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[0,6,0],[5,8,7],[0,9,0]] </span><br><span class="line">输出：24 </span><br><span class="line">解释： [[0,6,0], [5,8,7], [0,9,0]] 一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]] </span><br><span class="line">输出：28 </span><br><span class="line">解释： [[1,0,7], [2,0,6], [3,4,5], [0,3,0], [9,0,20]] </span><br><span class="line">一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题很经典得DFS，按部就班即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result, row, column;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转向位移</span></span><br><span class="line">    <span class="keyword">int</span>[] turnX = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] turnY = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMaximumGold</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">        row = grid.length;</span><br><span class="line">        column = grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记是否走过</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[row][column];</span><br><span class="line">        result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">                    ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    dfs(grid, ticks, i, j, grid[i][j]);</span><br><span class="line">                    ticks[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> grid  单元格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ticks 标记</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x0    x0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y0    y0</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count 黄金数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] grid, <span class="keyword">boolean</span>[][] ticks, <span class="keyword">int</span> x0, <span class="keyword">int</span> y0, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isTurn = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = x0 + turnX[i];</span><br><span class="line">            <span class="keyword">int</span> y = y0 + turnY[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (judge(x, y) &amp;&amp; grid[x][y] != <span class="number">0</span> &amp;&amp; !ticks[x][y]) &#123;</span><br><span class="line">                isTurn = <span class="keyword">true</span>;</span><br><span class="line">                ticks[x][y] = <span class="keyword">true</span>;</span><br><span class="line">                dfs(grid, ticks, x, y, count + grid[x][y]);</span><br><span class="line">                ticks[x][y] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isTurn) &#123;</span><br><span class="line">            result = Math.max(result, count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前坐标是否越界</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> x x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> y y</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &gt;= <span class="number">0</span> &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; (x - row) * (y - column) &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220205110337510.png" alt="image-20220205110337510"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1219-黄金矿工&quot;&gt;&lt;a href=&quot;#力扣-1219-黄金矿工&quot; class=&quot;headerlink&quot; title=&quot;力扣 1219. 黄金矿工&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/path</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="深度优先搜索" scheme="https://blog.xuyicheng.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>游戏中弱角色的数量</title>
    <link href="https://blog.xuyicheng.top/2022-01-28-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F.html"/>
    <id>https://blog.xuyicheng.top/2022-01-28-%E6%B8%B8%E6%88%8F%E4%B8%AD%E5%BC%B1%E8%A7%92%E8%89%B2%E7%9A%84%E6%95%B0%E9%87%8F.html</id>
    <published>2022-01-28T11:04:56.000Z</published>
    <updated>2022-01-28T11:08:02.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1996-游戏中弱角色的数量"><a href="#力扣-1996-游戏中弱角色的数量" class="headerlink" title="力扣 1996. 游戏中弱角色的数量"></a>力扣 <a href="https://leetcode-cn.com/problems/the-number-of-weak-characters-in-the-game/">1996. 游戏中弱角色的数量</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>你正在参加一个多角色游戏，每个角色都有两个主要属性：<strong>攻击</strong> 和 <strong>防御</strong> 。给你一个二维整数数组 <code>properties</code> ，其中 <code>properties[i] = [attacki, defensei]</code> 表示游戏中第 <code>i</code> 个角色的属性。</p><p>如果存在一个其他角色的攻击和防御等级 <strong>都严格高于</strong> 该角色的攻击和防御等级，则认为该角色为 <strong>弱角色</strong> 。更正式地，如果认为角色 <code>i</code> <strong>弱于</strong> 存在的另一个角色 <code>j</code> ，那么 <code>attackj &gt; attacki</code> 且 <code>defensej &gt; defensei</code> 。</p><p>返回 <strong>弱角色</strong> 的数量。</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= properties.length &lt;= 10^5</code></li><li><code>properties[i].length == 2</code></li><li><code>1 &lt;= attacki, defensei &lt;= 10^5</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[5,5],[6,3],[3,6]]</span><br><span class="line">输出：0</span><br><span class="line">解释：不存在攻击和防御都严格高于其他角色的角色。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[2,2],[3,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：第一个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：properties = [[1,5],[10,4],[4,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：第三个角色是弱角色，因为第二个角色的攻击和防御严格大于该角色。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们可以直接按照攻击降序，攻击相同时防御升序排序</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numberOfWeakCharacters</span><span class="params">(<span class="keyword">int</span>[][] properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 按照攻击降序，攻击相同时防御升序排序</span></span><br><span class="line">    Arrays.sort(properties, (p1, p2) -&gt; p1[<span class="number">0</span>] == p2[<span class="number">0</span>]? p1[<span class="number">1</span>] - p2[<span class="number">1</span>]: p2[<span class="number">0</span>] - p1[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前最大的防御力</span></span><br><span class="line">    <span class="keyword">int</span> max = properties[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按照攻击降序，攻击相同时防御升序排序后，</span></span><br><span class="line">    <span class="comment">// 这时我们向后遍历，反正攻击力是递减的，只要碰到防御力比之前角色最大防御力小的角色就计数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; properties.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &gt; properties[i][<span class="number">1</span>]) &#123;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            max = properties[i][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220128190729773.png" alt="image-20220128190729773"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1996-游戏中弱角色的数量&quot;&gt;&lt;a href=&quot;#力扣-1996-游戏中弱角色的数量&quot; class=&quot;headerlink&quot; title=&quot;力扣 1996. 游戏中弱角色的数量&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>删除回文子序列</title>
    <link href="https://blog.xuyicheng.top/2022-01-22-%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>https://blog.xuyicheng.top/2022-01-22-%E5%88%A0%E9%99%A4%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2022-01-22T02:51:59.000Z</published>
    <updated>2022-01-22T02:55:01.777Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1332-删除回文子序列"><a href="#力扣-1332-删除回文子序列" class="headerlink" title="力扣 1332. 删除回文子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/remove-palindromic-subsequences/">1332. 删除回文子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 <code>s</code>，它仅由字母 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code> 组成。每一次删除操作都可以从 <code>s</code> 中删除一个回文 <strong>子序列</strong>。</p><p>返回删除给定字符串中所有字符（字符串为空）的最小删除次数。</p><p>「子序列」定义：如果一个字符串可以通过删除原字符串某些字符而不改变原字符顺序得到，那么这个字符串就是原字符串的一个子序列。</p><p>「回文」定义：如果一个字符串向后和向前读是一致的，那么这个字符串就是一个回文。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅包含字母 <code>&#39;a&#39;</code> 和 <code>&#39;b&#39;</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;ababa&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：字符串本身就是回文序列，只需要删除一次。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;abb&quot; -&gt; &quot;bb&quot; -&gt; &quot;&quot;. </span><br><span class="line">先删除回文子序列 &quot;a&quot;，然后再删除 &quot;bb&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;baabb&quot;</span><br><span class="line">输出：2</span><br><span class="line">解释：&quot;baabb&quot; -&gt; &quot;b&quot; -&gt; &quot;&quot;. </span><br><span class="line">先删除回文子序列 &quot;baab&quot;，然后再删除 &quot;b&quot;。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题算是一个脑经急转弯，情况只是只有三种</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">removePalindromeSub</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回文字符串</span></span><br><span class="line">        <span class="keyword">if</span> (judge(s)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 先删除a，再删除b</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前字符串是不是回文字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line">        <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n / <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] != chars[n - <span class="number">1</span> - i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220122105437158.png" alt="image-20220122105437158"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1332-删除回文子序列&quot;&gt;&lt;a href=&quot;#力扣-1332-删除回文子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 1332. 删除回文子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最小时间差</title>
    <link href="https://blog.xuyicheng.top/2022-01-18-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE.html"/>
    <id>https://blog.xuyicheng.top/2022-01-18-%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E5%B7%AE.html</id>
    <published>2022-01-18T08:31:30.000Z</published>
    <updated>2022-01-18T08:33:59.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-539-最小时间差"><a href="#力扣-539-最小时间差" class="headerlink" title="力扣 539. 最小时间差"></a>力扣 <a href="https://leetcode-cn.com/problems/minimum-time-difference/">539. 最小时间差</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个 24 小时制（小时:分钟 **”HH:MM”**）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= timePoints.length &lt;= 2 * 10^4</code></li><li><code>timePoints[i]</code> 格式为 <strong>“HH:MM”</strong></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：timePoints = [&quot;00:00&quot;,&quot;23:59&quot;,&quot;00:00&quot;]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题直接计算即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinDifference</span><span class="params">(List&lt;String&gt; timePoints)</span> </span>&#123;</span><br><span class="line">    List&lt;<span class="keyword">int</span>[]&gt; times = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将字符串转化为小时和分钟的形式</span></span><br><span class="line">    <span class="keyword">for</span> (String s : timePoints) &#123;</span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> hour = (ch[<span class="number">0</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (ch[<span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> minute = (ch[<span class="number">3</span>] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + (ch[<span class="number">4</span>] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        times.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;hour, minute&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 按时间排序</span></span><br><span class="line">    times.sort((o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1[<span class="number">0</span>] == o2[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> o1[<span class="number">1</span>] - o2[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将第一个时间加上24个小时加到序列末尾方便计算最后一个时间与其差值</span></span><br><span class="line">    <span class="keyword">int</span> firstHour = times.get(<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> firstMinute = times.get(<span class="number">0</span>)[<span class="number">1</span>];</span><br><span class="line">    firstHour += <span class="number">24</span>;</span><br><span class="line">    times.add(<span class="keyword">new</span> <span class="keyword">int</span>[] &#123;firstHour, firstMinute&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minDiff = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; times.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = count(times.get(i - <span class="number">1</span>), times.get(i));</span><br><span class="line">        <span class="keyword">if</span> (diff == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        minDiff = Math.min(minDiff, diff);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> minDiff;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计算两时间之差</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time1 time1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> time2 time2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 所差的分钟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] time1, <span class="keyword">int</span>[] time2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (time1[<span class="number">0</span>] == time2[<span class="number">0</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> time2[<span class="number">1</span>] - time1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">60</span> * (time2[<span class="number">0</span>] - time1[<span class="number">0</span>]) + time2[<span class="number">1</span>] - time1[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220118163335194.png" alt="image-20220118163335194"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-539-最小时间差&quot;&gt;&lt;a href=&quot;#力扣-539-最小时间差&quot; class=&quot;headerlink&quot; title=&quot;力扣 539. 最小时间差&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/mini</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>建造者模式</title>
    <link href="https://blog.xuyicheng.top/2022-01-13-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://blog.xuyicheng.top/2022-01-13-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F.html</id>
    <published>2022-01-13T12:00:10.000Z</published>
    <updated>2022-01-13T12:06:37.791Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>在之前的文章中我们介绍了常见的设计模式，今天我们来使用 Java 语言对建造者模式进行具体实现举例。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>在下面的例子中，我们使用建造者模式来对 Person 类的实例化进行了改装，使其能够以<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%BC%8F%E6%8E%A5%E5%8F%A3">链式调用</a>的形式创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 当一个类的构造函数参数个数超过4个，而且这些参数有些是可选的参数，考虑使用构造者模式。</span></span><br><span class="line"><span class="comment"> * 源自 https://zhuanlan.zhihu.com/p/58093669</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> marx</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2022/01/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person person1 = <span class="keyword">new</span> Person(<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>, <span class="string">&quot;男&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        Person person2 = Person.builder()</span><br><span class="line">                                .name(<span class="string">&quot;李四&quot;</span>)</span><br><span class="line">                                .age(<span class="number">18</span>)</span><br><span class="line">                                .gender(<span class="string">&quot;男&quot;</span>)</span><br><span class="line">                                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 必选</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 必选</span></span><br><span class="line">    <span class="keyword">private</span> String gender; <span class="comment">// 必选</span></span><br><span class="line">    <span class="keyword">private</span> String address; <span class="comment">// 可选</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, String gender, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建造者模式使用的开始</span></span><br><span class="line"><span class="comment">     * 此处方法置为 static 是方便直接用类名调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> PersonBuilder&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PersonBuilder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PersonBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonBuilder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="keyword">private</span> String gender;</span><br><span class="line">        <span class="keyword">private</span> String address;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别用对应的属性名作为方法名来设置属性</span></span><br><span class="line">        <span class="comment">// 方法返回 this 是为了可以实现链式调用</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">age</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">gender</span><span class="params">(String gender)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.gender = gender;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> PersonBuilder <span class="title">address</span><span class="params">(String address)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.address = address;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 建造者模式使用的结尾，将中途获取的属性都注入对象中</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span> &#123;<span class="doctag">@link</span> Person&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Person <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Person(name, age, gender, address);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;在之前的文章中我们介绍了常见的设计模式，今天我们来使用 Java 语言对建造者模式进行具体实现举例。&lt;/p&gt;
&lt;h2 id=&quot;实例&quot;&gt;&lt;a </summary>
      
    
    
    
    <category term="设计模式" scheme="https://blog.xuyicheng.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="https://blog.xuyicheng.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>累加数</title>
    <link href="https://blog.xuyicheng.top/2022-01-10-%E7%B4%AF%E5%8A%A0%E6%95%B0.html"/>
    <id>https://blog.xuyicheng.top/2022-01-10-%E7%B4%AF%E5%8A%A0%E6%95%B0.html</id>
    <published>2022-01-10T09:36:44.000Z</published>
    <updated>2022-01-10T09:40:38.831Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-306-累加数"><a href="#力扣-306-累加数" class="headerlink" title="力扣 306. 累加数"></a>力扣 <a href="https://leetcode-cn.com/problems/additive-number/">306. 累加数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p><strong>累加数</strong> 是一个字符串，组成它的数字可以形成累加序列。</p><p>一个有效的 <strong>累加序列</strong> 必须 <strong>至少</strong> 包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。</p><p>给你一个只包含数字 ‘0’-‘9’ 的字符串，编写一个算法来判断给定输入是否是 <strong>累加数</strong> 。如果是，返回 true ；否则，返回 false 。</p><p>说明：累加序列里的数 <strong>不会</strong> 以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num.length &lt;= 35</code></li><li><code>num</code> 仅由数字（<code>0</code> - <code>9</code>）组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;112358&quot;</span><br><span class="line">输出：true </span><br><span class="line">解释：累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：&quot;199100199&quot;</span><br><span class="line">输出：true </span><br><span class="line">解释：累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题考察的其实就是深度优先搜索的能力和剪枝的判断</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * dfs</span></span><br><span class="line"><span class="comment">     * 大数字</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAdditiveNumber</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个数的位数</span></span><br><span class="line">        <span class="keyword">int</span> firstSize = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最起码有三个数</span></span><br><span class="line">        <span class="keyword">while</span> (firstSize &lt; size - <span class="number">1</span>) &#123;</span><br><span class="line">            String first = num.substring(<span class="number">0</span>, firstSize);</span><br><span class="line">            <span class="keyword">if</span> (judge(first)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 用BigInteger防止数字过长</span></span><br><span class="line">            BigInteger firstNum = <span class="keyword">new</span> BigInteger(first);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 遍历第二个数可能的位数</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= (size - firstSize) / <span class="number">2</span>; i++) &#123;</span><br><span class="line">                String second = num.substring(firstSize, firstSize + i);</span><br><span class="line">                <span class="keyword">if</span> (judge(second)) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                BigInteger secondNum = <span class="keyword">new</span> BigInteger(second);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 深度遍历后序是否符合题意</span></span><br><span class="line">                <span class="keyword">if</span> (dfs(num.substring(firstSize + i, size), firstNum, secondNum, <span class="number">2</span>)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 第一个数的预设长度加一</span></span><br><span class="line">            firstSize++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 没找到</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前数是否含有前置 0 且不为 0</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(String num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num.length() &gt; <span class="number">1</span> &amp;&amp; num.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 深度遍历</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> num       字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> firstNum  第一次num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secondNum 第二个num</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count     已经有几个符合要求的数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span> <span class="params">(String num, BigInteger firstNum, BigInteger secondNum, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> size = num.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当字符串遍历结束且已经有三个以上符合要求的数</span></span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span> &amp;&amp; count &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 取相加数中 位数更长的作为标记</span></span><br><span class="line">        <span class="keyword">int</span> bigSize = Math.max(firstNum.toString().length(), secondNum.toString().length());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 剩下的字符串长度不够则匹配失败</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; bigSize) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// a + b = c, c 可能的位数为 a, b 中较大的位数或加一</span></span><br><span class="line">        <span class="keyword">int</span> length = Math.min(size, bigSize + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = bigSize; i &lt;= length; i++) &#123;</span><br><span class="line">            String third = num.substring(<span class="number">0</span>, i);</span><br><span class="line">            <span class="keyword">if</span> (judge(third)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            BigInteger thirdNum = <span class="keyword">new</span> BigInteger(third);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// a + b = c 时继续遍历剩下的字符串</span></span><br><span class="line">            <span class="keyword">if</span> (firstNum.add(secondNum).equals(thirdNum)) &#123;</span><br><span class="line">                <span class="keyword">return</span> dfs(num.substring(i, size), secondNum, thirdNum, count + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220110173939559.png" alt="image-20220110173939559"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-306-累加数&quot;&gt;&lt;a href=&quot;#力扣-306-累加数&quot; class=&quot;headerlink&quot; title=&quot;力扣 306. 累加数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/additive-n</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="深度优先搜索" scheme="https://blog.xuyicheng.top/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>格雷编码</title>
    <link href="https://blog.xuyicheng.top/2022-01-08-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81.html"/>
    <id>https://blog.xuyicheng.top/2022-01-08-%E6%A0%BC%E9%9B%B7%E7%BC%96%E7%A0%81.html</id>
    <published>2022-01-08T12:08:46.000Z</published>
    <updated>2022-01-08T12:12:19.876Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-89-格雷编码"><a href="#力扣-89-格雷编码" class="headerlink" title="力扣 89. 格雷编码"></a>力扣 <a href="https://leetcode-cn.com/problems/gray-code/">89. 格雷编码</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：</p><ul><li>每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）</li><li>第一个整数是 0</li><li>一个整数在序列中出现 不超过一次</li><li>每对 相邻 整数的二进制表示 恰好一位不同 ，且</li><li>第一个 和 最后一个 整数的二进制表示 恰好一位不同</li><li>给你一个整数 n ，返回任一有效的 n 位格雷码序列 。</li></ul><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 16</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2</span><br><span class="line">输出：[0,1,3,2]</span><br><span class="line">解释：</span><br><span class="line">[0,1,3,2] 的二进制表示是 [00,01,11,10] 。</span><br><span class="line">- 00 和 01 有一位不同</span><br><span class="line">- 01 和 11 有一位不同</span><br><span class="line">- 11 和 10 有一位不同</span><br><span class="line">- 10 和 00 有一位不同</span><br><span class="line">[0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。</span><br><span class="line">- 00 和 10 有一位不同</span><br><span class="line">- 10 和 11 有一位不同</span><br><span class="line">- 11 和 01 有一位不同</span><br><span class="line">- 01 和 00 有一位不同</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题涉及到位操作，还有着对首尾元素的约束，所以这里我们采用对称操作的求解方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对称解法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">grayCode</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        result.add(<span class="number">0</span>);result.add(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为题目要求下一位与前一位的变化为二进制一位且要求首尾也要符合</span></span><br><span class="line">        <span class="comment">// 所以我们就在 n-1 求解出来的基础上进行求解</span></span><br><span class="line">        <span class="comment">// 每个 n 解其实结果数量时 n-1 的两倍</span></span><br><span class="line">        <span class="comment">// 所以我们可以利用这一点，将 n-1 的解对称翻转</span></span><br><span class="line">        <span class="comment">// 例如：[0, 1, 1, 0]，此时 n=2</span></span><br><span class="line">        <span class="comment">// 再将后面翻转所得的数首部都加一个 1（二进制）</span></span><br><span class="line">        <span class="comment">// 得：[00, 01, 11, 10]，可以看到完美符合题意</span></span><br><span class="line">        <span class="comment">// 以此类推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = <span class="number">2</span> &lt;&lt; (i - <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = size - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                result.add(result.get(j) + size);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间、空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220108201105878.png" alt="image-20220108201105878"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-89-格雷编码&quot;&gt;&lt;a href=&quot;#力扣-89-格雷编码&quot; class=&quot;headerlink&quot; title=&quot;力扣 89. 格雷编码&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/gray-code/</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>简化路径</title>
    <link href="https://blog.xuyicheng.top/2022-01-06-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84.html"/>
    <id>https://blog.xuyicheng.top/2022-01-06-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84.html</id>
    <published>2022-01-06T09:42:58.000Z</published>
    <updated>2022-01-06T09:50:15.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-71-简化路径"><a href="#力扣-71-简化路径" class="headerlink" title="力扣 71. 简化路径"></a>力扣 <a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><ul><li>始终以斜杠 ‘/‘ 开头。</li><li>两个目录名之间必须只有一个斜杠 ‘/‘ 。</li><li>最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。</li><li>返回简化后得到的 规范路径 。</li></ul><p><strong>提示：</strong></p><ul><li>1 &lt;= path.length &lt;= 3000</li><li>path 由英文字母，数字，’.’，’/‘ 或 ‘_’ 组成。</li><li>path 是一个有效的 Unix 风格绝对路径。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题只需要注意 <code>/</code> 和 <code>.</code> 即可，多个 <code>/</code> 等于一个 <code>/</code> ，所有我们可以将 <code>/</code> 去除将所有字符拆分开来后面再加 <code>/</code>，一个<code>.</code> 代表当前路径，无需改变栈，两个 <code>.</code> 要删除前一个路径，三个及以上 <code>.</code> 实际也视为一个文件名</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将所有非 / 字符拆分出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(temp.toString())) &#123;</span><br><span class="line">                    strList.add(temp.toString());</span><br><span class="line">                    temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.append(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(temp.toString())) &#123;</span><br><span class="line">            strList.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再通过栈后进先出的方式来应对路径变化</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str: strList) &#123;</span><br><span class="line">            <span class="comment">// 当前路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;.&quot;</span>.equals(str)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一级目录</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.addLast(<span class="string">&quot;/&quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        stack.forEach(temp::append);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止有空路径出现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.equals(temp.toString())? <span class="string">&quot;/&quot;</span>: temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220106174624828.png" alt="image-20220106174624828"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-71-简化路径&quot;&gt;&lt;a href=&quot;#力扣-71-简化路径&quot; class=&quot;headerlink&quot; title=&quot;力扣 71. 简化路径&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/simplify-p</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="栈" scheme="https://blog.xuyicheng.top/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>分数排名</title>
    <link href="https://blog.xuyicheng.top/2022-01-05-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D.html"/>
    <id>https://blog.xuyicheng.top/2022-01-05-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D.html</id>
    <published>2022-01-05T14:22:24.000Z</published>
    <updated>2022-01-05T14:28:46.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-178-分数排名"><a href="#力扣-178-分数排名" class="headerlink" title="力扣 178. 分数排名"></a>力扣 <a href="https://leetcode-cn.com/problems/rank-scores/">178. 分数排名</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Scores (id <span class="type">int</span>, score <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Scores</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3.5&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3.85&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询来实现分数排名。</p><p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong>对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <strong><code>Rank</code></strong></p><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为中等题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"># 解法一</span><br><span class="line"><span class="keyword">select</span> Score,(</span><br><span class="line">        # 查询在当前成绩之前的成绩等级有几个</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> Score) </span><br><span class="line">        <span class="keyword">from</span> Scores </span><br><span class="line">        # 此处用大于等于方便直接以 <span class="number">1</span> 开始排名</span><br><span class="line">        <span class="keyword">where</span> Score <span class="operator">&gt;=</span> s.Score</span><br><span class="line">    ) <span class="keyword">as</span> `Rank`</span><br><span class="line"><span class="keyword">from</span> Scores s</span><br><span class="line"># 再按照成绩进行降序排序</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 解法二</span><br><span class="line"># MySQL <span class="number">8</span> 支持 DENSE_RANK并列连续排序</span><br><span class="line"># 并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，依然按照连续数字排名。</span><br><span class="line"><span class="keyword">select</span> Score, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(</span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span></span><br><span class="line">    ) <span class="keyword">as</span> `Rank` </span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure><p>解法一效率：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220105222842315.png" alt="image-20220105222842315"></p><p>解法二效率：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220105222733193.png" alt="image-20220105222733193"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-178-分数排名&quot;&gt;&lt;a href=&quot;#力扣-178-分数排名&quot; class=&quot;headerlink&quot; title=&quot;力扣 178. 分数排名&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/rank-sc</summary>
      
    
    
    
    
    <category term="SQL" scheme="https://blog.xuyicheng.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>完美数</title>
    <link href="https://blog.xuyicheng.top/2021-12-31-%E5%AE%8C%E7%BE%8E%E6%95%B0.html"/>
    <id>https://blog.xuyicheng.top/2021-12-31-%E5%AE%8C%E7%BE%8E%E6%95%B0.html</id>
    <published>2021-12-31T07:09:22.000Z</published>
    <updated>2021-12-31T07:23:00.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-507-完美数"><a href="#力扣-507-完美数" class="headerlink" title="力扣 507. 完美数"></a>力扣 <a href="https://leetcode-cn.com/problems/perfect-number/">507. 完美数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。</p><p>给定一个 整数 n， 如果是完美数，返回 true，否则返回 false</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^8</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 28</span><br><span class="line">输出：true</span><br><span class="line">解释：28 = 1 + 2 + 4 + 7 + 14</span><br><span class="line">1, 2, 4, 7, 和 14 是 28 的所有正因子。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 6</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 496</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 8128</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题可以直接暴力求解，但是效率比较低，我们可以采用一次消去两个因子的形式，需要注意1不是完美数</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求因子时我们可以一次计算两个因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="keyword">int</span>) Math.sqrt(num) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                tick += i;</span><br><span class="line">                <span class="comment">// 排除出现开方因子的可能</span></span><br><span class="line">                <span class="keyword">if</span> (i * i != num) &#123;</span><br><span class="line">                    tick += num / i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tick + 1 是因为还存在 1 这个因子，此外还需要排除 num = 1 的情况</span></span><br><span class="line">        <span class="keyword">return</span> num == tick + <span class="number">1</span> &amp;&amp; num != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211231152049174.png" alt="image-20211231152049174"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-507-完美数&quot;&gt;&lt;a href=&quot;#力扣-507-完美数&quot; class=&quot;headerlink&quot; title=&quot;力扣 507. 完美数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/perfect-nu</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数学" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>一手顺子</title>
    <link href="https://blog.xuyicheng.top/2021-12-30-%E4%B8%80%E6%89%8B%E9%A1%BA%E5%AD%90.html"/>
    <id>https://blog.xuyicheng.top/2021-12-30-%E4%B8%80%E6%89%8B%E9%A1%BA%E5%AD%90.html</id>
    <published>2021-12-30T11:54:19.000Z</published>
    <updated>2021-12-30T12:02:32.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-846-一手顺子"><a href="#力扣-846-一手顺子" class="headerlink" title="力扣 846. 一手顺子"></a>力扣 <a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。</p><p>给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= hand.length &lt;= 10^4</code></li><li><code>0 &lt;= hand[i] &lt;= 10^9</code></li><li><code>1 &lt;= groupSize &lt;= hand.length</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3</span><br><span class="line">输出：true</span><br><span class="line">解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hand = [1,2,3,4,5], groupSize = 4</span><br><span class="line">输出：false</span><br><span class="line">解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题可以采用贪心策略，我们将所有数据存进优先队列，如何取一个最小的数，然后再在优先队列中将后面的序列依次筛查即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先队列</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNStraightHand</span><span class="params">(<span class="keyword">int</span>[] hand, <span class="keyword">int</span> groupSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hand.length;</span><br><span class="line">        <span class="comment">// 特例</span></span><br><span class="line">        <span class="keyword">if</span> (groupSize == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h: hand) &#123;</span><br><span class="line">            queue.add(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出一个元素作为首元素</span></span><br><span class="line">            <span class="keyword">int</span> first = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列删除，如果队列中不包含后序元素则直接返回 false</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; groupSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queue.remove(first + i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素排完</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211230195948934.png" alt="image-20211230195948934"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-846-一手顺子&quot;&gt;&lt;a href=&quot;#力扣-846-一手顺子&quot; class=&quot;headerlink&quot; title=&quot;力扣 846. 一手顺子&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/hand-of</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="优先队列" scheme="https://blog.xuyicheng.top/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="https://blog.xuyicheng.top/tags/%E8%B4%AA%E5%BF%83/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>统计特殊四元组</title>
    <link href="https://blog.xuyicheng.top/2021-12-29-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84.html"/>
    <id>https://blog.xuyicheng.top/2021-12-29-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84.html</id>
    <published>2021-12-29T13:28:13.000Z</published>
    <updated>2021-12-29T13:32:57.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1995-统计特殊四元组"><a href="#力扣-1995-统计特殊四元组" class="headerlink" title="力扣 1995. 统计特殊四元组"></a>力扣 <a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：</p><ul><li>nums[a] + nums[b] + nums[c] == nums[d] ，且</li><li>a &lt; b &lt; c &lt; d</li></ul><p><strong>提示：</strong></p><ul><li><code>4 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,6]</span><br><span class="line">输出：1</span><br><span class="line">解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3,6,4,5]</span><br><span class="line">输出：0</span><br><span class="line">解释：[3,3,6,4,5] 中不存在满足要求的四元组。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,3,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足要求的 4 个四元组如下：</span><br><span class="line">- (0, 1, 2, 3): 1 + 1 + 1 == 3</span><br><span class="line">- (0, 1, 3, 4): 1 + 1 + 3 == 5</span><br><span class="line">- (0, 2, 3, 4): 1 + 1 + 3 == 5</span><br><span class="line">- (1, 2, 3, 4): 1 + 1 + 3 == 5</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题简单在数据范围，可以直接用多重for循环暴力求解，我们在这里采用哈希表+双重for循环的形式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 本题中看似是四个数的查找，其实我们将等式移动一下不难发现</span></span><br><span class="line">    <span class="comment">// a + b = d - c</span></span><br><span class="line">    <span class="comment">// 这样我们就可以利用哈希表从后向前记录 d - c 的可能</span></span><br><span class="line">    <span class="comment">// 同时利用 b 当中轴，如何向前遍历 a</span></span><br><span class="line">    <span class="comment">// 这样原来的四重 for 循环就变成双重循环了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countQuadruplets</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处将 b 作为中轴向前寻找 a，向后寻找 d - c</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = n - <span class="number">3</span>; b &gt;= <span class="number">1</span>; b--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = b + <span class="number">2</span>; d &lt; n; d++) &#123;</span><br><span class="line">                temp = nums[d] - nums[b + <span class="number">1</span>];</span><br><span class="line">                map.put(temp, map.getOrDefault(temp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; b; a++) &#123;</span><br><span class="line">                temp = nums[a] + nums[b];</span><br><span class="line">                result += map.getOrDefault(temp, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211229213115217.png" alt="image-20211229213115217"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1995-统计特殊四元组&quot;&gt;&lt;a href=&quot;#力扣-1995-统计特殊四元组&quot; class=&quot;headerlink&quot; title=&quot;力扣 1995. 统计特殊四元组&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://blog.xuyicheng.top/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第二高的薪水</title>
    <link href="https://blog.xuyicheng.top/2021-12-28-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4.html"/>
    <id>https://blog.xuyicheng.top/2021-12-28-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4.html</id>
    <published>2021-12-28T03:31:58.000Z</published>
    <updated>2021-12-28T03:34:36.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-176-第二高的薪水"><a href="#力扣-176-第二高的薪水" class="headerlink" title="力扣 176. 第二高的薪水"></a>力扣 <a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (id <span class="type">int</span>, salary <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;300&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为中等题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"># 外层嵌套循环来实现题目要求的 &quot;如果不存在第二高的薪水，那么查询应返回 null&quot;</span><br><span class="line"><span class="keyword">select</span> (</span><br><span class="line">    # 因为薪水可能出现重复的，所以这里采用 <span class="keyword">distinct</span> 来取薪水的唯一值</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> salary </span><br><span class="line">    <span class="keyword">from</span> Employee </span><br><span class="line">    # 获取第二高，所以采用 <span class="keyword">order</span> <span class="keyword">by</span> 进行排序，且采用 <span class="keyword">desc</span> 降序排序</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">    # 取第二条数据（<span class="number">1</span>, <span class="number">1</span> 表示从第 <span class="number">2</span> 条数据开始取一条数据，MySQL 数据第 <span class="number">0</span> 行才是第 <span class="number">1</span> 条数据）</span><br><span class="line">    limit <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211228113424399.png" alt="image-20211228113424399"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-176-第二高的薪水&quot;&gt;&lt;a href=&quot;#力扣-176-第二高的薪水&quot; class=&quot;headerlink&quot; title=&quot;力扣 176. 第二高的薪水&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/s</summary>
      
    
    
    
    
    <category term="SQL" scheme="https://blog.xuyicheng.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>适龄的朋友</title>
    <link href="https://blog.xuyicheng.top/2021-12-27-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B.html"/>
    <id>https://blog.xuyicheng.top/2021-12-27-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B.html</id>
    <published>2021-12-27T15:31:33.000Z</published>
    <updated>2021-12-27T15:40:51.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-825-适龄的朋友"><a href="#力扣-825-适龄的朋友" class="headerlink" title="力扣 825. 适龄的朋友"></a>力扣 <a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：</p><ul><li>age[y] &lt;= 0.5 * age[x] + 7</li><li>age[y] &gt; age[x]</li><li>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100<br>否则，x 将会向 y 发送一条好友请求。</li></ul><p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p><strong>提示：</strong></p><ul><li><code>n == ages.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>1 &lt;= ages[i] &lt;= 120</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [16,16]</span><br><span class="line">输出：2</span><br><span class="line">解释：2 人互发好友请求。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [16,17,18]</span><br><span class="line">输出：2</span><br><span class="line">解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [20,30,100,110,120]</span><br><span class="line">输出：3</span><br><span class="line">解释：产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们可以先对数组进行排序，然后根据题目两个约束（虽然是三个条件，但实际符合前两个条件即可），用双指针来寻找符合条件的区间</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="keyword">int</span>[] ages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ages.length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(ages);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 age 是 ages[x]</span></span><br><span class="line">        <span class="comment">// 要寻找符合条件的 ages[y] 区间</span></span><br><span class="line">        <span class="comment">// 因为随着 ages[x] 的变大，ages[y] 左右区间也是向后偏移的，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> age : ages) &#123;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 ages[x] &lt; 15 时，找不到符合条件的 ages[y]</span></span><br><span class="line">            <span class="keyword">if</span> (age &lt; <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配对的左区间</span></span><br><span class="line">            <span class="keyword">while</span> (ages[left] &lt;= <span class="number">0.5</span> * age + <span class="number">7</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配对的右区间</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; ages[right + <span class="number">1</span>] &lt;= age) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累加这个区间</span></span><br><span class="line">            result += right - left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211227233415373.png" alt="image-20211227233415373"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-825-适龄的朋友&quot;&gt;&lt;a href=&quot;#力扣-825-适龄的朋友&quot; class=&quot;headerlink&quot; title=&quot;力扣 825. 适龄的朋友&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/frie</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="数组" scheme="https://blog.xuyicheng.top/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://blog.xuyicheng.top/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>组合两个表</title>
    <link href="https://blog.xuyicheng.top/2021-12-27-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8.html"/>
    <id>https://blog.xuyicheng.top/2021-12-27-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8.html</id>
    <published>2021-12-27T03:25:31.000Z</published>
    <updated>2021-12-28T03:31:32.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-175-组合两个表"><a href="#力扣-175-组合两个表" class="headerlink" title="力扣 175. 组合两个表"></a>力扣 <a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (personId <span class="type">int</span>, firstName <span class="type">varchar</span>(<span class="number">255</span>), lastName <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Address (addressId <span class="type">int</span>, personId <span class="type">int</span>, city <span class="type">varchar</span>(<span class="number">255</span>), state <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Address</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Leetcode&#x27;</span>, <span class="string">&#x27;California&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>表1: Person</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure></li><li><p>表2: Address</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为简单题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State </span><br><span class="line"># 题目要求：&quot;无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息&quot;</span><br><span class="line"># 所以在此处选择 Person 表左连接 Address 表，保证将所有 Person 表的数据都查询出来</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address </span><br><span class="line"># 两表连接数据的筛选条件</span><br><span class="line"><span class="keyword">on</span> Person.PersonId <span class="operator">=</span> Address.PersonId</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211228113055962.png" alt="image-20211228113055962"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-175-组合两个表&quot;&gt;&lt;a href=&quot;#力扣-175-组合两个表&quot; class=&quot;headerlink&quot; title=&quot;力扣 175. 组合两个表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/comb</summary>
      
    
    
    
    
    <category term="SQL" scheme="https://blog.xuyicheng.top/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>奇偶树</title>
    <link href="https://blog.xuyicheng.top/2021-12-25-%E5%A5%87%E5%81%B6%E6%A0%91.html"/>
    <id>https://blog.xuyicheng.top/2021-12-25-%E5%A5%87%E5%81%B6%E6%A0%91.html</id>
    <published>2021-12-25T02:14:24.000Z</published>
    <updated>2021-12-25T16:19:54.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1609-奇偶树"><a href="#力扣-1609-奇偶树" class="headerlink" title="力扣 1609. 奇偶树"></a>力扣 <a href="https://leetcode-cn.com/problems/even-odd-tree/">1609. 奇偶树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：</p><p>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。</p><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 10^5]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 10^6</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_1_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：每一层的节点值分别是：</span><br><span class="line">0 层：[1]</span><br><span class="line">1 层：[10,4]</span><br><span class="line">2 层：[3,7,9]</span><br><span class="line">3 层：[12,8,6,2]</span><br><span class="line">由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_2_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,2,3,3,7]</span><br><span class="line">输出：false</span><br><span class="line">解释：每一层的节点值分别是：</span><br><span class="line">0 层：[5]</span><br><span class="line">1 层：[4,2]</span><br><span class="line">2 层：[3,3,7]</span><br><span class="line">2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_1_333_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,9,1,3,5,7]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 层上的节点值应为偶数。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们直接层序遍历如何判断每层即可，不过读者切记需要判断是否“严格”递增</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvenOddTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点非奇节点</span></span><br><span class="line">        <span class="keyword">if</span> ((root.val &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.offer(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.offer(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> last = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> num = node.val;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 奇偶性错误</span></span><br><span class="line">                <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) != tick) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首元素</span></span><br><span class="line">                <span class="keyword">if</span> (last == -<span class="number">1</span>) &#123;</span><br><span class="line">                    last = num;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 和上一个数相等代表非严格递增或者递减</span></span><br><span class="line">                <span class="keyword">if</span> (num == last) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 增减性错误</span></span><br><span class="line">                <span class="keyword">int</span> count = num &gt; last? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (count != tick) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                last = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tick = (tick + <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211226001854590.png" alt="image-20211226001854590"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1609-奇偶树&quot;&gt;&lt;a href=&quot;#力扣-1609-奇偶树&quot; class=&quot;headerlink&quot; title=&quot;力扣 1609. 奇偶树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/even-od</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="二叉树" scheme="https://blog.xuyicheng.top/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="https://blog.xuyicheng.top/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>重复叠加字符串匹配</title>
    <link href="https://blog.xuyicheng.top/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html"/>
    <id>https://blog.xuyicheng.top/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html</id>
    <published>2021-12-22T15:41:38.000Z</published>
    <updated>2021-12-22T15:44:42.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-686-重复叠加字符串匹配"><a href="#力扣-686-重复叠加字符串匹配" class="headerlink" title="力扣 686. 重复叠加字符串匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length &lt;= 10^4</code></li><li><code>1 &lt;= b.length &lt;= 10^4</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：a 重复叠加三遍后为 &quot;abcdabcdabcd&quot;, 此时 b 是其子串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;aa&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;a&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abc&quot;, b = &quot;wxyz&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们只需要知道字符串a重复可能的上界即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizeA = a.length();</span><br><span class="line">        <span class="keyword">int</span> sizeB = b.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最少可能情况 a 包含 b</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最大可能 a 重复 sizeB / sizeA 次，再在首位各自加一个</span></span><br><span class="line">        <span class="keyword">int</span> right = sizeB / sizeA + <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!sb.toString().contains(b)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !sb.toString().contains(b)? -<span class="number">1</span>: left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211222234404914.png" alt="image-20211222234404914"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-686-重复叠加字符串匹配&quot;&gt;&lt;a href=&quot;#力扣-686-重复叠加字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 686. 重复叠加字符串匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="二分查找" scheme="https://blog.xuyicheng.top/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>一年中的第几天</title>
    <link href="https://blog.xuyicheng.top/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html"/>
    <id>https://blog.xuyicheng.top/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html</id>
    <published>2021-12-21T07:16:42.000Z</published>
    <updated>2021-12-21T07:19:24.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1154-一年中的第几天"><a href="#力扣-1154-一年中的第几天" class="headerlink" title="力扣 1154. 一年中的第几天"></a>力扣 <a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。</p><p>通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。</p><p><strong>提示：</strong></p><ul><li>date.length == 10</li><li>date[4] == date[7] == ‘-‘，其他的 date[i] 都是数字</li><li>date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-01-09&quot;</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-02-10&quot;</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2003-03-01&quot;</span><br><span class="line">输出：60</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2004-03-01&quot;</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题思路比较简单，直接计算即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个月份的前置天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] counts = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀和计算好这个月之前过去了多少天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        String[] temp = date.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = Integer.parseInt(temp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> mouth = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> day = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 年份为闰年且月份在二月之后预先加上一天</span></span><br><span class="line">        <span class="keyword">int</span> result = (judge(year) &amp;&amp; mouth &gt; <span class="number">2</span>)? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        result += counts[mouth - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        result += day;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前年份是否是闰年</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> year 年份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是闰年则返回 true，反之 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year % <span class="number">4</span> == <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211221151847237.png" alt="image-20211221151847237"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1154-一年中的第几天&quot;&gt;&lt;a href=&quot;#力扣-1154-一年中的第几天&quot; class=&quot;headerlink&quot; title=&quot;力扣 1154. 一年中的第几天&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="https://blog.xuyicheng.top/tags/java/"/>
    
    <category term="字符串" scheme="https://blog.xuyicheng.top/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
