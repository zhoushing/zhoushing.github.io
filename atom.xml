<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2021-12-22T15:44:42.033Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>重复叠加字符串匹配</title>
    <link href="http://zhoushing.github.io/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html"/>
    <id>http://zhoushing.github.io/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html</id>
    <published>2021-12-22T15:41:38.000Z</published>
    <updated>2021-12-22T15:44:42.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-686-重复叠加字符串匹配"><a href="#力扣-686-重复叠加字符串匹配" class="headerlink" title="力扣 686. 重复叠加字符串匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length &lt;= 10^4</code></li><li><code>1 &lt;= b.length &lt;= 10^4</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：a 重复叠加三遍后为 &quot;abcdabcdabcd&quot;, 此时 b 是其子串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;aa&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;a&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abc&quot;, b = &quot;wxyz&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们只需要知道字符串a重复可能的上界即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizeA = a.length();</span><br><span class="line">        <span class="keyword">int</span> sizeB = b.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最少可能情况 a 包含 b</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最大可能 a 重复 sizeB / sizeA 次，再在首位各自加一个</span></span><br><span class="line">        <span class="keyword">int</span> right = sizeB / sizeA + <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!sb.toString().contains(b)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !sb.toString().contains(b)? -<span class="number">1</span>: left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211222234404914.png" alt="image-20211222234404914"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-686-重复叠加字符串匹配&quot;&gt;&lt;a href=&quot;#力扣-686-重复叠加字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 686. 重复叠加字符串匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二分查找" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>一年中的第几天</title>
    <link href="http://zhoushing.github.io/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html"/>
    <id>http://zhoushing.github.io/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html</id>
    <published>2021-12-21T07:16:42.000Z</published>
    <updated>2021-12-21T07:19:24.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1154-一年中的第几天"><a href="#力扣-1154-一年中的第几天" class="headerlink" title="力扣 1154. 一年中的第几天"></a>力扣 <a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。</p><p>通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。</p><p><strong>提示：</strong></p><ul><li>date.length == 10</li><li>date[4] == date[7] == ‘-‘，其他的 date[i] 都是数字</li><li>date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-01-09&quot;</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-02-10&quot;</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2003-03-01&quot;</span><br><span class="line">输出：60</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2004-03-01&quot;</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题思路比较简单，直接计算即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个月份的前置天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] counts = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀和计算好这个月之前过去了多少天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        String[] temp = date.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = Integer.parseInt(temp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> mouth = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> day = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 年份为闰年且月份在二月之后预先加上一天</span></span><br><span class="line">        <span class="keyword">int</span> result = (judge(year) &amp;&amp; mouth &gt; <span class="number">2</span>)? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        result += counts[mouth - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        result += day;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前年份是否是闰年</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> year 年份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是闰年则返回 true，反之 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year % <span class="number">4</span> == <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211221151847237.png" alt="image-20211221151847237"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1154-一年中的第几天&quot;&gt;&lt;a href=&quot;#力扣-1154-一年中的第几天&quot; class=&quot;headerlink&quot; title=&quot;力扣 1154. 一年中的第几天&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>供暖器</title>
    <link href="http://zhoushing.github.io/2021-12-20-%E4%BE%9B%E6%9A%96%E5%99%A8.html"/>
    <id>http://zhoushing.github.io/2021-12-20-%E4%BE%9B%E6%9A%96%E5%99%A8.html</id>
    <published>2021-12-20T13:50:18.000Z</published>
    <updated>2021-12-20T13:54:52.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-475-供暖器"><a href="#力扣-475-供暖器" class="headerlink" title="力扣 475. 供暖器"></a>力扣 <a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p><p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p><p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= houses[i], heaters[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3], heaters = [2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3,4], heaters = [1,4]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [1,5], heaters = [2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中的每个房子使用的供暖不是前一个供暖器就是后一个，所以我们只需要遍历每个屋子并判断即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeSet</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用 TreeSet 来存储供暖器的位置，方便取得房屋前后取暖器的位置</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> heater: heaters) &#123;</span><br><span class="line">            set.add(heater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> house: houses) &#123;</span><br><span class="line">            <span class="comment">// floor：取得当前 TreeSet 中小于等于当前元素的最大值</span></span><br><span class="line">            Integer low = set.floor(house);</span><br><span class="line">            <span class="comment">// floor：取得当前 TreeSet 中大于等于当前元素的最小值</span></span><br><span class="line">            Integer high = set.ceiling(house);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = Math.max(result, high - house);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = Math.max(result, house - low);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = Math.max(result, Math.min((high - house), (house - low)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211220215307575.png" alt="image-20211220215307575"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-475-供暖器&quot;&gt;&lt;a href=&quot;#力扣-475-供暖器&quot; class=&quot;headerlink&quot; title=&quot;力扣 475. 供暖器&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/heaters/&quot;&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="TreeSet" scheme="http://zhoushing.github.io/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>找到小镇的法官</title>
    <link href="http://zhoushing.github.io/2021-12-19-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98.html"/>
    <id>http://zhoushing.github.io/2021-12-19-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98.html</id>
    <published>2021-12-19T13:24:20.000Z</published>
    <updated>2021-12-19T14:12:53.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-997-找到小镇的法官"><a href="#力扣-997-找到小镇的法官" class="headerlink" title="力扣 997. 找到小镇的法官"></a>力扣 <a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。</p><p>如果小镇的法官真的存在，那么：</p><p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足条件 1 和条件 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。</p><p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, trust = [[1,2]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,3],[2,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,2],[2,3]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题不会出现某个人信任自己的情况，所以我们统计每个人信任和被信任的情况即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 相信过几个人</span></span><br><span class="line">        <span class="keyword">int</span>[] tru = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 被几个人相信</span></span><br><span class="line">        <span class="keyword">int</span>[] beTru = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] temp: trust) &#123;</span><br><span class="line">            tru[temp[<span class="number">0</span>]]++;</span><br><span class="line">            beTru[temp[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当此人被其他所有人信任且不信任别人</span></span><br><span class="line">            <span class="comment">// 即可假定其是秘密法官</span></span><br><span class="line">            <span class="keyword">if</span> (beTru[i] == n - <span class="number">1</span> &amp;&amp; tru[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    result = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 多于一人时说明无法确定</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211219220721029.png" alt="image-20211219220721029"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-997-找到小镇的法官&quot;&gt;&lt;a href=&quot;#力扣-997-找到小镇的法官&quot; class=&quot;headerlink&quot; title=&quot;力扣 997. 找到小镇的法官&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>甲板上的战舰</title>
    <link href="http://zhoushing.github.io/2021-12-18-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0.html"/>
    <id>http://zhoushing.github.io/2021-12-18-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0.html</id>
    <published>2021-12-18T03:20:54.000Z</published>
    <updated>2021-12-18T04:19:09.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-419-甲板上的战舰"><a href="#力扣-419-甲板上的战舰" class="headerlink" title="力扣 419. 甲板上的战舰"></a>力扣 <a href="https://leetcode-cn.com/problems/battleships-in-a-board/">419. 甲板上的战舰</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。</p><p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 是 <code>&#39;.&#39;</code> 或 <code>&#39;X&#39;</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/battelship-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;.&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题我们只需按照左上角计算战舰即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ticks[i][j] &amp;&amp; board[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 只统计左上角</span></span><br><span class="line">                    result++;</span><br><span class="line">                    tick(board, ticks, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] ticks, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界或者为空地则回退</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只向下向右判断</span></span><br><span class="line">        tick(board, ticks, i + <span class="number">1</span>, j);</span><br><span class="line">        tick(board, ticks, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211218115423092.png" alt="image-20211218115423092"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-419-甲板上的战舰&quot;&gt;&lt;a href=&quot;#力扣-419-甲板上的战舰&quot; class=&quot;headerlink&quot; title=&quot;力扣 419. 甲板上的战舰&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/b</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="广度优先搜索" scheme="http://zhoushing.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>换酒问题</title>
    <link href="http://zhoushing.github.io/2021-12-17-%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98.html"/>
    <id>http://zhoushing.github.io/2021-12-17-%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98.html</id>
    <published>2021-12-17T12:46:26.000Z</published>
    <updated>2021-12-17T12:59:37.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1518-换酒问题"><a href="#力扣-1518-换酒问题" class="headerlink" title="力扣 1518. 换酒问题"></a>力扣 <a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p><p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多 能喝到多少瓶酒。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/sample_1_1875.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 9, numExchange = 3</span><br><span class="line">输出：13</span><br><span class="line">解释：你可以用 3 个空酒瓶兑换 1 瓶酒。</span><br><span class="line">所以最多能喝到 9 + 3 + 1 = 13 瓶酒。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/sample_2_1875.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 15, numExchange = 4</span><br><span class="line">输出：19</span><br><span class="line">解释：你可以用 4 个空酒瓶兑换 1 瓶酒。</span><br><span class="line">所以最多能喝到 15 + 3 + 1 = 19 瓶酒。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 5, numExchange = 5</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 2, numExchange = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题我们直接模拟换算的过程即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数学</span></span><br><span class="line"><span class="comment">     * 模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numBottles &lt; numExchange) &#123;</span><br><span class="line">            <span class="keyword">return</span> numBottles;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count(numBottles, <span class="number">0</span>, numExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * now: 现在拥有的酒数</span></span><br><span class="line"><span class="comment">     * preRemain: 上次剩下的酒瓶子数</span></span><br><span class="line"><span class="comment">     * numExchange: 交换比例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> preRemain, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = now;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((now + preRemain) &gt;= numExchange) &#123;</span><br><span class="line">            <span class="comment">// 酒瓶交换的酒数</span></span><br><span class="line">            <span class="keyword">int</span> exchangeNum = (now + preRemain) / numExchange;</span><br><span class="line">            <span class="comment">// 交换剩下的酒瓶数</span></span><br><span class="line">            <span class="keyword">int</span> remain = (now + preRemain) % numExchange;</span><br><span class="line">            result += count(exchangeNum, remain, numExchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211217205854842.png" alt="image-20211217205854842"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1518-换酒问题&quot;&gt;&lt;a href=&quot;#力扣-1518-换酒问题&quot; class=&quot;headerlink&quot; title=&quot;力扣 1518. 换酒问题&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/wate</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="模拟" scheme="http://zhoushing.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>后端仔如何优雅的写前端（一）</title>
    <link href="http://zhoushing.github.io/2021-11-27-%E5%90%8E%E7%AB%AF%E4%BB%94%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://zhoushing.github.io/2021-11-27-%E5%90%8E%E7%AB%AF%E4%BB%94%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89.html</id>
    <published>2021-11-27T08:38:45.000Z</published>
    <updated>2021-11-28T02:48:25.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    无论是在生产或者学习中，我们后端开发人员（以下简称为后端仔），总是离不开和前端打交道，甚至在某些迫不得已的时候，我们也需要挺身而出靠自己的能力编写前端。此篇文章仅根据笔者自己的理解加一些的实际编写经验，适合对前端想要了解或者是来要做项目抱佛脚的后端仔。</p><p>​    我相信很多小伙伴其实和笔者一样，都是接触后端语言，类似于c++、java等入门的，各大高校的课程通常没有直接教学并实战前端的，所以在这里我先从前端的介绍开始逐步给大家展示如何上手前端。在本篇中主要是对前端的情况以及发展历史做一些介绍，不感兴趣的读者可以直接转看下一篇，但还是<strong>建议读者粗略的看一眼，只需注意加粗的部分即可，这关系到我们后面上手时所用的技术或语言</strong>。</p><h2 id="前端的介绍"><a href="#前端的介绍" class="headerlink" title="前端的介绍"></a>前端的介绍</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <strong>前端</strong>（英语：<strong>front-end</strong>）和<strong>后端</strong>（英语：<strong>back-end</strong>）是描述进程开始和结束的通用词汇。前端作用于采集输入信息，后端进行处理。计算机程序的<a href="https://zh.wikipedia.org/wiki/%E7%95%8C%E9%9D%A2">界面</a>样式，视觉呈现属于前端。在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B">软体架构</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出。说白了在通常的项目和工程中，直接展示给用户，可以直接与用户进行交互的部分，例如一个网站项目中的<strong>HTML</strong>、<strong>CSS</strong>等负责展示的部分，<strong>JavaScript</strong>等负责交互的部分都属于<strong>前端</strong>；而与数据库中的数据进行交互，在用户看不见的地方进行数据处理的部分，例如<strong>c++、Java</strong>等部分都属于<strong>后端</strong>。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211127210505274.png" alt="image-20211127210505274"></p><p>我们可以看到从1990HTML问世以来，前端的发展已经经历了许多扩展和尝试了，在这其中有几个重要的节点，其中提到的名词可能大家都听说或者了解过。</p><p>1990 年，Tim 以超文本语言 HTML 为基础在 NeXT 电脑上发明了最原始的 <strong>Web 浏览器</strong>。</p><p>1994 年底，由 Tim 牵头的万维网联盟（World Wide Web Consortium）也就是 <strong>W3C</strong> 成立，这标志着万维网的正式诞生。此时的网页以 HTML 为主，是纯静态的网页，网页是“只读”的，信息流只能通过服务器到客户端单向流通，由此世界进入了 Web 1.0 时代。</p><p>1995 年，网景工程师 Brendan Eich 花了10天时间设计了 <strong>JavaScript</strong> 语言。起初这种<strong>脚本语言</strong>叫做 Mocha，后改名 LiveScript，后来为了借助 Java 语言创造良好的营销效果最终改名为 JavaScript。网景公司把这种脚本语言嵌入到了 Navigator 2.0 之中，使其能在浏览器中运行。</p><p>与此相对的是，1996 年，微软发布了 VBScript 和 JScript。JScript 是对 JavaScript 进行逆向工程的实现，并内置于 Internet Explorer 3 中。但是 JavaScript 与 JScript 两种语言的实现存在差别，这导致了程序员开发的网页不能同时兼容 Navigator 和 Internet Explorer 浏览器。 <strong>I</strong>nternet <strong>E</strong>xplorer 开始抢夺 Netscape 的市场份额，这导致了第一次浏览器战争。</p><ul><li><p>1996.12 W3C 推出了 <strong>CSS</strong> 1.0 规范</p></li><li><p>1997.6 ECMA 以 JavaScript 语言为基础制定了 ECMAScript 1.0 标准规范</p></li><li><p>1999 W3C 发布 HTML 4.01 标准，同年微软推出用于<strong>异步数据传输</strong>的 ActiveX，随即各大浏览器厂商模仿实现了 XMLHttpRequest（AJAX 雏形）。</p></li></ul><p>第一次浏览器战争以 IE 浏览器完胜 Netscape 而结束，IE 开始统领浏览器市场，份额的最高峰达到 2002 年的 96%。</p><h4 id="动态页面的崛起"><a href="#动态页面的崛起" class="headerlink" title="动态页面的崛起"></a><strong>动态页面的崛起</strong></h4><p><strong>PHP</strong>（PHP：Hypertext Preprocessor）最初是由 Rasmus Lerdorf 在 1995 年开始开发的，PHP 的主要目标是允许网络开发人员快速编写动态页面。</p><p><strong>JSP</strong>（JavaServer Pages）是由 Sun 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，从而动态生成 HTML、XML 或其他格式文档的 Web 网页的技术标准。JSP 技术是以 Java 语言为基础的。1999 年，JSP 1.2 规范随着 J2EE 1.2 发布。</p><p><strong>ASP</strong>（Active Server Pages）1.0 在 1996 年随着 IIS 3.0 而发布。2002 年，<a href="http://asp.net/">ASP.NET</a> 发布，用于替代 ASP。</p><p>随着这些动态服务器页面技术的出现，页面不再是静止的，页面可以获取服务器数据信息并不断更新。以 <strong>Google</strong> 为代表的搜索引擎以及各种论坛相继出现，使得 Web 充满了活力。</p><p>从 Web 诞生至 2005 年，一直处于<strong>后端重、前端轻</strong>的状态。</p><h4 id="AJAX-的流行"><a href="#AJAX-的流行" class="headerlink" title="AJAX 的流行"></a><strong>AJAX 的流行</strong></h4><p>在 Web 最初发展的阶段，前端页面要想获取后台信息需要刷新整个页面，这是很糟糕的用户体验。</p><ul><li>2005年2月，<strong>Ajax</strong>的概念由杰西·詹姆士·贾瑞特所提出。**<a href="https://zh.wikipedia.org/wiki/AJAX">AJAX</a><strong>即“</strong>Asynchronous JavaScript and XML**”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术），指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术。</li></ul><p>随着 AJAX 的流行，越来越多的网站使用 AJAX 动态获取数据，这使得动态网页内容变成可能，像 Facebook 这样的社交网络开始变得繁荣起来，前端一时间呈现出了欣欣向荣的局面。</p><p>AJAX 使得浏览器客户端可以更方便地向服务器发送数据信息，这促进了 Web 2.0 的发展。</p><ul><li>2006 <strong>XMLHttpRequest</strong> 被 W3C 正式纳入标准。</li></ul><h4 id="前端兼容性框架的出现"><a href="#前端兼容性框架的出现" class="headerlink" title="前端兼容性框架的出现"></a><strong>前端兼容性框架的出现</strong></h4><p>Firefox 于 2004 年 11 月首次发布，并且 9 个月内下载量超过 6000 万，获取了巨大的成功，IE 的主导地位首次受到了挑战。之后 Firefox 浏览器一路奋起直追，逐渐蚕食 IE 市场份额，这引发了第二次浏览器战争。</p><p>第二次浏览器战争中，随着以 Firefox 和 Opera 为首的 W3C 阵营与 IE 对抗程度的加剧，浏览器碎片化问题越来越严重，不同的浏览器执行不同的标准，对于开发人员来说这是一个恶梦。</p><p>为了解决浏览器兼容性问题，Dojo、jQuery、YUI、ExtJS、MooTools 等前端 Framework 相继诞生。前端开发人员用这些 Framework 频繁发送 AJAX 请求到后台，在得到数据后，再用这些 Framework 更新 DOM 树。</p><p>其中，<strong>jQuery</strong> 独领风骚，几乎成了所有网站的标配。Dojo、YUI、ExtJS 等提供了很多组件，这使得开发复杂的企业级 Web 应用成为可能。</p><h4 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a><strong>HTML 5</strong></h4><p>1999年，W3C发布了 HTML 4.01 版本，在之后的几年，没有再发布更新的 Web 标准。随着Web的迅猛发展，旧的Web标准已不能满足 Web 应用的快速增长。</p><p>2004 年 6 月，Mozilla 基金会和 Opera 软件公司在万维网联盟（W3C）所主办的研讨会上提出了一份联合建议书，其中包括 Web Forms 2.0 的初步规范草案。建议举行一次投票，以表决 W3C 是否应该扩展 HTML 和 DOM，从而满足 Web 应用中的新需求。研讨会最后以 8 票赞成，14 票反对否决此建议，这引起一些人的不满，不久后，部分浏览器厂商宣布成立网页超文本技术工作小组（WHATWG），以继续推动该规范的开发工作，该组织再度提出 Web Applications 1.0 规范草案，后来这两种规范合并形成 <strong>HTML5</strong>。2007 年，获得 W3C 接纳，并成立了新的 HTML 工作团队。2008 年 1 月 22 日，第一份正式草案发布。</p><ul><li>2008.12 <strong>Chrome</strong> 发布，JavaScript 引擎 V8。</li></ul><p>HTML5 草案发布不久，Google 在 2008 年 12 月发布了 Chrome 浏览器，加入了第二次浏览器大战当中。Chrome 使用了 Safari 开源的 WebKit 作为布局引擎，并且研发了高效的 JavaScript 引擎 V8。</p><p>在第二次浏览器大战中，各个浏览器厂商都以提升 JavaScript 运行效率和支持 HTML5 各种新特性为主要目标，促进了浏览器的良性竞争。在这一场战争中，Chrome 攻城略地，抢夺 IE 市场份额。2013 年，Chrome 超过 IE，成为市场份额最高的浏览器。2016 年，Chrome 占据了浏览器市场的半壁江山。</p><p>自 2008 年以来，浏览器中不断支持的 HTML5 新特性让开发者激动不已：WebWorker 可以让 JavaScript 运行在多线程中，WebSocket 可以实现前端与后台的双工通信，WebGL 可以创建 Web3D 网页游戏…</p><ul><li>2012.10 微软发布 <strong>TypeScript</strong> 公开版</li></ul><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作。TypeScript 是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</p><ul><li>2013.6.19 TypeScript 0.9 正式版</li><li>2014.10.28 W3C 正式发布 <strong>HTML 5.0</strong> 推荐标准</li></ul><h4 id="Node-js-的爆发"><a href="#Node-js-的爆发" class="headerlink" title="Node.js 的爆发"></a><strong>Node.js 的爆发</strong></h4><p>2008 年 Chrome 发布，其 JavaScript 引擎 V8 的高效执行引起了 Ryan Dahl 的注意。2009 年，Ryan 利用 Chrome 的 V8 引擎打造了基于<strong>事件循环的异步 I/O 框架</strong> —— <strong>Node.js</strong> 诞生。</p><p>Node.js 具有以下特点：</p><ul><li>基于事件循环的异步 I/O 框架，能够提高 I/O 吞吐量</li><li>单线程运行，能够避免了多线程变量同步的问题</li><li>使得 JavaScript 可以编写后台代码，前后端编程语言统一。</li><li>Node.js 的出现吸引了很多前端开发人员开始用 JavaScript 开发服务器代码，其异步编程风格也深受开发人员的喜爱。Node.js 的伟大不仅在于拓展了 JavaScript 在服务器端的无限可能，更重要的是它构建了一个庞大的生态系统。</li></ul><p>2010 年 1 月，<strong>NPM</strong> 作为 Node.js 的包管理系统首次发布。开发人员可以按照 CommonJS 的规范编写 Node.js 模块，然后将其发布到 NPM 上面供其他开发人员使用。目前 NPM 具有 40 万左右的模块，是世界上最大的包模块管理系统。</p><h4 id="前端-MV-架构"><a href="#前端-MV-架构" class="headerlink" title="*前端 MV 架构**"></a>*<em>前端 MV</em> 架构**</h4><p>随着 HTML5 的流行，前端不再是人们眼中的小玩意，以前在 C/S 中实现的桌面软件的功能逐步迁移到了前端，前端的代码逻辑逐渐变得复杂起来。</p><p>以前只用于后台的 MV* 等架构在前端逐渐使用起来，以下列举了部分常用的 MV* 框架。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/20180413121849687" alt="这里写图片描述"></p><p>随着这些 MV* 框架的出现，网页逐渐由 Web Site 演变成了 Web App，最终导致了复杂的单页应用（ Single Page Application）的出现。</p><h4 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a><strong>ECMAScript 6</strong></h4><p>1997 年 6 月， ECMAScript 1.0 标准发布。</p><p>1998 年 6 月，ECMAScript 2.0 发布。</p><p>1999 年 12 月，ECMAScript 3.0 发布。</p><p>2007 年 10 月，Mozilla 主张的 ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，该草案遭到了以 Yahoo、Microsoft、Google 为首的大公司的强烈反对，JavaScript 语言的创造者 Brendan Eich 和 IE 架构师 Chris Wilson 甚至在博客上就ES4向后兼容性问题打起了口水仗，最后由于各方分歧太大，ECMA 开会决定废弃中止 ECMAScript 4.0 草案。经各方妥协，在保证向下兼容的情况下，将部分增强的功能放到 ECMAScript 3.1 标准中，将原有 ECMAScript 4.0 草案中激进的功能放到以后的标准中。不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p><p>2009 年 12 月，本着’Don’t break the web’原则，<strong>ECMAScript 5</strong> 发布。新增了 strict 模式、属性 getter 和 setter 等。</p><p>2011 年 6 月，ECMAScript 5.1 发布。</p><p>2015 年 6 月，<strong>ECMAScript 6.0</strong> 发布。该版本增加了许多新的语法，包括支持 let、const、Arrow function、Class、Module、Promise、Iterator、Generator、Set、Map、async、Symbol、Proxy、Reflect、Decorator 等。TC39 委员会计划以后每年都发布一个新版本的 ECMAScript，所以 ECMAScript 6.0 改名为 ECMAScript 2015。</p><p>2016 年 6 月，在 ECMAScript 2015 的基础上进行了部分增强，发布了 ECMAScript 2016。</p><p>在 ECMAScript 的各个版本中，ECMAScript 6.0 无疑最受人瞩目的，它增加了许多新特性，极大拓展了 JavaScript 语法和能力，以至于许多浏览器都只能支持部分 ES6 中的新特性。随之，Babel 和 TypeScript 逐渐流行起来，编写 ES6 代码，然后用 Babel 或 TypeScript 将其编译为 ES5 等浏览器支持的 JavaScript。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考引用了 <a href="https://blog.csdn.net/freekiteyu/article/details/79927047">前端发展简史</a> 以及 <a href="https://zh.wikipedia.org/wiki">维基百科</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;​    无论是在生产或者学习中，我们后端开发人员（以下简称为后端仔），总是离不开和前端打交道，甚至在某些迫不得已的时候，我们也需要挺身而出</summary>
      
    
    
    
    <category term="后端仔写前端系列" scheme="http://zhoushing.github.io/categories/%E5%90%8E%E7%AB%AF%E4%BB%94%E5%86%99%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</id>
    <published>2021-11-21T09:11:43.000Z</published>
    <updated>2021-11-21T09:18:34.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-236-二叉树的最近公共祖先"><a href="#力扣-236-二叉树的最近公共祖先" class="headerlink" title="力扣 236. 二叉树的最近公共祖先"></a>力扣 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [2, 10^5] 内。</li><li>-10^9 &lt;= Node.val &lt;= 10^9</li><li>所有 Node.val 互不相同 。</li><li>p != q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以通过分别判断左支右支包含目标两个节点的情况来判断公共祖宗节点的位置</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前根节点等于其中一个节点，直接得出当前节点是最近公共祖先节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果两个节点都在左支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都在右支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121171647061.png" alt="image-20211121171647061"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#力扣-236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;力扣 236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html</id>
    <published>2021-11-21T09:05:22.000Z</published>
    <updated>2021-11-21T09:11:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-287-寻找重复数"><a href="#力扣-287-寻找重复数" class="headerlink" title="力扣 287. 寻找重复数"></a>力扣 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= n &lt;= 10^5</li><li>nums.length == n + 1</li><li>1 &lt;= nums[i] &lt;= n</li><li>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现题目要求的是至少出现一个，所以就不能使用位运算了，这里可以将这个数组看成循环数组，然后使用快慢指针求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将出现重复元素的数组看成环，用快慢指针来查找重复出现的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast || fast == <span class="number">0</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[slow];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121170916265.png" alt="image-20211121170916265"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-287-寻找重复数&quot;&gt;&lt;a href=&quot;#力扣-287-寻找重复数&quot; class=&quot;headerlink&quot; title=&quot;力扣 287. 寻找重复数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/find</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>最长和谐子序列</title>
    <link href="http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-11-20T09:35:00.000Z</published>
    <updated>2021-11-20T09:39:48.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-594-最长和谐子序列"><a href="#力扣-594-最长和谐子序列" class="headerlink" title="力扣 594. 最长和谐子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,5,2,3,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的和谐子序列是 [3,2,2,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现因为本题不要求是子数组，所以可以直接对元素进行统计</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个元素出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sub = map.getOrDefault(key - <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> add = map.getOrDefault(key + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加一减一的数都没出现过就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sub == -<span class="number">1</span> &amp;&amp; add == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, value + Math.max(sub, add));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211120173839981.png" alt="image-20211120173839981"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-594-最长和谐子序列&quot;&gt;&lt;a href=&quot;#力扣-594-最长和谐子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 594. 最长和谐子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashMap" scheme="http://zhoushing.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>单词拆分</title>
    <link href="http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html"/>
    <id>http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html</id>
    <published>2021-11-18T13:44:22.000Z</published>
    <updated>2021-11-18T14:04:32.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-139-单词拆分"><a href="#力扣-139-单词拆分" class="headerlink" title="力扣 139. 单词拆分"></a>力扣 <a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 300</li><li>1 &lt;= wordDict.length &lt;= 1000</li><li>1 &lt;= wordDict[i].length &lt;= 20</li><li>s 和 wordDict[i] 仅有小写英文字母组成</li><li>wordDict 中的所有字符串 互不相同</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>需要注意题目中要求源字符串的匹配方式，在这里我们采取向后遍历所有字符串可能的方式，采用动态规划向后记录的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 代表空串都是匹配的</span></span><br><span class="line">        ticks[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接逐长度匹配字典，通过动态规划来向后传递组合的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticks[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    ticks[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ticks[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211118214949077.png" alt="image-20211118214949077"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-139-单词拆分&quot;&gt;&lt;a href=&quot;#力扣-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;力扣 139. 单词拆分&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/word-br</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长连续序列</title>
    <link href="http://zhoushing.github.io/2021-11-17-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-11-17-%E6%9C%80%E9%95%BF%E8%BF%9E%E7%BB%AD%E5%BA%8F%E5%88%97.html</id>
    <published>2021-11-17T08:40:42.000Z</published>
    <updated>2021-11-17T08:44:04.045Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-128-最长连续序列"><a href="#力扣-128-最长连续序列" class="headerlink" title="力扣 128. 最长连续序列"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。</p><p>请你设计并实现时间复杂度为 O(n) 的算法解决此问题。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [100,4,200,1,3,2]</span><br><span class="line">输出：4</span><br><span class="line">解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>使用了HashSet来存储数组中数，利用他的contains方法来判断当前元素是否有后继</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * 向后延展</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">longestConsecutive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 其一是利用set的contains方法，也可以避免出现重复数值</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">            set.add(num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : set) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!set.contains(num - <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">int</span> currentNum = num;</span><br><span class="line">                <span class="keyword">int</span> currentLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 向后延展寻找是否有后继</span></span><br><span class="line">                <span class="keyword">while</span> (set.contains(currentNum + <span class="number">1</span>)) &#123;</span><br><span class="line">                    currentNum += <span class="number">1</span>;</span><br><span class="line">                    currentLen += <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                result = Math.max(result, currentLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211117164251562.png" alt="image-20211117164251562"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-128-最长连续序列&quot;&gt;&lt;a href=&quot;#力扣-128-最长连续序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 128. 最长连续序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/l</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashSet" scheme="http://zhoushing.github.io/tags/HashSet/"/>
    
  </entry>
  
  <entry>
    <title>最大单词长度乘积</title>
    <link href="http://zhoushing.github.io/2021-11-17-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.html"/>
    <id>http://zhoushing.github.io/2021-11-17-%E6%9C%80%E5%A4%A7%E5%8D%95%E8%AF%8D%E9%95%BF%E5%BA%A6%E4%B9%98%E7%A7%AF.html</id>
    <published>2021-11-17T07:44:11.000Z</published>
    <updated>2021-11-17T07:52:08.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-318-最大单词长度乘积"><a href="#力扣-318-最大单词长度乘积" class="headerlink" title="力扣 318. 最大单词长度乘积"></a>力扣 <a href="https://leetcode-cn.com/problems/maximum-product-of-word-lengths/">318. 最大单词长度乘积</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个字符串数组 <code>words</code>，找到 <code>length(word[i]) * length(word[j])</code> 的最大值，并且这两个单词不含有公共字母。你可以认为每个单词只包含小写字母。如果不存在这样的两个单词，返回 0。</p><p><strong>提示：</strong></p><ul><li><code>2 &lt;= words.length &lt;= 1000</code></li><li><code>1 &lt;= words[i].length &lt;= 1000</code></li><li><code>words[i]</code> 仅包含小写字母</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;abcw&quot;,&quot;baz&quot;,&quot;foo&quot;,&quot;bar&quot;,&quot;xtfn&quot;,&quot;abcdef&quot;]</span><br><span class="line">输出: 16 </span><br><span class="line">解释: 这两个单词为 &quot;abcw&quot;, &quot;xtfn&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;a&quot;,&quot;ab&quot;,&quot;abc&quot;,&quot;d&quot;,&quot;cd&quot;,&quot;bcd&quot;,&quot;abcd&quot;]</span><br><span class="line">输出: 4 </span><br><span class="line">解释: 这两个单词为 &quot;ab&quot;, &quot;cd&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;a&quot;,&quot;aa&quot;,&quot;aaa&quot;,&quot;aaaa&quot;]</span><br><span class="line">输出: 0 </span><br><span class="line">解释: 不存在这样的两个单词。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>一开始就打算使用数组字母表来记录字符，后来发现题目中约束为小写字母，所以我们可以用二进制位数来代表字符串中对应的字符是否出现，再通过对应的记录数想与来判断两个字符串是否有重复字符</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 位运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(String[] words)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = words.length;</span><br><span class="line">        <span class="keyword">int</span>[] hash = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 遍历每个字符，用对应的二进制位来代表这个字母是否出现</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> c : words[i].toCharArray()) &#123;</span><br><span class="line">                hash[i] |= <span class="number">1</span> &lt;&lt; (c - <span class="string">&#x27;a&#x27;</span>); </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">// 当两个数相遇等于0，代表这两个字符串没有字符相交</span></span><br><span class="line">                <span class="keyword">if</span> ((hash[i] &amp; hash[j]) == <span class="number">0</span>) &#123;</span><br><span class="line">                    max = Math.max(words[i].length() * words[j].length(), max);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211117154720696.png" alt="image-20211117154720696"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-318-最大单词长度乘积&quot;&gt;&lt;a href=&quot;#力扣-318-最大单词长度乘积&quot; class=&quot;headerlink&quot; title=&quot;力扣 318. 最大单词长度乘积&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="位运算" scheme="http://zhoushing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二叉树展开为链表</title>
    <link href="http://zhoushing.github.io/2021-11-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-11-16-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%95%E5%BC%80%E4%B8%BA%E9%93%BE%E8%A1%A8.html</id>
    <published>2021-11-16T07:03:19.000Z</published>
    <updated>2021-11-16T07:40:01.379Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-114-二叉树展开为链表"><a href="#力扣-114-二叉树展开为链表" class="headerlink" title="力扣 114. 二叉树展开为链表"></a>力扣 <a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你二叉树的根结点 root ，请你将它展开为一个单链表：</p><p>展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null 。<br>展开后的单链表应该与二叉树 先序遍历 顺序相同。</p><p><strong>提示：</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/flaten.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,5,3,4,null,6]</span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [0]</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现本题可以采用回溯的思想，前序遍历的顺序是根左右，所以我们选择按照最右、最左、根的顺序倒序回溯操作</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尾指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeNode last = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatten</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 预先操作最右节点</span></span><br><span class="line">        flatten(root.right);</span><br><span class="line">        flatten(root.left);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 按照右 左 根的顺序倒序操作，以尾指针标记最后操作节点</span></span><br><span class="line">        root.right = last;</span><br><span class="line">        root.left = <span class="keyword">null</span>;</span><br><span class="line">        last = root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211116152058590.png" alt="image-20211116152058590"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-114-二叉树展开为链表&quot;&gt;&lt;a href=&quot;#力扣-114-二叉树展开为链表&quot; class=&quot;headerlink&quot; title=&quot;力扣 114. 二叉树展开为链表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>完美矩形</title>
    <link href="http://zhoushing.github.io/2021-11-16-%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2.html"/>
    <id>http://zhoushing.github.io/2021-11-16-%E5%AE%8C%E7%BE%8E%E7%9F%A9%E5%BD%A2.html</id>
    <published>2021-11-16T01:15:06.000Z</published>
    <updated>2021-11-16T07:40:39.078Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-391-完美矩形"><a href="#力扣-391-完美矩形" class="headerlink" title="力扣 391. 完美矩形"></a>力扣 <a href="https://leetcode-cn.com/problems/perfect-rectangle/">391. 完美矩形</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个数组 rectangles ，其中 rectangles[i] = [xi, yi, ai, bi] 表示一个坐标轴平行的矩形。这个矩形的左下顶点是 (xi, yi) ，右上顶点是 (ai, bi) 。</p><p>如果所有矩形一起精确覆盖了某个矩形区域，则返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= rectangles.length &lt;= 2 * 10^4</li><li>rectangles[i].length == 4</li><li>-10^5 &lt;= xi, yi, ai, bi &lt;= 10^5</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perectrec1-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：5 个矩形一起可以精确地覆盖一个矩形区域。 </span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfectrec2-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,2,3],[1,3,2,4],[3,1,4,2],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：两个矩形之间有间隔，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfectrec3-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[3,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：图形顶端留有空缺，无法覆盖成一个矩形。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/perfecrrec4-plane.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：rectangles = [[1,1,3,3],[3,1,4,2],[1,3,2,4],[2,2,4,4]]</span><br><span class="line">输出：false</span><br><span class="line">解释：因为中间有相交区域，虽然形成了矩形，但不是精确覆盖。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为困难题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现在判断时，完美矩形的点中，除了外圈顶点之外其他点都是成对存在，而且所有小矩形的总面积等于外圈大矩形的面积</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRectangleCover</span><span class="params">(<span class="keyword">int</span>[][] rectangles)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> right = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> top = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">int</span> bottom = Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> n = rectangles.length;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> sumArea = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> tempLeft = rectangles[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tempBottom = rectangles[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> tempRight = rectangles[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> tempTop = rectangles[i][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 标记最外圈的顶点，完美矩形的顶点总应该在最外圈</span></span><br><span class="line">            left = Math.min(left, tempLeft);</span><br><span class="line">            bottom = Math.min(bottom, tempBottom);</span><br><span class="line">            right = Math.max(right, tempRight);</span><br><span class="line">            top = Math.max(top, tempTop);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累计每个小矩形的面积</span></span><br><span class="line">            sumArea += (tempTop - tempBottom) * (tempRight - tempLeft);</span><br><span class="line"></span><br><span class="line">            String lt = tempLeft + <span class="string">&quot;_&quot;</span> + tempTop;</span><br><span class="line">            String lb = tempLeft + <span class="string">&quot;_&quot;</span> + tempBottom;</span><br><span class="line">            String rt = tempRight + <span class="string">&quot;_&quot;</span> + tempTop;</span><br><span class="line">            String rb = tempRight + <span class="string">&quot;_&quot;</span> + tempBottom;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录每个点，完美矩形除了外圈四个顶点外，其他点应该是成对出现的</span></span><br><span class="line">            handlePoint(set, lt);</span><br><span class="line">            handlePoint(set, lb);</span><br><span class="line">            handlePoint(set, rt);</span><br><span class="line">            handlePoint(set, rb);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当且仅当set集合只剩下四个顶点，而且刚好是最外圈的四个点时</span></span><br><span class="line">        <span class="keyword">if</span> (set.size() == <span class="number">4</span> &amp;&amp; </span><br><span class="line">                set.contains(left + <span class="string">&quot;_&quot;</span> + top) &amp;&amp; set.contains(left + <span class="string">&quot;_&quot;</span> + bottom) &amp;&amp;</span><br><span class="line">                set.contains(right + <span class="string">&quot;_&quot;</span> + bottom) &amp;&amp; set.contains(right + <span class="string">&quot;_&quot;</span> + top)) &#123;</span><br><span class="line">            <span class="comment">// 而且所有小矩形的面积和等于外圈大矩形的面积时</span></span><br><span class="line">            <span class="keyword">return</span> sumArea == (right - left) * (top - bottom);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 操作点，保存不重复点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePoint</span><span class="params">(HashSet&lt;String&gt; set, String point)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!set.contains(point)) &#123;</span><br><span class="line">            set.add(point);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            set.remove(point);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211116091941567.png" alt="image-20211116091941567"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为困难，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-391-完美矩形&quot;&gt;&lt;a href=&quot;#力扣-391-完美矩形&quot; class=&quot;headerlink&quot; title=&quot;力扣 391. 完美矩形&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/perfect</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>从前序与中序遍历序列构造二叉树</title>
    <link href="http://zhoushing.github.io/2021-11-15-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-11-15-%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91.html</id>
    <published>2021-11-15T07:44:22.000Z</published>
    <updated>2021-11-15T07:50:33.540Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-105-从前序与中序遍历序列构造二叉树"><a href="#力扣-105-从前序与中序遍历序列构造二叉树" class="headerlink" title="力扣 105. 从前序与中序遍历序列构造二叉树"></a>力扣 <a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一棵树的前序遍历 <code>preorder</code> 与中序遍历 <code>inorder</code>。请构造二叉树并返回其根节点。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= preorder.length &lt;= 3000</li><li>inorder.length == preorder.length</li><li>-3000 &lt;= preorder[i], inorder[i] &lt;= 3000</li><li>preorder 和 inorder 均无重复元素</li><li>inorder 均出现在 preorder</li><li>preorder 保证为二叉树的前序遍历序列</li><li>inorder 保证为二叉树的中序遍历序列</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [-1], inorder = [-1]</span><br><span class="line">Output: [-1]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要分治构建节点以及左右子树即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二叉树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildTree</span><span class="params">(<span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = preorder.length;</span><br><span class="line"></span><br><span class="line">        TreeNode result = buildNode(<span class="number">0</span>, n, <span class="number">0</span>, n, preorder, inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preLeft  前序左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preRight 前序右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inLeft   中序左边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inRight  中序右边界</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> preorder 前序序列</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> inorder  中序序列</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">buildNode</span><span class="params">(<span class="keyword">int</span> preLeft, <span class="keyword">int</span> preRight, <span class="keyword">int</span> inLeft, <span class="keyword">int</span> inRight, <span class="keyword">int</span>[] preorder, <span class="keyword">int</span>[] inorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 左右区间重合，无节点</span></span><br><span class="line">        <span class="keyword">if</span> (preLeft == preRight) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前根节点</span></span><br><span class="line">        <span class="keyword">int</span> now = preorder[preLeft];</span><br><span class="line">        TreeNode result = <span class="keyword">new</span> TreeNode(now);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算左子树的节点个数</span></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = inLeft; i &lt; inRight; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (inorder[i] == now) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tick++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分别构建左右节点</span></span><br><span class="line">        result.left = buildNode(preLeft + <span class="number">1</span>, preLeft + tick + <span class="number">1</span>, inLeft, inLeft + tick, preorder, inorder);</span><br><span class="line">        result.right = buildNode(preLeft + tick + <span class="number">1</span>, preRight, inLeft + tick + <span class="number">1</span>, inRight, preorder, inorder);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211115154932442.png" alt="image-20211115154932442"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-105-从前序与中序遍历序列构造二叉树&quot;&gt;&lt;a href=&quot;#力扣-105-从前序与中序遍历序列构造二叉树&quot; class=&quot;headerlink&quot; title=&quot;力扣 105. 从前序与中序遍历序列构造二叉树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https:/</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>灯泡开关</title>
    <link href="http://zhoushing.github.io/2021-11-15-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3.html"/>
    <id>http://zhoushing.github.io/2021-11-15-%E7%81%AF%E6%B3%A1%E5%BC%80%E5%85%B3.html</id>
    <published>2021-11-15T02:08:36.000Z</published>
    <updated>2021-11-15T02:15:57.376Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-319-灯泡开关"><a href="#力扣-319-灯泡开关" class="headerlink" title="力扣 319. 灯泡开关"></a>力扣 <a href="https://leetcode-cn.com/problems/bulb-switcher/">319. 灯泡开关</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>初始时有 n 个灯泡处于关闭状态。第一轮，你将会打开所有灯泡。接下来的第二轮，你将会每两个灯泡关闭一个。</p><p>第三轮，你每三个灯泡就切换一个灯泡的开关（即，打开变关闭，关闭变打开）。第 i 轮，你每 i 个灯泡就切换一个灯泡的开关。直到第 n 轮，你只需要切换最后一个灯泡的开关。</p><p>找出并返回 n 轮后有多少个亮着的灯泡。</p><p><strong>提示：</strong></p><ul><li><code>0 &lt;= n &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/bulb.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：1 </span><br><span class="line">解释：</span><br><span class="line">初始时, 灯泡状态 [关闭, 关闭, 关闭].</span><br><span class="line">第一轮后, 灯泡状态 [开启, 开启, 开启].</span><br><span class="line">第二轮后, 灯泡状态 [开启, 关闭, 开启].</span><br><span class="line">第三轮后, 灯泡状态 [开启, 关闭, 关闭]. </span><br><span class="line"></span><br><span class="line">你应该返回 1，因为只有一个灯泡还亮着。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 0</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道脑筋急转弯算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题明白原理后就豁然开朗了，我们可以看到题目n的范围是9次幂级的，所以平常的解决办法通常是不行的，我们可以仔细阅读题目再写几组数字，仔细想一下规律</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数学</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bulbSwitch</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/** </span></span><br><span class="line"><span class="comment">         * 第i个灯泡的反转次数等于它所有因子（包括1和i）的个数，</span></span><br><span class="line"><span class="comment">         * 一开始所有的灯泡都是灭的，只有当他反转奇数次才会变成亮，</span></span><br><span class="line"><span class="comment">         * 所以只有因子总个数为奇数的序号的灯泡才会亮，而且只有平方数的因子数为奇数</span></span><br><span class="line"><span class="comment">         * （比如6=1*6,2*3，它们的因子总是成对出现的，而4=1*4,2*2，平方数的平方根因子会出现1次），</span></span><br><span class="line"><span class="comment">         * 所以最终答案等于n以内（包括n和1）的平方数总数量，所以只需要计算sqrt(n)即可</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) Math.sqrt(n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211115101227712.png" alt="image-20211115101227712"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-319-灯泡开关&quot;&gt;&lt;a href=&quot;#力扣-319-灯泡开关&quot; class=&quot;headerlink&quot; title=&quot;力扣 319. 灯泡开关&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/bulb-sw</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>MySQL入门</title>
    <link href="http://zhoushing.github.io/2021-10-13-MySQL%E5%85%A5%E9%97%A8.html"/>
    <id>http://zhoushing.github.io/2021-10-13-MySQL%E5%85%A5%E9%97%A8.html</id>
    <published>2021-10-13T02:16:09.000Z</published>
    <updated>2021-12-05T15:32:53.924Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>上篇文章中我们简单介绍了数据库以及 MySQL 的介绍及安装，本篇文章我们主要要介绍一下 MySQL 的相关规则和语法。</p><h2 id="使用-MySQL"><a href="#使用-MySQL" class="headerlink" title="使用 MySQL"></a>使用 MySQL</h2><h3 id="连接DBMS"><a href="#连接DBMS" class="headerlink" title="连接DBMS"></a>连接DBMS</h3><p>​    MySQL与所有客户机-服务器DBMS一样，要求执行命令之前登录到DBMS。MySQL在内部保存自己的用户列表，并且把每个用户与各种权限关联起来。</p><p>​    在上篇文章安装MySQL过程中，我们的账号为<code>root</code>，密码为<code>123456</code>。在自己本地使用时，可以这样简单设置一下。但是在现实生产或者工作时，管理登录受到密切保护（因为对它的访问授予了创建表、<strong>删除整个数据库</strong>、更改登录和口令等完全的操作）。</p><p>在连接MySQL时，需要以下信息：</p><ul><li>主机名（计算机名）——如果连接到本地MySQL服务器，为Localhost；</li><li>端口（如果使用默认端口3306之外的端口）；</li><li>一个合法的用户名；</li><li>用户口令（也就是密码）。</li></ul><p>例如在SQLyog中登录：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211013105422565.png" alt="image-20211013105422565"></p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>​    在你最初连接到MySQL时，没有数据库打开供你使用。在你能执行任何数据库操作之前，需要选择一个数据库。为此，我们可以使用<code>USE</code>关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">USE 表名</span><br><span class="line"># 将当前数据库转到目的数据库，一般的mysql可视化程序都会输入一句“Database changed”</span><br></pre></td></tr></table></figure><p>​    记住，要先使用<code>USE</code>打开指定数据库，才能读取其中的数据并操作。</p><blockquote><p>小Tip：在Windows系统上MySQL关键字一般不区分大小写（linux上就会区分，Windows上可以设置区分），所以上述例子中使用USE和use甚至是其他的组合都可以，不过MySQL语句规范: </p><p>   1: 关键字与函数名称全部大写;</p><p>   2: 数据库名称,表名称,字段名称全部小写;</p><p>所以在给数据库或者表等起名时，推荐使用下划线划分的形式，例如 person_table 。</p></blockquote><h3 id="了解数据库和表"><a href="#了解数据库和表" class="headerlink" title="了解数据库和表"></a>了解数据库和表</h3><p>​    在建立数据库之后或者打开一个别人创建的数据库时，而且我们不知道或者忘记可以使用的数据库名怎么办？</p><p>​    数据库、表、列、用户、权限等的信息被存储在数据库和表中。不过，内部的表一般不直接访问。可用的MySQL的<code>SHOW</code>命令来显示这些信息（由MySQL来负责将这些信息提取出来）。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> DATABASES;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="operator">|</span> Database           <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="operator">|</span> information_schema <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> mysql              <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> performance_schema <span class="operator">|</span>                                                              </span><br><span class="line"><span class="operator">|</span> school             <span class="operator">|</span>                                                          </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+                                                              </span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)    </span><br></pre></td></tr></table></figure><p>​    上面展示的就是<code>SHOW DATABASES</code>命令的效果，返回可用数据库的一个列表。需要注意的是，<strong>MySQL用<code>;</code>来标志着一条命令的结束，当读者在运行sql语句没反应时，不妨检查下是不是缺少<code>;</code>的原因。</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> USE SCHOOL;                                                                  </span><br><span class="line">Database changed                                                                    </span><br><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> TABLES;                                                                 </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="operator">|</span> Tables_in_school <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="operator">|</span> normaluser       <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">|</span> student          <span class="operator">|</span>                                                                </span><br><span class="line"><span class="operator">+</span><span class="comment">------------------+                                                                </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    上面展示的就是<code>SHOW TABLES</code>命令的效果，返回可用数据库的一个列表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SHOW</span> COLUMNS <span class="keyword">FROM</span> student;                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="operator">|</span> Field    <span class="operator">|</span> Type            <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Key <span class="operator">|</span> <span class="keyword">Default</span>      <span class="operator">|</span> Extra <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="operator">|</span> Sno      <span class="operator">|</span> <span class="type">int</span>(<span class="number">11</span>)         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span> PRI <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> pwd      <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">20</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> Sname    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">30</span>)     <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> sex      <span class="operator">|</span> <span class="type">char</span>(<span class="number">2</span>)         <span class="operator">|</span> <span class="keyword">NO</span>   <span class="operator">|</span>     <span class="operator">|</span> 男           <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> grade    <span class="operator">|</span> <span class="type">int</span>(<span class="number">4</span>) unsigned <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> phone    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> address  <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">255</span>)    <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> 地址不详      <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> birthday <span class="operator">|</span> datetime        <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> email    <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">50</span>)     <span class="operator">|</span> YES  <span class="operator">|</span>     <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">|</span> idCard   <span class="operator">|</span> <span class="type">varchar</span>(<span class="number">18</span>)     <span class="operator">|</span> YES  <span class="operator">|</span> UNI <span class="operator">|</span> <span class="keyword">NULL</span>         <span class="operator">|</span>       <span class="operator">|</span>                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----------+-----------------+------+-----+--------------+-------+                  </span></span><br><span class="line"><span class="number">10</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>​    <code>SHOW COLUMNS</code>要求给出一个表名（例如上面的<code>FROM student</code>），它对每个字段返回一行，行中包含字段名、数据类型、是否允许NULL、键信息、默认值以及其他信息（例如当字段自增时在<code>Extra</code>一栏会显示<code>auto_increment</code>）。</p><blockquote><p><strong>什么是 auto_increment ？</strong> auto_increment 也就是自动增量，某些表的列需要唯一值，例如，订单编号、雇员ID等。在每个行添加到表中时，MySQL可以自动地为每个行分配下一个可用编号，不用在添加一行时手动分配唯一值（这样做必须记住最后一次使用的值）。这个功能就是所谓的自动增量。如果需要它，则必须要在用CREATE语句创建表时把它作为表定义的组成部分，我们在后面会再提到。</p></blockquote><blockquote><p>小Tip：上述的 SHOW COLUMNS FROM student 可以替换成 DESCRIBE student；简而言之，DESCRIBE 是 SHOW COLUMNS FROM 的一种简写，其实还可以写成 DESC（偷懒Plus）。</p></blockquote><p>其他所支持的SHOW命令还有：</p><ul><li>SHOW STATUS，用于显示广泛的服务器状态信息；</li><li>SHOW CREATE DATABASE 和 SHOW CREATE TABLE，分别用来显示创建特定数据库或表的MySQL语句；</li><li>SHOW GRANTS，用来显示授予用户（所有用户或特定用户）的安全权限；</li><li>SHOW ERRORS 和 SHOW WARNINGS，用来显示服务器错误或警告信息。</li></ul><h3 id="检索数据"><a href="#检索数据" class="headerlink" title="检索数据"></a>检索数据</h3><h4 id="检索列"><a href="#检索列" class="headerlink" title="检索列"></a>检索列</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser;                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>​    上述语句利用SELECT语句从normaluser表中检索出了所有列（<code>*</code>指代所有字段），等同于 <code>SELECT user_account, user_password, money FROM normaluser</code>。所需的的列名在SELECT关键字之后给出，FROM关键字指出从其中检索数据的表名。</p><blockquote><p>小Tip：在SQLyog中操作时，可以通过操作图形化界面的方式创建数据库、表以及添加数据，可以参考这篇博文：<a href="https://blog.csdn.net/su2231595742/article/details/107967198">SQLyog使用教程</a>。命令行创建的方式之后才会讲解。</p></blockquote><h4 id="检索不同行"><a href="#检索不同行" class="headerlink" title="检索不同行"></a>检索不同行</h4><p>当我们想知道用户的常用密码是什么时，我们可以对密码进行查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SELECT user_password FROM normaluser;                                        </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">| user_password |                                                                   </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">| 123456        |                                                                   </span><br><span class="line">| 123456        |                                                                   </span><br><span class="line">| 654321        |                                                                   </span><br><span class="line">+---------------+                                                                   </span><br><span class="line">3 rows in set (0.00 sec) </span><br></pre></td></tr></table></figure><p>​    这时候我们发现出现了重复的数据，当我们不想结果出现重复数据时，我们可以使用<code>DISTINCT</code>关键字，顾名思义，这个关键字将结果进行筛选，最后只剩下结果不同的列表，例如下面的效果：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> user_password <span class="keyword">FROM</span> normaluser;                              </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> user_password <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="number">2</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure><blockquote><p>小Tip：不能部分使用DISTINCT，DISTINCT会作用于目标的所有列而不仅是前置他的列。比如给出 <code>SELECT DISTINCT user_account, user_password FROM normaluser </code>时，就要求除非账号和密码都相同，否则就会被检索出来。</p></blockquote><h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p><code>SELECT</code>语句返回所有匹配的行，它们可能是指定表中的所有行。为了返回指定条数的数据，可以使用<code>LIMIT</code>关键字。例子如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser LIMIT <span class="number">3</span>;                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    上述语句使用<code>SELECT</code>语句检索了所有列。<code>LIMIT 3</code>指示MySQL返回<strong>不多于</strong>3行。当我们想知道某一行开始的后三行时，我们可以指定要检索的开始行和行数，如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser LIMIT <span class="number">2</span>, <span class="number">3</span>;                                         </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> zhangsi      <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> liwu         <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   </span><br></pre></td></tr></table></figure><p><code>LIMIT 2, 3</code>表示返回第二行以及后面的两行，也就是从第二行开始到第四行。第一个数表示开始位置，第二个数表示要返回的行数。</p><blockquote><p><strong>行 0</strong> 可能有读者奇怪上述例子中为什么第三行数据却是第二行，因为数据表中的第一行是行0而不是行1。因此，LIMIT 1, 1检索出来的是第二行数据而不是第一行数据。</p></blockquote><blockquote><p><strong>当行数不够时</strong> LIMIT中指定要检索出的数据为检索的最大行数。如果没有足够的行时，MySQL将只会返回他能返回的那么多行。</p></blockquote><blockquote><p><strong>MySQL 5 中的 LIMIT 语法</strong> 从MySQL 5 开始出现一种LIMIT的另一种替代语法。<code>LIMIT 4 OFFSET 3</code> 意思是从行3开始取四行，就像<code>LIMIT 3, 4</code> 一样。</p></blockquote><h4 id="使用完全限定的表名"><a href="#使用完全限定的表名" class="headerlink" title="使用完全限定的表名"></a>使用完全限定的表名</h4><p>​    到目前为止的例子中，我们只使用了列名来引用列。在某些情况下，我们也可以使用全限定的名字来引用列（同时使用表名和列名）。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> normaluser.user_password <span class="keyword">FROM</span> school.normaluser;                      </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> user_password <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>                                                                   </span><br><span class="line"><span class="operator">+</span><span class="comment">---------------+                                                                   </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><p>​    在这条语句中，我们将user_password限定为normaluser表中的user_password字段，normaluser限定为school数据库中的normaluser表，等价于<code>SELECT user_password FROM normaluser</code>，在之后某些场景需要使用完全限定名。现在需要注意一下这个语法，以便到时候知道它的作用。</p><h3 id="排序检索数据"><a href="#排序检索数据" class="headerlink" title="排序检索数据"></a>排序检索数据</h3><h4 id="排序数据"><a href="#排序数据" class="headerlink" title="排序数据"></a>排序数据</h4><p>​    在上面许多的操作时，我们可以看出检索的数据并没有什么严格的顺序。其实，检索出的数据并不是以纯粹的随机顺序显示的。如果不排序，数据一般将以它在底层表中出现的顺序显示。这可以是数据最初添加到表中的数据顺序。但是，如果数据后来进行过更新或者删除操作时，则此时将会受到MySQL重用回收存储空间的影响。因此，如果不明确控制的话，不能（也不应该）依赖排序顺序。<strong>在关系数据库设计理论中认为，如果不明确规定排序顺序，则不应该假定检索出的数据的顺序有意义。</strong></p><blockquote><p><strong>子句</strong> SQL语句由子句构成，有些子句是必需的，而有些是可选的。一个子句通常由一个关键字和所提供的数据组成。子句的例子有<code>SELECT</code>语句的<code>FROM</code>子句，我们在之前的例子中看到了这个子句的作用。</p></blockquote><p>​    当我们需要明确使用排序用<code>SELECT</code>语句检索出的数据，可以使用<code>ORDER BY</code>子句。<code>OEDER BY</code>子句取一个或者多个列的名字，据此对输出进行排序。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_account;                   </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)  </span><br></pre></td></tr></table></figure><p>​    可以看到上述操作将用户账号以字母顺序排序（默认是升序的）展示了表中的数据，如果想要降序输出，加上<code>DESC</code>关键字即可。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> user_account <span class="keyword">DESC</span>;              </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>                                                                    </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+                                                                    </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)  </span><br></pre></td></tr></table></figure><h4 id="按多个列进行排序"><a href="#按多个列进行排序" class="headerlink" title="按多个列进行排序"></a>按多个列进行排序</h4><p>​    在实际使用时，经常需要不止一个列进行数据排序，因为可能有些数据是相等的，所以就需要多个列进行排序。为了按多个列排序，只要指定列名，列名之间用逗号分开即可（就像选择多个列时所做的那样），例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> user_account, money <span class="keyword">FROM</span> normaluser <span class="keyword">ORDER</span> <span class="keyword">BY</span> money <span class="keyword">DESC</span>, user_account;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="operator">|</span> user_account <span class="operator">|</span> money <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="operator">|</span> liwu         <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> lisi         <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> wangliu      <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> wangwu       <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> zhangsan     <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">|</span> zhangsi      <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                                            </span><br><span class="line"><span class="operator">+</span><span class="comment">--------------+-------+                                                            </span></span><br><span class="line"><span class="number">6</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   </span><br></pre></td></tr></table></figure><p>​    上述例子中，我们将用户按照余额进行了降序排序，当所持金额相同时按照名字升序排列。这就是实现了对排序规则的排序。</p><blockquote><p><strong>在每个列上降序排序</strong> 如果想在多个列上进行降序排序，必须对每个列指定<code>DESC</code>关键字。</p></blockquote><blockquote><p>小Tip：有细心的读者可能发现了，在前面还出现过一次<code>DESC</code>关键字</p><p>DESC table_name；</p><p>PS：此处desc是describe的缩写，用法： desc 表名/查询语句 </p><p>SELECT user_account FROM normaluser ORDER BY user_account DESC;        </p><p>PS：此处desc是descend的缩写， 用法：select * from 表 order by 字段 desc</p></blockquote><blockquote><p><strong>ORDER BY子句的位置</strong> 在给出<code>ORDER BY</code>子句时，应该保证它位于<code>FROM</code>子句之后。如果使用<code>LIMIT</code>，它必须位于<code>ORDER BY</code>之后。使用子句的次序不当讲产生错误消息。关于子句的顺序，后面我们应该还会提到。</p></blockquote><h3 id="过滤数据"><a href="#过滤数据" class="headerlink" title="过滤数据"></a>过滤数据</h3><h4 id="使用-WHERE-子句"><a href="#使用-WHERE-子句" class="headerlink" title="使用 WHERE 子句"></a>使用 WHERE 子句</h4><p>​    数据库表中通常包含大量的数据，很少需要检索表中所有行。通常只会根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指定搜索条件（也叫过滤条件）。</p><p>​    在<code>SELECT</code>语句中，数据根据<code>WHERE</code>子句中指定的搜索条件进行过滤。<code>WHERE</code>子句在表名（<code>FROM</code>子句）之后给出，例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser <span class="keyword">WHERE</span> money <span class="operator">=</span> <span class="number">250</span>;                                  </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> wangliu      <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.02</span> sec)</span><br></pre></td></tr></table></figure><p>​    上面展示了一个简单的筛选：它检查一个列是否有指定的值，据此进行筛选。但是SQL支持的不仅仅是这样的简单筛选。</p><blockquote><p><strong>WHERE 子句的位置</strong> 在同时使用<code>ORDER BY</code>位于<code>WHERE</code>之后，否则将会产生错误。</p></blockquote><h4 id="WHERE-子句操作符"><a href="#WHERE-子句操作符" class="headerlink" title="WHERE 子句操作符"></a>WHERE 子句操作符</h4><table><thead><tr><th align="center">操作数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">=</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt;</td><td align="center">不等于</td></tr><tr><td align="center">!=</td><td align="center">不等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;=</td><td align="center">小于等于</td></tr><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;=</td><td align="center">大于等于</td></tr><tr><td align="center">BETWEEN</td><td align="center">在指定两个数之间</td></tr></tbody></table><h4 id="不匹配检查"><a href="#不匹配检查" class="headerlink" title="不匹配检查"></a>不匹配检查</h4><p>​    在上面的例子中，我们已经举例了匹配单个值得情况，以下例子例出所持金额不是250的用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser <span class="keyword">WHERE</span> money <span class="operator">&lt;&gt;</span> <span class="number">250</span>;                                 </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> zhangsan     <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">4</span> <span class="operator">|</span> zhangsi      <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">200</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> liwu         <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">3</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.01</span> sec)  </span><br></pre></td></tr></table></figure><blockquote><p><strong>何时使用引号</strong>  如果仔细观察许多 WHERE 子句中使用的条件，不难发现有些值被括在单引号内，而有些值未被括起来。单引号用来限定字符串。如果将值与串类型的列进行比较，则需要限定引号。用来与数值列进行比较的值不用引号。</p></blockquote><p>​    上面的例子同样可以使用 <code>!=</code> 而不是 <code>&lt;&gt;</code> 操作符；</p><h4 id="范围值查询"><a href="#范围值查询" class="headerlink" title="范围值查询"></a>范围值查询</h4><p>​    为了检查某个范围的值，可以使用 <code>BETWEEN</code> 操作符。其语法与其他 WHERE 子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。例如以下的例子，我们检索了所持金额在250到300的所有用户：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> normaluser <span class="keyword">WHERE</span> money <span class="keyword">between</span> <span class="number">250</span> <span class="keyword">and</span> <span class="number">300</span>;                    </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> user_account <span class="operator">|</span> user_password <span class="operator">|</span> money <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="operator">|</span>  <span class="number">2</span> <span class="operator">|</span> lisi         <span class="operator">|</span> <span class="number">123456</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">3</span> <span class="operator">|</span> wangwu       <span class="operator">|</span> <span class="number">654321</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">5</span> <span class="operator">|</span> liwu         <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">300</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">|</span>  <span class="number">6</span> <span class="operator">|</span> wangliu      <span class="operator">|</span> <span class="number">789012</span>        <span class="operator">|</span>   <span class="number">250</span> <span class="operator">|</span>                                       </span><br><span class="line"><span class="operator">+</span><span class="comment">----+--------------+---------------+-------+                                       </span></span><br><span class="line"><span class="number">4</span> <span class="keyword">rows</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)   </span><br></pre></td></tr></table></figure><h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><p>​    在创建表时，表设计人员可以指定其中的列是否可以不包含值。在一个列不包含值时，称其为包含空值NULL。</p><blockquote><p><strong>NULL</strong> 无值（no value），它与字段包含0、空字符串或仅仅包含空格不同。实际上，它们各不相同。</p></blockquote><p>​    SELECT语句有一个特殊的 WHERE 子句，用来检查具有 NULL 值的列。这个 WHERE 子句就是 <code>IS NULL</code> 子句。其语法如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> normaluser <span class="keyword">where</span> user_account  <span class="keyword">is</span> <span class="keyword">null</span>;             </span><br><span class="line"><span class="keyword">Empty</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec) </span><br></pre></td></tr></table></figure><p>​    这条语句返回了所有没有设置账号的用户的用户信息，由于表中没有这样的数据，所以没有返回数据。但是假如在数据录入没有录入数据而且表结构允许此字段出现空值时，则此列将包含 NULL 值。</p><blockquote><p><strong>NULL 与不匹配</strong> 在通过过滤出不具有特定值的行时，你可能希望返回具有 NULL 的行。但是，不行。因为未知具有特殊的含义，数据库不知道它们是否匹配，所以在匹配或不匹配过滤时不返回它们。</p><p>因此，在过滤数据时，一定要验证返回数据中确实给出了被过滤列具有 NULL 的行。</p></blockquote><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考《MySQL必知必会》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;上篇文章中我们简单介绍了数据库以及 MySQL 的介绍及安装，本篇文章我们主要要介绍一下 MySQL 的相关规则和语法。&lt;/p&gt;
&lt;h2 i</summary>
      
    
    
    
    <category term="MySQL系列" scheme="http://zhoushing.github.io/categories/MySQL%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="数据库" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://zhoushing.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="http://zhoushing.github.io/2021-10-11-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-10-11-%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</id>
    <published>2021-10-11T15:06:27.000Z</published>
    <updated>2021-10-11T15:10:37.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-96-不同的二叉搜索树"><a href="#力扣-96-不同的二叉搜索树" class="headerlink" title="力扣 96. 不同的二叉搜索树"></a>力扣 <a href="https://leetcode-cn.com/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道动态规划算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们只需要依次讨论 2 - n 个节点的可能即可，每个可能只需要讨论 左子树的可能和右子树可能的乘积 即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     * 左右划分</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] sums = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        sums[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            sums[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 排列组合</span></span><br><span class="line">                <span class="comment">// sums[j] 左子树的可能</span></span><br><span class="line">                <span class="comment">// sums[i - j - 1] 右子树的可能</span></span><br><span class="line">                sums[i] = sums[i] + sums[j] * sums[i - j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> sums[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211011230838760.png" alt="image-20211011230838760"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-96-不同的二叉搜索树&quot;&gt;&lt;a href=&quot;#力扣-96-不同的二叉搜索树&quot; class=&quot;headerlink&quot; title=&quot;力扣 96. 不同的二叉搜索树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>单词搜索</title>
    <link href="http://zhoushing.github.io/2021-10-11-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html"/>
    <id>http://zhoushing.github.io/2021-10-11-%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2.html</id>
    <published>2021-10-11T14:59:07.000Z</published>
    <updated>2021-10-11T15:06:06.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-79-单词搜索"><a href="#力扣-79-单词搜索" class="headerlink" title="力扣 79. 单词搜索"></a>力扣 <a href="https://leetcode-cn.com/problems/word-search/">79. 单词搜索</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个 m x n 二维字符网格 board 和一个字符串单词 word 。如果 word 存在于网格中，返回 true ；否则，返回 false 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>提示：</strong></p><ul><li>m == board.length</li><li>n = board[i].length</li><li>1 &lt;= m, n &lt;= 6</li><li>1 &lt;= word.length &lt;= 15</li><li>board 和 word 仅由大小写英文字母组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/word3.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCB&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现我们直接DFS进行判断即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转向</span></span><br><span class="line">    <span class="keyword">int</span>[] turnX = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span>[] turnY = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">(<span class="keyword">char</span>[][] board, String word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] words = word.toCharArray();</span><br><span class="line"></span><br><span class="line">        m = board.length;</span><br><span class="line">        n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == words[<span class="number">0</span>]) &#123;</span><br><span class="line">                    ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (dfs(board, words, <span class="number">1</span>, i, j, ticks)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    ticks[i][j] = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">char</span>[] words, <span class="keyword">int</span> now, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">boolean</span>[][] ticks)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 已经匹配完成</span></span><br><span class="line">        <span class="keyword">if</span> (now == words.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">            i += turnX[k]; j += turnY[k];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不符合要求排除</span></span><br><span class="line">            <span class="keyword">if</span> (!judge(i, j) &amp;&amp; !ticks[i][j] &amp;&amp; board[i][j] == words[now]) &#123;</span><br><span class="line">                ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                result |= dfs(board, words, now + <span class="number">1</span>, i, j, ticks);</span><br><span class="line">                ticks[i][j] = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i -= turnX[k]; j -= turnY[k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断下标是否越界</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || (i - m) * (j - n) &lt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211011230603362.png" alt="image-20211011230603362"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-79-单词搜索&quot;&gt;&lt;a href=&quot;#力扣-79-单词搜索&quot; class=&quot;headerlink&quot; title=&quot;力扣 79. 单词搜索&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/word-searc</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
