<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2021-07-20T01:41:17.225Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组中最大数对和的最小值</title>
    <link href="http://zhoushing.github.io/2021-07-20-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.html"/>
    <id>http://zhoushing.github.io/2021-07-20-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E6%95%B0%E5%AF%B9%E5%92%8C%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC.html</id>
    <published>2021-07-20T01:38:49.000Z</published>
    <updated>2021-07-20T01:41:17.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1877-数组中最大数对和的最小值"><a href="#力扣-1877-数组中最大数对和的最小值" class="headerlink" title="力扣 1877. 数组中最大数对和的最小值"></a>力扣 <a href="https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array/">1877. 数组中最大数对和的最小值</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>一个数对 <code>(a,b)</code> 的 <strong>数对和</strong> 等于 <code>a + b</code> 。<strong>最大数对和</strong> 是一个数对数组中最大的 <strong>数对和</strong> 。</p><ul><li>比方说，如果我们有数对 <code>(1,5)</code> ，<code>(2,3)</code> 和 <code>(4,4)</code>，<strong>最大数对和</strong> 为 <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code> 。</li></ul><p>给你一个长度为 <strong>偶数</strong> <code>n</code> 的数组 <code>nums</code> ，请你将 <code>nums</code> 中的元素分成 <code>n / 2</code> 个数对，使得：</p><ul><li><code>nums</code> 中每个元素 <strong>恰好</strong> 在 <strong>一个</strong> 数对中，且</li><li><strong>最大数对和</strong> 的值 <strong>最小</strong> 。</li></ul><p>请你在最优数对划分的方案下，返回最小的 <strong>最大数对和</strong> 。</p></li><li><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 10^5</code></li><li><code>n</code> 是 <strong>偶数</strong> 。</li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,5,2,3]</span><br><span class="line">输出：7</span><br><span class="line">解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。</span><br><span class="line">最大数对和为 max(3+3, 5+2) &#x3D; max(6, 7) &#x3D; 7 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,5,4,2,4,6]</span><br><span class="line">输出：8</span><br><span class="line">解释：数组中的元素可以分为数对 (3,5)，(4,4) 和 (6,2) 。</span><br><span class="line">最大数对和为 max(3+5, 4+4, 6+2) &#x3D; max(8, 8, 8) &#x3D; 8 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现本题比较简单，直接排序求解即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minPairSum</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 排序来保证大小元素分配均匀</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> maxCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            maxCount = Math.max(maxCount, nums[i] + nums[n - i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/20/RSXQL1kvZwHtsob.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1877-数组中最大数对和的最小值&quot;&gt;&lt;a href=&quot;#力扣-1877-数组中最大数对和的最小值&quot; class=&quot;headerlink&quot; title=&quot;力扣 1877. 数组中最大数对和的最小值&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetc</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>最高频元素的频数</title>
    <link href="http://zhoushing.github.io/2021-07-19-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-07-19-%E6%9C%80%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0%E7%9A%84%E9%A2%91%E6%95%B0.html</id>
    <published>2021-07-19T08:10:08.000Z</published>
    <updated>2021-07-19T08:14:14.145Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1838-最高频元素的频数"><a href="#力扣-1838-最高频元素的频数" class="headerlink" title="力扣 1838. 最高频元素的频数"></a>力扣 <a href="https://leetcode-cn.com/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p></li><li><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>1 &lt;= nums[i] &lt;= 10^5</code></li><li><code>1 &lt;= k &lt;= 10^5</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,4], k &#x3D; 5</span><br><span class="line">输出：3</span><br><span class="line">解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums &#x3D; [4,4,4] 。</span><br><span class="line">4 是数组中最高频元素，频数是 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,4,8,13], k &#x3D; 5</span><br><span class="line">输出：2</span><br><span class="line">解释：存在多种最优解决方案：</span><br><span class="line">- 对第一个元素执行 3 次递增操作，此时 nums &#x3D; [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。</span><br><span class="line">- 对第二个元素执行 4 次递增操作，此时 nums &#x3D; [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。</span><br><span class="line">- 对第三个元素执行 5 次递增操作，此时 nums &#x3D; [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [3,9,6], k &#x3D; 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>决定采用滑动窗口来求解，但时间空间效率欠优</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 滑动窗口</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 至少有一个数</span></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// LinkedList实现双向队列，模拟滑动窗口</span></span><br><span class="line">        Deque&lt;Integer&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将数组排序，保证在队列中的有序排列</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        stack.addLast(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">// 记录元素和，用long是为了防止溢出</span></span><br><span class="line">        <span class="keyword">long</span> sum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt; n; i++) &#123;</span><br><span class="line">            stack.addLast(nums[i]);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">// 如果当前队列内的元素不符合要求，就移除队首元素，直到满足为止</span></span><br><span class="line">            <span class="keyword">while</span> (sum + k &lt; nums[i] * stack.size()) &#123;</span><br><span class="line">                sum -= stack.removeFirst();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 记录符合题意的最大可能频数</span></span><br><span class="line">            result = Math.max(result, stack.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都一般，可见此解法勉强还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/19/62wmDckEMxYAT7B.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1838-最高频元素的频数&quot;&gt;&lt;a href=&quot;#力扣-1838-最高频元素的频数&quot; class=&quot;headerlink&quot; title=&quot;力扣 1838. 最高频元素的频数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="滑动窗口" scheme="http://zhoushing.github.io/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>变位词组</title>
    <link href="http://zhoushing.github.io/2021-07-18-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84.html"/>
    <id>http://zhoushing.github.io/2021-07-18-%E5%8F%98%E4%BD%8D%E8%AF%8D%E7%BB%84.html</id>
    <published>2021-07-18T02:26:12.000Z</published>
    <updated>2021-07-18T04:04:16.323Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-面试题-10-02-变位词组"><a href="#力扣-面试题-10-02-变位词组" class="headerlink" title="力扣 面试题 10.02. 变位词组"></a>力扣 <a href="https://leetcode-cn.com/problems/group-anagrams-lcci/">面试题 10.02. 变位词组</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>编写一种方法，对字符串数组进行排序，将所有变位词组合在一起。变位词是指字母相同，但排列不同的字符串。</p><p><strong>注意：</strong>本题相对原题稍作修改</p></li></ul><ul><li><p><strong>说明：</strong></p><ul><li>所有输入均为小写字母。</li><li>不考虑答案输出的顺序。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入: [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;],</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;],</span><br><span class="line">  [&quot;nat&quot;,&quot;tan&quot;],</span><br><span class="line">  [&quot;bat&quot;]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道哈希表算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题采用哈希表进行记录比较容易求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        HashMap&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 将字符串转化为字节数组进行排序</span></span><br><span class="line">            <span class="keyword">char</span>[] ch = strs[i].toCharArray();</span><br><span class="line">            Arrays.sort(ch);</span><br><span class="line">            String s = <span class="keyword">new</span> String(ch);</span><br><span class="line">            List&lt;String&gt; temp;</span><br><span class="line">            <span class="comment">// 排序之后对当前字符串进行HashMap记录</span></span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(s, <span class="keyword">null</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                temp = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = map.get(s);</span><br><span class="line">            &#125;</span><br><span class="line">            temp.add(strs[i]);</span><br><span class="line">            map.put(s, temp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// 取出所有变位词的记录</span></span><br><span class="line">        <span class="keyword">for</span>(List&lt;String&gt; list : map.values()) &#123;</span><br><span class="line">            result.add(list);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/18/Vsl6KpmO2ySWhPw.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-面试题-10-02-变位词组&quot;&gt;&lt;a href=&quot;#力扣-面试题-10-02-变位词组&quot; class=&quot;headerlink&quot; title=&quot;力扣 面试题 10.02. 变位词组&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>连续子数组的最大和</title>
    <link href="http://zhoushing.github.io/2021-07-17-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html"/>
    <id>http://zhoushing.github.io/2021-07-17-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C.html</id>
    <published>2021-07-17T00:35:26.000Z</published>
    <updated>2021-07-17T00:38:57.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-剑指-Offer-42-连续子数组的最大和"><a href="#力扣-剑指-Offer-42-连续子数组的最大和" class="headerlink" title="力扣 剑指 Offer 42. 连续子数组的最大和"></a>力扣 <a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>输入一个整型数组，数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。</p><p>要求时间复杂度为O(n)。</p></li></ul><ul><li><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>-100 &lt;= arr[i] &lt;= 100</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道动态规划算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题的动态规划里面好像带一点的贪心，用dp数组来模拟连接子串的过程，如果前面的子串的和大于0我就继续连接，否则我就重新开始子串连接</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 用dp数组来记录当前的连接串</span></span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = dp[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果前面的子串和大于零，说明前面的子串是可连接的，否则，从当前元素重新开始</span></span><br><span class="line">            dp[i] = Math.max(<span class="number">0</span>, dp[i - <span class="number">1</span>]) + nums[i];</span><br><span class="line">            <span class="comment">// 记录子串的最大和</span></span><br><span class="line">            max = Math.max(dp[i], max);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/17/UL2wdSmDrlbFANe.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-剑指-Offer-42-连续子数组的最大和&quot;&gt;&lt;a href=&quot;#力扣-剑指-Offer-42-连续子数组的最大和&quot; class=&quot;headerlink&quot; title=&quot;力扣 剑指 Offer 42. 连续子数组的最大和&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;h</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>减小和重新排列数组后的最大元素</title>
    <link href="http://zhoushing.github.io/2021-07-15-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html"/>
    <id>http://zhoushing.github.io/2021-07-15-%E5%87%8F%E5%B0%8F%E5%92%8C%E9%87%8D%E6%96%B0%E6%8E%92%E5%88%97%E6%95%B0%E7%BB%84%E5%90%8E%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%83%E7%B4%A0.html</id>
    <published>2021-07-15T00:21:38.000Z</published>
    <updated>2021-07-15T00:24:18.464Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1846-减小和重新排列数组后的最大元素"><a href="#力扣-1846-减小和重新排列数组后的最大元素" class="headerlink" title="力扣 1846. 减小和重新排列数组后的最大元素"></a>力扣 <a href="https://leetcode-cn.com/problems/maximum-element-after-decreasing-and-rearranging/">1846. 减小和重新排列数组后的最大元素</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><ul><li><p>给你一个正整数数组 <code>arr</code> 。请你对 <code>arr</code> 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：</p><ul><li><code>arr</code> 中 <strong>第一个</strong> 元素必须为 <code>1</code> 。</li><li>任意相邻两个元素的差的绝对值 <strong>小于等于</strong> <code>1</code> ，也就是说，对于任意的 <code>1 &lt;= i &lt; arr.length</code> （<strong>数组下标从 0 开始</strong>），都满足 <code>abs(arr[i] - arr[i - 1]) &lt;= 1</code> 。<code>abs(x)</code> 为 <code>x</code> 的绝对值。</li></ul><p>你可以执行以下 2 种操作任意次：</p><ul><li><strong>减小</strong> <code>arr</code> 中任意元素的值，使其变为一个 <strong>更小的正整数</strong> 。</li><li><strong>重新排列</strong> <code>arr</code> 中的元素，你可以以任意顺序重新排列。</li></ul><p>请你返回执行以上操作后，在满足前文所述的条件下，<code>arr</code> 中可能的 <strong>最大值</strong> 。</p></li></ul></li><li><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 10^5</code></li><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [2,2,1,2,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。</span><br><span class="line">arr 中最大元素为 2 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [100,1,1000]</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">一个可行的方案如下：</span><br><span class="line">1. 重新排列 arr 得到 [1,100,1000] 。</span><br><span class="line">2. 将第二个元素减小为 2 。</span><br><span class="line">3. 将第三个元素减小为 3 。</span><br><span class="line">现在 arr &#x3D; [1,2,3] ，满足所有条件。</span><br><span class="line">arr 中最大元素为 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：arr &#x3D; [1,2,3,4,5]</span><br><span class="line">输出：5</span><br><span class="line">解释：数组已经满足所有条件，最大元素为 5 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题比较简单，理解题目后就容易解出来了</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maximumElementAfterDecrementingAndRearranging</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.length;</span><br><span class="line">        <span class="comment">// 因为可执行操作中规定，只能将数字变小，不能变大，还可以以任意顺序重新排序</span></span><br><span class="line">        <span class="comment">// 所以我们进行排序，使数组变成非严格单调增序列</span></span><br><span class="line">        <span class="comment">// 单调增：(1,2,3,4)</span></span><br><span class="line">        <span class="comment">// 非严格单调增：(1,2,2,3,4)，即允许有相同元素在</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第一个元素置为1</span></span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在符合题意得情况下，使得arr[i]尽可能大</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                arr[i] = arr[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为数组是非严格单调增，所以最大值在数组末位</span></span><br><span class="line">        <span class="keyword">return</span> arr[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/15/qd2DrE94bWawv8z.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1846-减小和重新排列数组后的最大元素&quot;&gt;&lt;a href=&quot;#力扣-1846-减小和重新排列数组后的最大元素&quot; class=&quot;headerlink&quot; title=&quot;力扣 1846. 减小和重新排列数组后的最大元素&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>绝对差值和</title>
    <link href="http://zhoushing.github.io/2021-07-14-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C.html"/>
    <id>http://zhoushing.github.io/2021-07-14-%E7%BB%9D%E5%AF%B9%E5%B7%AE%E5%80%BC%E5%92%8C.html</id>
    <published>2021-07-14T13:33:15.000Z</published>
    <updated>2021-07-14T13:40:10.645Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1818-绝对差值和"><a href="#力扣-1818-绝对差值和" class="headerlink" title="力扣 1818. 绝对差值和"></a>力扣 <a href="https://leetcode-cn.com/problems/minimum-absolute-sum-difference/">1818. 绝对差值和</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>给你两个正整数数组 <code>nums1</code> 和 <code>nums2</code> ，数组的长度都是 <code>n</code> 。</p><p>数组 <code>nums1</code> 和 <code>nums2</code> 的 <strong>绝对差值和</strong> 定义为所有 <code>|nums1[i] - nums2[i]|</code>（<code>0 &lt;= i &lt; n</code>）的 <strong>总和</strong>（<strong>下标从 0 开始</strong>）。</p><p>你可以选用 <code>nums1</code> 中的 <strong>任意一个</strong> 元素来替换 <code>nums1</code> 中的 <strong>至多</strong> 一个元素，以 <strong>最小化</strong> 绝对差值和。</p><p>在替换数组 <code>nums1</code> 中最多一个元素 <strong>之后</strong> ，返回最小绝对差值和。因为答案可能很大，所以需要对 <code>109 + 7</code> <strong>取余</strong> 后返回。</p><p><code>|x|</code> 定义为：</p><ul><li>如果 <code>x &gt;= 0</code> ，值为 <code>x</code> ，或者</li><li>如果 <code>x &lt;= 0</code> ，值为 <code>-x</code></li></ul></li><li><p><strong>提示：</strong></p><ul><li><code>n == nums1.length</code></li><li><code>n == nums2.length</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= nums1[i], nums2[i] &lt;= 10^5</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,7,5], nums2 &#x3D; [2,3,5]</span><br><span class="line">输出：3</span><br><span class="line">解释：有两种可能的最优方案：</span><br><span class="line">- 将第二个元素替换为第一个元素：[1,7,5] &#x3D;&gt; [1,1,5] ，或者</span><br><span class="line">- 将第二个元素替换为第三个元素：[1,7,5] &#x3D;&gt; [1,5,5]</span><br><span class="line">两种方案的绝对差值和都是 |1-2| + (|1-3| 或者 |5-3|) + |5-5| &#x3D; 3</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [2,4,6,8,10], nums2 &#x3D; [2,4,6,8,10]</span><br><span class="line">输出：0</span><br><span class="line">解释：nums1 和 nums2 相等，所以不用替换元素。绝对差值和为 0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums1 &#x3D; [1,10,4,4,2,7], nums2 &#x3D; [9,3,5,1,7,4]</span><br><span class="line">输出：20</span><br><span class="line">解释：将第一个元素替换为第二个元素：[1,10,4,4,2,7] &#x3D;&gt; [10,10,4,4,2,7]</span><br><span class="line">绝对差值和为 |10-9| + |10-3| + |4-5| + |4-1| + |2-7| + |7-4| &#x3D; 20</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题用贪心需要做出一些调整，因为修改产生的最大差值不一定是修改差距最大的元素产生的</strong>，让我们来看看具体如何实现的吧。</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210714214000465.png" alt="image-20210714214000465"></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * HashSet</span></span><br><span class="line"><span class="comment">     * 取余</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minAbsoluteSumDiff</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span>[] nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = nums1.length;</span><br><span class="line">        <span class="keyword">int</span> MOD = <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用TreeSet来存储数组1中的元素</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums1) &#123;</span><br><span class="line">            set.add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 更改方案能减少的最大差值</span></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Math.abs(nums1[i] - nums2[i]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> num2 = nums2[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 寻找num2在数组1中对应的上边界和下边界（也就是最接近于num2的大于他的数和小于他的数）</span></span><br><span class="line">            <span class="keyword">int</span> floor = set.floor(num2) == <span class="keyword">null</span>? -<span class="number">100000</span>: set.floor(num2);</span><br><span class="line">            <span class="keyword">int</span> ceil = set.ceiling(num2) == <span class="keyword">null</span>? -<span class="number">100000</span>: set.ceiling(num2);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> floorGap = Math.abs(floor - num2);</span><br><span class="line">            <span class="keyword">int</span> ceilGap = Math.abs(ceil - num2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 比较这次修改能带来的最大差值</span></span><br><span class="line">            max = Math.max(max, Math.max(temp - floorGap, temp - ceilGap));</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// (a + b) % c = (a%c + b%c) % c</span></span><br><span class="line">            result = (result % MOD + temp % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">return</span> (result - max + MOD) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率一般，空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/14/B5UhQ3kCJG8AlYj.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1818-绝对差值和&quot;&gt;&lt;a href=&quot;#力扣-1818-绝对差值和&quot; class=&quot;headerlink&quot; title=&quot;力扣 1818. 绝对差值和&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/m</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashSet" scheme="http://zhoushing.github.io/tags/HashSet/"/>
    
    <category term="取余" scheme="http://zhoushing.github.io/tags/%E5%8F%96%E4%BD%99/"/>
    
  </entry>
  
  <entry>
    <title>初识前端组件库</title>
    <link href="http://zhoushing.github.io/2021-07-10-%E5%88%9D%E8%AF%86%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93.html"/>
    <id>http://zhoushing.github.io/2021-07-10-%E5%88%9D%E8%AF%86%E5%89%8D%E7%AB%AF%E7%BB%84%E4%BB%B6%E5%BA%93.html</id>
    <published>2021-07-10T10:01:16.000Z</published>
    <updated>2021-07-10T10:25:15.824Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>​    在实际的学习和设计过程中，我们不可避免地会接触到前端的html，css，js等代码，但是在对页面进行调试的时候，真心的不是很方便。还有诸如笔者这种偏向于后端的代码开发人员就更加头大了，往往一个页面就弄一上午，非常的浪费时间。</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210710182028869.png" alt="image-20210710182028869"></p><p>​    所以呢，在各种途径的搜寻下以及在观看了腾讯的<a href="https://www.zhihu.com/people/coder_yupi">鱼皮</a>大佬的视频后，发现了一个宝藏的工具：前端组件库</p><h2 id="组件库说明"><a href="#组件库说明" class="headerlink" title="组件库说明"></a>组件库说明</h2><p>组件库：顾名思义呢就是一大堆前端组件的库，里面有开源大佬已经帮你总结写好的诸多组件的代码和样式以及动作，能够让你轻松的快速页面开发不是梦。</p><h2 id="使用组件库"><a href="#使用组件库" class="headerlink" title="使用组件库"></a>使用组件库</h2><ol><li><p>搜索</p><p>利用搜索引擎搜索组件库</p><p>原生：<a href="https://www.layui.com/">LayUI</a></p><p>Vue：<a href="https://element.eleme.cn/#/zh-CN">ElementUI</a></p><p>React：<a href="https://ant.design/index-cn">Ant Design</a></p><p>移动端/小程序：<a href="https://gitee.com/vant-contrib/vant">VantUI</a></p></li><li><p>开始</p><p>来到对应组件库的官网，进入文档，选择快速开始或者开始使用等快速解释文档</p></li><li><p>引入</p><p>按照文档步骤，下载工具包到本地映入项目中，或者直接使用CDN进行引入</p></li><li><p>选择</p><p>选择自己需要的组件</p></li><li><p>看文档</p><p>在当前自己选择的组件文档中，仔细看一遍，选择更加方便完整的方式</p></li><li><p>粘贴</p><p>复制粘贴（手动狗头）</p></li><li><p>修改</p><p>根据自己的具体设计和需求修改对应的代码</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;​    在实际的学习和设计过程中，我们不可避免地会接触到前端的html，css，js等代码，但是在对页面进行调试的时候，真心的不是很方便。</summary>
      
    
    
    
    
    <category term="前端" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="组件库" scheme="http://zhoushing.github.io/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>主要元素</title>
    <link href="http://zhoushing.github.io/2021-07-09-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0.html"/>
    <id>http://zhoushing.github.io/2021-07-09-%E4%B8%BB%E8%A6%81%E5%85%83%E7%B4%A0.html</id>
    <published>2021-07-08T19:18:49.000Z</published>
    <updated>2021-07-08T19:23:43.531Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-面试题-17-10-主要元素"><a href="#力扣-面试题-17-10-主要元素" class="headerlink" title="力扣 面试题 17.10. 主要元素"></a>力扣 <a href="https://leetcode-cn.com/problems/find-majority-element-lcci/">面试题 17.10. 主要元素</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li>数组中占比超过一半的元素称之为主要元素。给你一个 <strong>整数</strong> 数组，找出其中的主要元素。若没有，返回 <code>-1</code> 。请设计时间复杂度为 <code>O(N)</code> 、空间复杂度为 <code>O(1)</code> 的解决方案。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[1,2,5,9,5,9,5,5,5]</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[3,2]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2,2,1,1,1,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>笔者采用了，正反向选举的方式，如果一个数的出现超过半数，那么肯定他出现的次数可以抵消掉其他所有出现的数的次数，依照此规律，我们仅需两次遍历就可以把主要元素找出来</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 出现最多的数和出现次数</span></span><br><span class="line">        <span class="keyword">int</span> mostNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mostCount = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果一个数次数出现最多，那么他的出现次数减去其他数出现的次数肯定大于0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mostCount == <span class="number">0</span>) &#123;</span><br><span class="line">                mostNum = nums[i];</span><br><span class="line">                mostCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mostNum == nums[i]) &#123;</span><br><span class="line">                    mostCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有数的可能次数相互抵消了，没有主要元素</span></span><br><span class="line">        <span class="keyword">if</span> (mostCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        result = mostNum;</span><br><span class="line">        mostNum = <span class="number">0</span>;</span><br><span class="line">        mostCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次正向遍历可能出现特殊情况导致，主要元素审查失败</span></span><br><span class="line">        <span class="comment">// 再反向遍历一次，保证主要元素选举正确</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mostCount == <span class="number">0</span>) &#123;</span><br><span class="line">                mostNum = nums[i];</span><br><span class="line">                mostCount++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (mostNum == nums[i]) &#123;</span><br><span class="line">                    mostCount++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    mostCount--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反向遍历所有数抵消或者与正向选举出的数不一样，主要元素不存在</span></span><br><span class="line">        <span class="keyword">if</span> (mostCount == <span class="number">0</span> || result != mostNum) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/09/A5wBzorMuJZ97g1.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-面试题-17-10-主要元素&quot;&gt;&lt;a href=&quot;#力扣-面试题-17-10-主要元素&quot; class=&quot;headerlink&quot; title=&quot;力扣 面试题 17.10. 主要元素&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="计数" scheme="http://zhoushing.github.io/tags/%E8%AE%A1%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>和相同的二元子数组</title>
    <link href="http://zhoushing.github.io/2021-07-08-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84.html"/>
    <id>http://zhoushing.github.io/2021-07-08-%E5%92%8C%E7%9B%B8%E5%90%8C%E7%9A%84%E4%BA%8C%E5%85%83%E5%AD%90%E6%95%B0%E7%BB%84.html</id>
    <published>2021-07-08T04:18:16.000Z</published>
    <updated>2021-07-08T04:21:07.969Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-930-和相同的二元子数组"><a href="#力扣-930-和相同的二元子数组" class="headerlink" title="力扣 930. 和相同的二元子数组"></a>力扣 <a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>给你一个二元数组 <code>nums</code> ，和一个整数 <code>goal</code> ，请你统计并返回有多少个和为 <code>goal</code> 的 <strong>非空</strong> 子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,0,1,0,1], goal &#x3D; 2</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">如下面黑体所示，有 4 个满足题目要求的子数组：</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br><span class="line">[1,0,1,0,1]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [0,0,0,0,0], goal &#x3D; 0</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，**笔者借鉴自<a href="https://leetcode-cn.com/u/ac_oier/">宫水三叶</a>大佬的<a href="https://leetcode-cn.com/problems/binary-subarrays-with-sum/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-hfoc0/">解法</a>**，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 前缀和+哈希</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numSubarraysWithSum</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> goal)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="comment">// 前缀和数组</span></span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当前遍历到的n + 1个数的和，作为右边界</span></span><br><span class="line">            <span class="keyword">int</span> right = sum[i + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 左边界就是右边界减去目标值</span></span><br><span class="line">            <span class="keyword">int</span> left = right - goal;</span><br><span class="line">            <span class="comment">// 查看哈希表中之前有没有存过对应的前缀和，有就累加</span></span><br><span class="line">            <span class="comment">// 至此，计算了一次当前位置前的区间了</span></span><br><span class="line">            result += map.getOrDefault(left, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 存储当前前缀和，方便之后计算区间和</span></span><br><span class="line">            map.put(right, map.getOrDefault(right, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率一般，空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/08/yBOXuJHG8P4ZD92.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-930-和相同的二元子数组&quot;&gt;&lt;a href=&quot;#力扣-930-和相同的二元子数组&quot; class=&quot;headerlink&quot; title=&quot;力扣 930. 和相同的二元子数组&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="前缀和" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>初识VMware Workstation</title>
    <link href="http://zhoushing.github.io/2021-07-06-%E5%88%9D%E8%AF%86VMware.html"/>
    <id>http://zhoushing.github.io/2021-07-06-%E5%88%9D%E8%AF%86VMware.html</id>
    <published>2021-07-06T11:22:13.000Z</published>
    <updated>2021-07-07T08:51:37.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><h3 id="虚拟机是什么"><a href="#虚拟机是什么" class="headerlink" title="虚拟机是什么"></a>虚拟机是什么</h3><p>虚拟机（Virtual Machine）指通过<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6/12053">软件</a>模拟的具有完整<a href="https://baike.baidu.com/item/%E7%A1%AC%E4%BB%B6">硬件</a>系统功能的、运行在一个完全<a href="https://baike.baidu.com/item/%E9%9A%94%E7%A6%BB/33079">隔离</a>环境中的完整<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/7210959">计算机系统</a>。在实体计算机中能够完成的工作在虚拟机中都能够实现。在<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338">计算机</a>中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的<a href="https://baike.baidu.com/item/CMOS/428167">CMOS</a>、硬盘和<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>，可以像使用实体机一样对虚拟机进行操作。(百度百科)</p><p><strong>虚拟机</strong>（英语：virtual machine），在<a href="https://chi.jinzhao.wiki/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中的<a href="https://chi.jinzhao.wiki/wiki/%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">体系结构</a>里，是指一种特殊的<a href="https://chi.jinzhao.wiki/wiki/%E8%BD%AF%E4%BB%B6">软件</a>，可以在<a href="https://chi.jinzhao.wiki/wiki/%E7%B3%BB%E7%BB%9F%E5%B9%B3%E5%8F%B0">计算机平台</a>和<a href="https://chi.jinzhao.wiki/wiki/%E7%BB%88%E7%AB%AF%E7%94%A8%E6%88%B7">终端用户</a>之间创建一种环境，而终端用户则是基于虚拟机这个软件所创建的环境来操作其它<a href="https://chi.jinzhao.wiki/wiki/%E8%BD%AF%E4%BB%B6">软件</a>。虚拟机（VM）是计算机系统的<a href="https://chi.jinzhao.wiki/wiki/%E4%BB%BF%E7%9C%9F%E5%99%A8">仿真器</a>，通过软件模拟具有完整<a href="https://chi.jinzhao.wiki/wiki/%E7%A1%AC%E4%BB%B6">硬件</a>系统功能的、运行在一个完全隔离环境中的完整<a href="https://chi.jinzhao.wiki/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F">计算机系统</a>，能提供物理计算机的功能。(维基百科)</p><p>在笔者看来，虚拟机正如其名，就是能够让你在一台机器上同时运行两个或更多Windows、DOS、LINUX系统。</p><h3 id="为什么使用虚拟机"><a href="#为什么使用虚拟机" class="headerlink" title="为什么使用虚拟机"></a>为什么使用虚拟机</h3><p>1.演示环境，可以安装各种演示环境，便于做各种例子；</p><p>2.保证主机的快速运行，减少不必要的垃圾安装程序，偶尔使用的程序，或者测试用的程序在虚拟机上运行；</p><p>3.想测试一下不熟悉的应用，在虚拟机中随便安装和彻底删除；</p><p>4.体验不同版本的操作系统，如Linux、Mac等。</p><p>总的来说就是：简单方便</p><h2 id="VMware-Workstation"><a href="#VMware-Workstation" class="headerlink" title="VMware Workstation"></a><a href="https://baike.baidu.com/item/VMware%20Workstation">VMware Workstation</a></h2><p>​    全称VMware Workstation Pro，是一款功能强大的桌面虚拟计算机软件，提供用户可在单一的桌面上同时运行不同的操作系统，和进行开发、测试 、部署新的应用程序的最佳解决方案。VMware Workstation 可在一部实体机器上模拟完整的网络环境，以及可便于携带的虚拟机器，其更好的灵活性与先进的技术胜过了市面上其他的虚拟计算机软件。</p><p>官网：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a></p><h2 id="下载地址"><a href="#下载地址" class="headerlink" title="下载地址"></a>下载地址</h2><p>链接：<a href="https://www.vmware.com/cn/products/workstation-pro/workstation-pro-evaluation.html">官网下载地址</a></p><p>说明：官网的是16版本了，读者可以选择下载下来试用30天，在下面提供15版本的百度网盘下载。</p><p>版本：15.5.2</p><p>链接：<a href="https://pan.baidu.com/s/1V0Df_lFb6NlwzkA-QMTULQ">百度网盘</a></p><p>提取码：uxl2</p><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>　　<strong>各版本序列号(来源于网络)</strong></p><p>　　10.x：1Z0G9-67285-FZG78-ZL3Q2-234JG</p><p>　　11.x：YG74R-86G1M-M8DLP-XEQNT-XAHW2</p><p>　　12.x：ZC3TK-63GE6-481JY-WWW5T-Z7ATA</p><p>　　14.x：AU108-FLF9P-H8EJZ-7XMQ9-XG0U8</p><p>　　15.x：FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6</p><p>(笔者仅尝试过15版本的密钥，其他的请读者自己尝试)</p><h2 id="安装VMware-Workstation"><a href="#安装VMware-Workstation" class="headerlink" title="安装VMware Workstation"></a>安装VMware Workstation</h2><ol><li>解压</li><li>双击.exe安装文件</li><li>无脑下一步</li><li>不启用产品更新以及不加入客户体验提升计划(建议)</li><li>无脑下一步</li><li>安装(安装过程有点久，请耐心等待)</li><li>输入许可证，也就是上面的密钥</li><li>完成安装</li></ol><h2 id="使用VMware-Workstation"><a href="#使用VMware-Workstation" class="headerlink" title="使用VMware Workstation"></a>使用VMware Workstation</h2><p>首先要拥有一个系统的iso文件，这里推荐的是<a href="https://baike.baidu.com/item/Linux">linux</a>系统发行版中的<a href="https://baike.baidu.com/item/ubuntu/155795?fr=aladdin">ubuntu</a></p><p><a href="https://mirrors.neusoft.edu.cn/ubuntu-releases/focal/">ubuntu下载地址</a></p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707163223981.png" alt="image-20210707163223981"></p><p>接着在VMware Workstation中操作</p><ol><li><p>创建新的虚拟机</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707163726576.png" alt="image-20210707163726576"></p></li><li><p>选择配置模式(典型)</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707163821644.png" alt="image-20210707163821644"></p></li><li><p>选择iso文件路径</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707164015304.png" alt="image-20210707164015304"></p></li><li><p>填写系统信息</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707164428550.png" alt="image-20210707164428550"></p></li><li><p>编辑虚拟机名称和位置</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707164544837.png" alt="image-20210707164544837"></p></li><li><p>指定磁盘容量(建议单文件)</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707164844091.png" alt="image-20210707164844091"></p></li><li><p>完成创建</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210707164952707.png"></p></li><li><p>教程到此结束，快去试用一下新系统吧</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;h3 id=&quot;虚拟机是什么&quot;&gt;&lt;a href=&quot;#虚拟机是什么&quot; class=&quot;headerlink&quot; title=&quot;虚拟机是什么&quot;&gt;&lt;/a&gt;虚</summary>
      
    
    
    
    
    <category term="虚拟机" scheme="http://zhoushing.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    <category term="VMware Workstation" scheme="http://zhoushing.github.io/tags/VMware-Workstation/"/>
    
  </entry>
  
  <entry>
    <title>错误的集合</title>
    <link href="http://zhoushing.github.io/2021-07-04-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88.html"/>
    <id>http://zhoushing.github.io/2021-07-04-%E9%94%99%E8%AF%AF%E7%9A%84%E9%9B%86%E5%90%88.html</id>
    <published>2021-07-04T13:21:26.000Z</published>
    <updated>2021-07-04T13:23:26.705Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-645-错误的集合"><a href="#力扣-645-错误的集合" class="headerlink" title="力扣 645. 错误的集合"></a>力扣 <a href="https://leetcode-cn.com/problems/set-mismatch/">645. 错误的集合</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>集合 <code>s</code> 包含从 <code>1</code> 到 <code>n</code> 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 <strong>丢失了一个数字</strong> 并且 <strong>有一个数字重复</strong> 。</p><p>给定一个数组 <code>nums</code> 代表了集合 <code>S</code> 发生错误后的结果。</p><p>请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。</p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,2,2,4]</span><br><span class="line">输出：[2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums &#x3D; [1,1]</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>笔者采用了朴素解法</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] findErrorNums(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重复的数字</span></span><br><span class="line">        <span class="keyword">int</span> doubleNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 错误的数字</span></span><br><span class="line">        <span class="keyword">int</span> errorNum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 原来的所有数之和</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 错误集合的数之和</span></span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                doubleNum = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            sum1 += (i + <span class="number">1</span>);</span><br><span class="line">            sum2 += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sum2 + errorNum = sum1 + doubleNum;</span></span><br><span class="line">        errorNum = sum1 + doubleNum - sum2;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;doubleNum, errorNum&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率一般，空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/04/3gzD69kWn4pMUrf.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-645-错误的集合&quot;&gt;&lt;a href=&quot;#力扣-645-错误的集合&quot; class=&quot;headerlink&quot; title=&quot;力扣 645. 错误的集合&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/set-</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>根据字符出现频率排序</title>
    <link href="http://zhoushing.github.io/2021-07-03-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html"/>
    <id>http://zhoushing.github.io/2021-07-03-%E6%A0%B9%E6%8D%AE%E5%AD%97%E7%AC%A6%E5%87%BA%E7%8E%B0%E9%A2%91%E7%8E%87%E6%8E%92%E5%BA%8F.html</id>
    <published>2021-07-03T15:28:28.000Z</published>
    <updated>2021-07-03T15:34:48.253Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-451-根据字符出现频率排序"><a href="#力扣-451-根据字符出现频率排序" class="headerlink" title="力扣 451. 根据字符出现频率排序"></a>力扣 <a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/">451. 根据字符出现频率排序</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;tree&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;eert&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;e&#39;出现两次，&#39;r&#39;和&#39;t&#39;都只出现一次。</span><br><span class="line">因此&#39;e&#39;必须出现在&#39;r&#39;和&#39;t&#39;之前。此外，&quot;eetr&quot;也是一个有效的答案。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;cccaaa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">&#39;c&#39;和&#39;a&#39;都出现三次。此外，&quot;aaaccc&quot;也是有效的答案。</span><br><span class="line">注意&quot;cacaca&quot;是不正确的，因为相同的字母必须放在一起。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">&quot;Aabb&quot;</span><br><span class="line"></span><br><span class="line">输出:</span><br><span class="line">&quot;bbAa&quot;</span><br><span class="line"></span><br><span class="line">解释:</span><br><span class="line">此外，&quot;bbaA&quot;也是一个有效的答案，但&quot;Aabb&quot;是不正确的。</span><br><span class="line">注意&#39;A&#39;和&#39;a&#39;被认为是两种不同的字符。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道哈希算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题套用哈希统计字符出现次数再排序即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 哈希</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">frequencySort</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过哈希表来统计各字符出现的顺序</span></span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(s.charAt(i))) &#123;</span><br><span class="line">                map.put(s.charAt(i), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(s.charAt(i), map.get(s.charAt(i)) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将各字母及其出现次数根据出现次数排序</span></span><br><span class="line">        List&lt;Map.Entry&lt;Character, Integer&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;Map.Entry&lt;Character, Integer&gt;&gt;(map.entrySet());</span><br><span class="line"></span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Map.Entry&lt;Character, Integer&gt;&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Map.Entry&lt;Character, Integer&gt; o1, Map.Entry&lt;Character, Integer&gt; o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o2.getValue().compareTo(o1.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 更简写法</span></span><br><span class="line">        <span class="comment">// list.sort((o1, o2) -&gt; o2.getValue().compareTo(o1.getValue()));</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历数组，将结果填入</span></span><br><span class="line">        list.forEach((entry) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getValue() != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] temp = <span class="keyword">new</span> <span class="keyword">char</span>[entry.getValue()];</span><br><span class="line">                Arrays.fill(temp, entry.getKey());</span><br><span class="line">                sb.append(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率一般，空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210703233404901.png" alt="image-20210703233404901"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-451-根据字符出现频率排序&quot;&gt;&lt;a href=&quot;#力扣-451-根据字符出现频率排序&quot; class=&quot;headerlink&quot; title=&quot;力扣 451. 根据字符出现频率排序&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>雪糕的最大数量</title>
    <link href="http://zhoushing.github.io/2021-07-02-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F.html"/>
    <id>http://zhoushing.github.io/2021-07-02-%E9%9B%AA%E7%B3%95%E7%9A%84%E6%9C%80%E5%A4%A7%E6%95%B0%E9%87%8F.html</id>
    <published>2021-07-02T00:36:05.000Z</published>
    <updated>2021-07-02T00:39:28.251Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1833-雪糕的最大数量"><a href="#力扣-1833-雪糕的最大数量" class="headerlink" title="力扣 1833. 雪糕的最大数量"></a>力扣 <a href="https://leetcode-cn.com/problems/maximum-ice-cream-bars/">1833. 雪糕的最大数量</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>夏日炎炎，小男孩 Tony 想买一些雪糕消消暑。</p><p>商店中新到 <code>n</code> 支雪糕，用长度为 <code>n</code> 的数组 <code>costs</code> 表示雪糕的定价，其中 <code>costs[i]</code> 表示第 <code>i</code> 支雪糕的现金价格。Tony 一共有 <code>coins</code> 现金可以用于消费，他想要买尽可能多的雪糕。</p><p>给你价格数组 <code>costs</code> 和现金量 <code>coins</code> ，请你计算并返回 Tony 用 <code>coins</code> 现金能够买到的雪糕的 <strong>最大数量</strong> 。</p><p><strong>注意：</strong>Tony 可以按任意顺序购买雪糕。</p></li></ul><ul><li><p><strong>提示：</strong></p><ul><li><code>costs.length == n</code></li><li><code>1 &lt;= n &lt;= 105</code></li><li><code>1 &lt;= costs[i] &lt;= 105</code></li><li><code>1 &lt;= coins &lt;= 108</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs &#x3D; [1,3,2,4,1], coins &#x3D; 7</span><br><span class="line">输出：4</span><br><span class="line">解释：Tony 可以买下标为 0、1、2、4 的雪糕，总价为 1 + 3 + 2 + 1 &#x3D; 7</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs &#x3D; [10,6,8,7,7,8], coins &#x3D; 5</span><br><span class="line">输出：0</span><br><span class="line">解释：Tony 没有足够的钱买任何一支雪糕。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：costs &#x3D; [1,6,3,1,2,5], coins &#x3D; 20</span><br><span class="line">输出：6</span><br><span class="line">解释：Tony 可以买下所有的雪糕，总价为 1 + 6 + 3 + 1 + 2 + 5 &#x3D; 18 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道贪心算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题虽然是中等题，但思路很容易想，因为不限制买雪糕的顺序，所以我们只需要每次选择最便宜的雪糕即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 排序</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxIceCream</span><span class="params">(<span class="keyword">int</span>[] costs, <span class="keyword">int</span> coins)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = costs.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先进行排序，方便进行贪心选择</span></span><br><span class="line">        Arrays.sort(costs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">// 当还剩下雪糕可选以及还剩下钱可以买雪糕时，贪心选择最便宜的雪糕</span></span><br><span class="line">        <span class="keyword">while</span>(result &lt; n &amp;&amp; coins &gt;= costs[tick]) &#123;</span><br><span class="line">            coins -= costs[tick];</span><br><span class="line">            tick++;</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210702083817224.png" alt="image-20210702083817224"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1833-雪糕的最大数量&quot;&gt;&lt;a href=&quot;#力扣-1833-雪糕的最大数量&quot; class=&quot;headerlink&quot; title=&quot;力扣 1833. 雪糕的最大数量&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="排序" scheme="http://zhoushing.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>传递信息</title>
    <link href="http://zhoushing.github.io/2021-07-01-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF.html"/>
    <id>http://zhoushing.github.io/2021-07-01-%E4%BC%A0%E9%80%92%E4%BF%A1%E6%81%AF.html</id>
    <published>2021-07-01T01:33:34.000Z</published>
    <updated>2021-07-01T01:36:13.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-LCP-07-传递信息"><a href="#力扣-LCP-07-传递信息" class="headerlink" title="力扣 LCP 07. 传递信息"></a>力扣 <a href="https://leetcode-cn.com/problems/chuan-di-xin-xi/">LCP 07. 传递信息</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：</p><ol><li>有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0</li></ol></li></ul><ol start="2"><li><p>每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。</p></li><li><p>每轮信息必须需要传递给另一个人，且信息可重复经过同一个人</p><p>给定总玩家数 <code>n</code>，以及按 <code>[玩家编号,对应可传递玩家编号]</code> 关系组成的二维数组 <code>relation</code>。返回信息从小 A (编号 0 ) 经过 <code>k</code> 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。</p></li></ol><ul><li><p><strong>提示：</strong></p><ul><li><code>2 &lt;= n &lt;= 10</code></li><li><code>1 &lt;= k &lt;= 5</code></li><li><code>1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2</code></li><li><code>0 &lt;= relation[i][0],relation[i][1] &lt; n 且 relation[i][0] != relation[i][1]</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><blockquote><p>输入：<code>n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3</code></p><p>输出：<code>3</code></p><p>解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：<code>n = 3, relation = [[0,2],[2,1]], k = 2</code></p><p>输出：<code>0</code></p><p>解释：信息不能从小 A 处经过 2 轮传递到编号 2</p></blockquote><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道DFS算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题用DFS比较直观</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 存储各个玩家能传递到的玩家列表</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; list;</span><br><span class="line">    <span class="comment">// 总玩家数</span></span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="comment">// k 轮数</span></span><br><span class="line">    <span class="keyword">int</span> times;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] relation, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        num = n;</span><br><span class="line">        times = k;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化二维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历存储</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] ints : relation) &#123;</span><br><span class="line">            list.get(ints[<span class="number">0</span>]).add(ints[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从第一个玩家开始</span></span><br><span class="line">        dfs(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 轮数到达 k</span></span><br><span class="line">        <span class="keyword">if</span> (count == times) &#123;</span><br><span class="line">            <span class="comment">// 判断是否到达最后一个玩家</span></span><br><span class="line">            result = index == num - <span class="number">1</span>? result + <span class="number">1</span>: result;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 遍历能到达的玩家，进行消息传递</span></span><br><span class="line">        <span class="comment">// .forEach是jdk8新特性，等同于for(T i: 可迭代对象)</span></span><br><span class="line">        list.get(index).forEach((tick) -&gt; dfs(tick, count + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/07/01/KIAo3d61XEiLexC.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-LCP-07-传递信息&quot;&gt;&lt;a href=&quot;#力扣-LCP-07-传递信息&quot; class=&quot;headerlink&quot; title=&quot;力扣 LCP 07. 传递信息&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>Excel表列名称</title>
    <link href="http://zhoushing.github.io/2021-06-29-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html"/>
    <id>http://zhoushing.github.io/2021-06-29-Excel%E8%A1%A8%E5%88%97%E5%90%8D%E7%A7%B0.html</id>
    <published>2021-06-29T12:28:29.000Z</published>
    <updated>2021-06-29T12:33:20.185Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-168-Excel表列名称"><a href="#力扣-168-Excel表列名称" class="headerlink" title="力扣 168. Excel表列名称"></a>力扣 <a href="https://leetcode-cn.com/problems/excel-sheet-column-title/">168. Excel表列名称</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>给你一个整数 <code>columnNumber</code> ，返回它在 Excel 表中相对应的列名称。</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">A -&gt; 1</span><br><span class="line">B -&gt; 2</span><br><span class="line">C -&gt; 3</span><br><span class="line">...</span><br><span class="line">Z -&gt; 26</span><br><span class="line">AA -&gt; 27</span><br><span class="line">AB -&gt; 28 </span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>提示：</strong></p><ul><li><code>1 &lt;= columnNumber &lt;= 2^31 - 1</code></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber &#x3D; 1</span><br><span class="line">输出：&quot;A&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber &#x3D; 28</span><br><span class="line">输出：&quot;AB&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber &#x3D; 701</span><br><span class="line">输出：&quot;ZY&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：columnNumber &#x3D; 2147483647</span><br><span class="line">输出：&quot;FXSHRXW&quot;</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题是经典的进制转化加了一点小坑，要注意这里的A是从1开始，所以进行进制转化时，需要多一步操作</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 进制</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convertToTitle</span><span class="params">(<span class="keyword">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (columnNumber &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 本题中数字是从1开始，所以操作数时要减一，这样就能完美转化为26进制</span></span><br><span class="line">            columnNumber--;</span><br><span class="line">            sb.append((<span class="keyword">char</span>) (columnNumber % <span class="number">26</span> + <span class="string">&#x27;A&#x27;</span>));</span><br><span class="line">            columnNumber = columnNumber / <span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 因为此处是从操作数取余所得，即是从尾部获取得，所以要进行翻转</span></span><br><span class="line">        <span class="keyword">return</span> sb.reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/06/29/lIipt6GwPgUr3zb.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-168-Excel表列名称&quot;&gt;&lt;a href=&quot;#力扣-168-Excel表列名称&quot; class=&quot;headerlink&quot; title=&quot;力扣 168. Excel表列名称&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数字" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%97/"/>
    
    <category term="进制" scheme="http://zhoushing.github.io/tags/%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>打开转盘锁</title>
    <link href="http://zhoushing.github.io/2021-06-25-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81.html"/>
    <id>http://zhoushing.github.io/2021-06-25-%E6%89%93%E5%BC%80%E8%BD%AC%E7%9B%98%E9%94%81.html</id>
    <published>2021-06-25T08:24:17.000Z</published>
    <updated>2021-06-25T08:27:56.637Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-752-打开转盘锁"><a href="#力扣-752-打开转盘锁" class="headerlink" title="力扣 752. 打开转盘锁"></a>力扣 <a href="https://leetcode-cn.com/problems/open-the-lock/">752. 打开转盘锁</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： <code>&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;</code> 。每个拨轮可以自由旋转：例如把 <code>&#39;9&#39;</code> 变为 <code>&#39;0&#39;</code>，<code>&#39;0&#39;</code> 变为 <code>&#39;9&#39;</code> 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>锁的初始数字为 <code>&#39;0000&#39;</code> ，一个代表四个拨轮的数字的字符串。</p><p>列表 <code>deadends</code> 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>字符串 <code>target</code> 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 <code>-1</code> 。</p></li></ul><ul><li><p><strong>提示：</strong></p><ul><li><code>1 &lt;= deadends.length &lt;= 500</code></li><li><code>deadends[i].length == 4</code></li><li><code>target.length == 4</code></li><li><code>target</code> <strong>不在</strong> <code>deadends</code> 之中</li><li><code>target</code> 和 <code>deadends[i]</code> 仅由若干位数字组成</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends &#x3D; [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target &#x3D; &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，</span><br><span class="line">因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends &#x3D; [&quot;8888&quot;], target &#x3D; &quot;0009&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：</span><br><span class="line">把最后一位反向旋转一次即可 &quot;0000&quot; -&gt; &quot;0009&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends &#x3D; [&quot;8887&quot;,&quot;8889&quot;,&quot;8878&quot;,&quot;8898&quot;,&quot;8788&quot;,&quot;8988&quot;,&quot;7888&quot;,&quot;9888&quot;], target &#x3D; &quot;8888&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：</span><br><span class="line">无法旋转到目标数字且不被锁定。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: deadends &#x3D; [&quot;0000&quot;], target &#x3D; &quot;8888&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道BFS算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题是比较有意思的一道BFS的题目</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * BFS</span></span><br><span class="line"><span class="comment">     * 经典层序遍历，类似于树的层序遍历原理，</span></span><br><span class="line"><span class="comment">     * 层序遍历当前步数之后的可能，加入队列中</span></span><br><span class="line"><span class="comment">     * 类似于树遍历中将孩子节点加入队列当中一样</span></span><br><span class="line"><span class="comment">     * 保证了层序的遍历顺序</span></span><br><span class="line"><span class="comment">     * 因为是先进先出的队列，所以保证只有遍历完一层之后才会遍历下一层</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">openLock</span><span class="params">(String[] deadends, String target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 目标就是原点，即无需步数</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;0000&quot;</span>.equals(target)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 存储死锁位置</span></span><br><span class="line">        <span class="comment">// 设为set方便查找</span></span><br><span class="line">        Set&lt;String&gt; dead = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String deadend : deadends) &#123;</span><br><span class="line">            dead.add(deadend);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原点死锁，返回目标不可达</span></span><br><span class="line">        <span class="keyword">if</span> (dead.contains(<span class="string">&quot;0000&quot;</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算步数</span></span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处使用LinkedList作为队列的实现</span></span><br><span class="line">        Queue&lt;String&gt; queue = <span class="keyword">new</span> LinkedList&lt;String&gt;();</span><br><span class="line">        queue.offer(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 标记已经走过的</span></span><br><span class="line">        Set&lt;String&gt; seen = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        seen.add(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            ++step;</span><br><span class="line">            <span class="keyword">int</span> size = queue.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="comment">// 提取当前位置</span></span><br><span class="line">                String status = queue.poll();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (String nextStatus : get(status)) &#123;</span><br><span class="line">                    <span class="comment">// 如果当前位置没有走过而且不是死锁位置</span></span><br><span class="line">                    <span class="keyword">if</span> (!seen.contains(nextStatus) &amp;&amp; !dead.contains(nextStatus)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (nextStatus.equals(target)) &#123;</span><br><span class="line">                            <span class="keyword">return</span> step;</span><br><span class="line">                        &#125;</span><br><span class="line">                        queue.offer(nextStatus);</span><br><span class="line">                        seen.add(nextStatus);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数字向前转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">numPrev</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&#x27;9&#x27;</span> : (<span class="keyword">char</span>) (x - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数字向后转</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">numSucc</span><span class="params">(<span class="keyword">char</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="string">&#x27;9&#x27;</span> ? <span class="string">&#x27;0&#x27;</span> : (<span class="keyword">char</span>) (x + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 枚举 status 通过一次旋转得到的数字</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">get</span><span class="params">(String status)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] array = status.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">char</span> num = array[i];</span><br><span class="line">            array[i] = numPrev(num);</span><br><span class="line">            result.add(<span class="keyword">new</span> String(array));</span><br><span class="line">            array[i] = numSucc(num);</span><br><span class="line">            result.add(<span class="keyword">new</span> String(array));</span><br><span class="line">            array[i] = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210625162711365.png" alt="image-20210625162711365"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-752-打开转盘锁&quot;&gt;&lt;a href=&quot;#力扣-752-打开转盘锁&quot; class=&quot;headerlink&quot; title=&quot;力扣 752. 打开转盘锁&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/open</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="广度优先搜索" scheme="http://zhoushing.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>二进制中1的个数</title>
    <link href="http://zhoushing.github.io/2021-06-23-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-06-23-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0.html</id>
    <published>2021-06-23T06:48:39.000Z</published>
    <updated>2021-06-25T08:26:19.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-剑指-Offer-15-二进制中1的个数"><a href="#力扣-剑指-Offer-15-二进制中1的个数" class="headerlink" title="力扣 剑指 Offer 15. 二进制中1的个数"></a>力扣 <a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">剑指 Offer 15. 二进制中1的个数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li>请实现一个函数，输入一个整数（以二进制串形式），输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。</li></ul><ul><li><p><strong>提示：</strong></p><ul><li>输入必须是长度为 <code>32</code> 的 <strong>二进制串</strong> 。    </li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000000001011</span><br><span class="line">输出：3</span><br><span class="line">解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：00000000000000000000000010000000</span><br><span class="line">输出：1</span><br><span class="line">解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：11111111111111111111111111111101</span><br><span class="line">输出：31</span><br><span class="line">解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 &#39;1&#39;。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道位运算算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题是比较简单的位运算题目</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 位运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// you need to treat n as an unsigned value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 消除二进制数尾位1来计算二进制数中1的个数</span></span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            result++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210623145317709.png" alt="image-20210623145317709"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-剑指-Offer-15-二进制中1的个数&quot;&gt;&lt;a href=&quot;#力扣-剑指-Offer-15-二进制中1的个数&quot; class=&quot;headerlink&quot; title=&quot;力扣 剑指 Offer 15. 二进制中1的个数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;http</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="位运算" scheme="http://zhoushing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>字符串的排列</title>
    <link href="http://zhoushing.github.io/2021-06-22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-1.html"/>
    <id>http://zhoushing.github.io/2021-06-22-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97-1.html</id>
    <published>2021-06-22T09:17:07.000Z</published>
    <updated>2021-06-22T09:21:24.779Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-剑指-Offer-38-字符串的排列"><a href="#力扣-剑指-Offer-38-字符串的排列" class="headerlink" title="力扣 剑指 Offer 38. 字符串的排列"></a>力扣 <a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/">剑指 Offer 38. 字符串的排列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>输入一个字符串，打印出该字符串中字符的所有排列。</p><p>你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。</p></li><li><p><strong>限制：</strong></p><p><code>1 &lt;= s 的长度 &lt;= 8</code></p></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;abc&quot;</span><br><span class="line">输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道DFS算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题是比较经典的DFS题目</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = s.length();</span><br><span class="line"></span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>[] ch = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 深度优先遍历</span></span><br><span class="line">        dfs(ch, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 动态数组转静态数组</span></span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> String[list.size()]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> tick)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 组建成功一个字符串</span></span><br><span class="line">        <span class="keyword">if</span> (tick == ch.length) &#123;</span><br><span class="line">            <span class="comment">// 将字节数组作为参数创建字符串</span></span><br><span class="line">            list.add(<span class="keyword">new</span> String(ch));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = tick; i &lt; ch.length; i++) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> temp = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = tick; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="comment">// 字母相同时，后面的组合相同，剪枝</span></span><br><span class="line">                <span class="keyword">if</span> (ch[i] == ch[j]) &#123;</span><br><span class="line">                    temp = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (temp) &#123;</span><br><span class="line">                <span class="comment">// 交换两数</span></span><br><span class="line">                <span class="keyword">char</span> tempCh = ch[tick];</span><br><span class="line">                ch[tick] = ch[i];</span><br><span class="line">                ch[i] = tempCh;</span><br><span class="line"></span><br><span class="line">                dfs(ch, tick + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 复原两数</span></span><br><span class="line">                tempCh = ch[tick];</span><br><span class="line">                ch[tick] = ch[i];</span><br><span class="line">                ch[i] = tempCh;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/06/22/mhDIAyP6CKVOwqY.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-剑指-Offer-38-字符串的排列&quot;&gt;&lt;a href=&quot;#力扣-剑指-Offer-38-字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;力扣 剑指 Offer 38. 字符串的排列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://le</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="回溯" scheme="http://zhoushing.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二进制手表</title>
    <link href="http://zhoushing.github.io/2021-06-21-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-06-21-%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%89%8B%E8%A1%A8.html</id>
    <published>2021-06-21T02:23:19.000Z</published>
    <updated>2021-06-21T02:27:25.314Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-401-二进制手表"><a href="#力扣-401-二进制手表" class="headerlink" title="力扣 401. 二进制手表"></a>力扣 <a href="https://leetcode-cn.com/problems/binary-watch/">401. 二进制手表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>二进制手表顶部有 4 个 LED 代表 <strong>小时（0-11）</strong>，底部的 6 个 LED 代表 <strong>分钟（0-59）</strong>。每个 LED 代表一个 0 或 1，最低位在右侧。</p><ul><li>例如，下面的二进制手表读取 <code>&quot;3:25&quot;</code> 。</li></ul><p><img src= "/img/loading1.gif" data-lazy-src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20210621102545629.png" alt="image-20210621102545629"></p><p><em>（图源：<a href="https://commons.m.wikimedia.org/wiki/File:Binary_clock_samui_moon.jpg">WikiMedia - Binary clock samui moon.jpg</a> ，许可协议：<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.en">Attribution-ShareAlike 3.0 Unported (CC BY-SA 3.0)</a> ）</em></p><p>给你一个整数 <code>turnedOn</code> ，表示当前亮着的 LED 的数量，返回二进制手表可以表示的所有可能时间。你可以 <strong>按任意顺序</strong> 返回答案。</p><p>小时不会以零开头：</p><ul><li>例如，<code>&quot;01:00&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;1:00&quot;</code> 。</li></ul><p>分钟必须由两位数组成，可能会以零开头：</p><ul><li>例如，<code>&quot;10:2&quot;</code> 是无效的时间，正确的写法应该是 <code>&quot;10:02&quot;</code> 。</li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn &#x3D; 1</span><br><span class="line">输出：[&quot;0:01&quot;,&quot;0:02&quot;,&quot;0:04&quot;,&quot;0:08&quot;,&quot;0:16&quot;,&quot;0:32&quot;,&quot;1:00&quot;,&quot;2:00&quot;,&quot;4:00&quot;,&quot;8:00&quot;]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：turnedOn &#x3D; 9</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道位运算算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题可以转化成经典的位运算题目</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 位运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">readBinaryWatch</span><span class="params">(<span class="keyword">int</span> turnedOn)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 亮灯数超过8就溢出了，没有这样的时间</span></span><br><span class="line">        <span class="keyword">if</span>(turnedOn &gt; <span class="number">8</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于时间的可能比较小，可以直接对每个时间进行验证，判断是否符合亮灯数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; <span class="number">12</span>; h++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> m = <span class="number">0</span>; m &lt; <span class="number">60</span>; m++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (count(h) + count(m) == turnedOn) &#123;</span><br><span class="line">                    sb.append(h);</span><br><span class="line">                    sb.append(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">                    <span class="comment">// 分钟的前置0</span></span><br><span class="line">                    <span class="keyword">if</span> (m &lt; <span class="number">10</span>) &#123;</span><br><span class="line">                        sb.append(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    sb.append(m);</span><br><span class="line"></span><br><span class="line">                    result.add(sb.toString());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 清空，方便再次存储</span></span><br><span class="line">                sb.delete(<span class="number">0</span>, sb.length());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 计算当前数 二进制数中1的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> nums = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            n &amp;= (n - <span class="number">1</span>);</span><br><span class="line">            nums++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/06/21/uPF1qDifCk9rzyQ.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-401-二进制手表&quot;&gt;&lt;a href=&quot;#力扣-401-二进制手表&quot; class=&quot;headerlink&quot; title=&quot;力扣 401. 二进制手表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/bina</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="位运算" scheme="http://zhoushing.github.io/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>皇位继承顺序</title>
    <link href="http://zhoushing.github.io/2021-06-20-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F.html"/>
    <id>http://zhoushing.github.io/2021-06-20-%E7%9A%87%E4%BD%8D%E7%BB%A7%E6%89%BF%E9%A1%BA%E5%BA%8F.html</id>
    <published>2021-06-20T06:59:44.000Z</published>
    <updated>2021-06-20T07:02:48.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1600-皇位继承顺序"><a href="#力扣-1600-皇位继承顺序" class="headerlink" title="力扣 1600. 皇位继承顺序"></a>力扣 <a href="https://leetcode-cn.com/problems/throne-inheritance/">1600. 皇位继承顺序</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><ul><li><p>一个王国里住着国王、他的孩子们、他的孙子们等等。每一个时间点，这个家庭里有人出生也有人死亡。</p><p>这个王国有一个明确规定的皇位继承顺序，第一继承人总是国王自己。我们定义递归函数 <code>Successor(x, curOrder)</code> ，给定一个人 <code>x</code> 和当前的继承顺序，该函数返回 <code>x</code> 的下一继承人。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Successor(x, curOrder):</span><br><span class="line">    如果 x 没有孩子或者所有 x 的孩子都在 curOrder 中：</span><br><span class="line">        如果 x 是国王，那么返回 null</span><br><span class="line">        否则，返回 Successor(x 的父亲, curOrder)</span><br><span class="line">    否则，返回 x 不在 curOrder 中最年长的孩子</span><br></pre></td></tr></table></figure><p>比方说，假设王国由国王，他的孩子 Alice 和 Bob （Alice 比 Bob 年长）和 Alice 的孩子 Jack 组成。</p><ol><li>一开始， <code>curOrder</code> 为 <code>[&quot;king&quot;]</code>.</li><li>调用 <code>Successor(king, curOrder)</code> ，返回 Alice ，所以我们将 Alice 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;]</code> 。</li><li>调用 <code>Successor(Alice, curOrder)</code> ，返回 Jack ，所以我们将 Jack 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;]</code> 。</li><li>调用 <code>Successor(Jack, curOrder)</code> ，返回 Bob ，所以我们将 Bob 放入 <code>curOrder</code> 中，得到 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code> 。</li><li>调用 <code>Successor(Bob, curOrder)</code> ，返回 <code>null</code> 。最终得到继承顺序为 <code>[&quot;king&quot;, &quot;Alice&quot;, &quot;Jack&quot;, &quot;Bob&quot;]</code> 。</li></ol><p>通过以上的函数，我们总是能得到一个唯一的继承顺序。</p><p>请你实现 <code>ThroneInheritance</code> 类：</p><ul><li><p><code>ThroneInheritance(string kingName)</code> 初始化一个 <code>ThroneInheritance</code> 类的对象。国王的名字作为构造函数的参数传入。</p></li><li><p><code>void birth(string parentName, string childName)</code> 表示 <code>parentName</code> 新拥有了一个名为 <code>childName</code> 的孩子。</p></li><li><p><code>void death(string name)</code> 表示名为 <code>name</code> 的人死亡。一个人的死亡不会影响 <code>Successor</code> 函数，也不会影响当前的继承顺序。你可以只将这个人标记为死亡状态。</p></li><li><p><code>string[] getInheritanceOrder()</code> 返回 <strong>除去</strong> 死亡人员的当前继承顺序列表。</p></li></ul></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;ThroneInheritance&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;birth&quot;, &quot;getInheritanceOrder&quot;, &quot;death&quot;, &quot;getInheritanceOrder&quot;]</span><br><span class="line">[[&quot;king&quot;], [&quot;king&quot;, &quot;andy&quot;], [&quot;king&quot;, &quot;bob&quot;], [&quot;king&quot;, &quot;catherine&quot;], [&quot;andy&quot;, &quot;matthew&quot;], [&quot;bob&quot;, &quot;alex&quot;], [&quot;bob&quot;, &quot;asha&quot;], [null], [&quot;bob&quot;], [null]]</span><br><span class="line">输出：</span><br><span class="line">[null, null, null, null, null, null, null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;], null, [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">ThroneInheritance t&#x3D; new ThroneInheritance(&quot;king&quot;); &#x2F;&#x2F; 继承顺序：king</span><br><span class="line">t.birth(&quot;king&quot;, &quot;andy&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy</span><br><span class="line">t.birth(&quot;king&quot;, &quot;bob&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; bob</span><br><span class="line">t.birth(&quot;king&quot;, &quot;catherine&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; bob &gt; catherine</span><br><span class="line">t.birth(&quot;andy&quot;, &quot;matthew&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; catherine</span><br><span class="line">t.birth(&quot;bob&quot;, &quot;alex&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; catherine</span><br><span class="line">t.birth(&quot;bob&quot;, &quot;asha&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; matthew &gt; bob &gt; alex &gt; asha &gt; catherine</span><br><span class="line">t.getInheritanceOrder(); &#x2F;&#x2F; 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;bob&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]</span><br><span class="line">t.death(&quot;bob&quot;); &#x2F;&#x2F; 继承顺序：king &gt; andy &gt; matthew &gt; bob（已经去世）&gt; alex &gt; asha &gt; catherine</span><br><span class="line">t.getInheritanceOrder(); &#x2F;&#x2F; 返回 [&quot;king&quot;, &quot;andy&quot;, &quot;matthew&quot;, &quot;alex&quot;, &quot;asha&quot;, &quot;catherine&quot;]</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道哈希算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题只需要注意王位的继承制度是嫡长子继承制即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThroneInheritance</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     * 哈希</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    String kingName;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 此处使用map方便查找</span></span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储过世的人</span></span><br><span class="line">    Set&lt;String&gt; deathSet = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThroneInheritance</span><span class="params">(String kingName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.kingName = kingName;</span><br><span class="line">        map.put(kingName, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">birth</span><span class="params">(String parentName, String childName)</span> </span>&#123;</span><br><span class="line">        map.get(parentName).add(childName);</span><br><span class="line">        map.put(childName, <span class="keyword">new</span> LinkedList&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">death</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        deathSet.add(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getInheritanceOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        dfs(result, kingName);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 深度优先遍历所有人</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; result, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!deathSet.contains(name)) &#123;</span><br><span class="line">            result.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (String subName : map.get(name)) &#123;</span><br><span class="line">            dfs(result, subName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your ThroneInheritance object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * ThroneInheritance obj = new ThroneInheritance(kingName);</span></span><br><span class="line"><span class="comment"> * obj.birth(parentName,childName);</span></span><br><span class="line"><span class="comment"> * obj.death(name);</span></span><br><span class="line"><span class="comment"> * List&lt;String&gt; param_3 = obj.getInheritanceOrder();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>时间效率和空间效率都还行，可见此解法还比较适合此题；</p><p><img src= "/img/loading1.gif" data-lazy-src="https://i.loli.net/2021/06/20/dU19v5a8w4OP2j6.png" alt="image.png"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1600-皇位继承顺序&quot;&gt;&lt;a href=&quot;#力扣-1600-皇位继承顺序&quot; class=&quot;headerlink&quot; title=&quot;力扣 1600. 皇位继承顺序&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="深度优先搜索" scheme="http://zhoushing.github.io/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
</feed>
