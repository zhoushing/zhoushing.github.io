<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ZH&#39;Blog</title>
  
  
  <link href="http://zhoushing.github.io/atom.xml" rel="self"/>
  
  <link href="http://zhoushing.github.io/"/>
  <updated>2022-01-06T09:50:15.703Z</updated>
  <id>http://zhoushing.github.io/</id>
  
  <author>
    <name>Marx</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简化路径</title>
    <link href="http://zhoushing.github.io/2022-01-06-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84.html"/>
    <id>http://zhoushing.github.io/2022-01-06-%E7%AE%80%E5%8C%96%E8%B7%AF%E5%BE%84.html</id>
    <published>2022-01-06T09:42:58.000Z</published>
    <updated>2022-01-06T09:50:15.703Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-71-简化路径"><a href="#力扣-71-简化路径" class="headerlink" title="力扣 71. 简化路径"></a>力扣 <a href="https://leetcode-cn.com/problems/simplify-path/">71. 简化路径</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 path ，表示指向某一文件或目录的 Unix 风格 绝对路径 （以 ‘/‘ 开头），请你将其转化为更加简洁的规范路径。</p><p>在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。任意多个连续的斜杠（即，’//‘）都被视为单个斜杠 ‘/‘ 。 对于此问题，任何其他格式的点（例如，’…’）均被视为文件/目录名称。</p><p>请注意，返回的 规范路径 必须遵循下述格式：</p><ul><li>始终以斜杠 ‘/‘ 开头。</li><li>两个目录名之间必须只有一个斜杠 ‘/‘ 。</li><li>最后一个目录名（如果存在）不能 以 ‘/‘ 结尾。</li><li>此外，路径仅包含从根目录到目标文件或目录的路径上的目录（即，不含 ‘.’ 或 ‘..’）。</li><li>返回简化后得到的 规范路径 。</li></ul><p><strong>提示：</strong></p><ul><li>1 &lt;= path.length &lt;= 3000</li><li>path 由英文字母，数字，’.’，’/‘ 或 ‘_’ 组成。</li><li>path 是一个有效的 Unix 风格绝对路径。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home/&quot;</span><br><span class="line">输出：&quot;/home&quot;</span><br><span class="line">解释：注意，最后一个目录名后面没有斜杠。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/../&quot;</span><br><span class="line">输出：&quot;/&quot;</span><br><span class="line">解释：从根目录向上一级是不可行的，因为根目录是你可以到达的最高级。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/home//foo/&quot;</span><br><span class="line">输出：&quot;/home/foo&quot;</span><br><span class="line">解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：path = &quot;/a/./b/../../c/&quot;</span><br><span class="line">输出：&quot;/c&quot;</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题只需要注意 <code>/</code> 和 <code>.</code> 即可，多个 <code>/</code> 等于一个 <code>/</code> ，所有我们可以将 <code>/</code> 去除将所有字符拆分开来后面再加 <code>/</code>，一个<code>.</code> 代表当前路径，无需改变栈，两个 <code>.</code> 要删除前一个路径，三个及以上 <code>.</code> 实际也视为一个文件名</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 栈</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">simplifyPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] chars = path.toCharArray();</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        StringBuilder temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先将所有非 / 字符拆分出来</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chars[i] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(temp.toString())) &#123;</span><br><span class="line">                    strList.add(temp.toString());</span><br><span class="line">                    temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp.append(chars[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">&quot;&quot;</span>.equals(temp.toString())) &#123;</span><br><span class="line">            strList.add(temp.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 再通过栈后进先出的方式来应对路径变化</span></span><br><span class="line">        Deque&lt;String&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String str: strList) &#123;</span><br><span class="line">            <span class="comment">// 当前路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;.&quot;</span>.equals(str)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 上一级目录</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;..&quot;</span>.equals(str)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!stack.isEmpty()) &#123;</span><br><span class="line">                    stack.removeLast();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.addLast(<span class="string">&quot;/&quot;</span> + str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        temp = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        stack.forEach(temp::append);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 防止有空路径出现</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>.equals(temp.toString())? <span class="string">&quot;/&quot;</span>: temp.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220106174624828.png" alt="image-20220106174624828"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-71-简化路径&quot;&gt;&lt;a href=&quot;#力扣-71-简化路径&quot; class=&quot;headerlink&quot; title=&quot;力扣 71. 简化路径&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/simplify-p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="栈" scheme="http://zhoushing.github.io/tags/%E6%A0%88/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>分数排名</title>
    <link href="http://zhoushing.github.io/2022-01-05-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D.html"/>
    <id>http://zhoushing.github.io/2022-01-05-%E5%88%86%E6%95%B0%E6%8E%92%E5%90%8D.html</id>
    <published>2022-01-05T14:22:24.000Z</published>
    <updated>2022-01-05T14:28:46.814Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-178-分数排名"><a href="#力扣-178-分数排名" class="headerlink" title="力扣 178. 分数排名"></a>力扣 <a href="https://leetcode-cn.com/problems/rank-scores/">178. 分数排名</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Scores (id <span class="type">int</span>, score <span class="type">DECIMAL</span>(<span class="number">3</span>,<span class="number">2</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Scores</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;3.5&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;3.85&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;4.0&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Scores (id, score) <span class="keyword">values</span> (<span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;3.65&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询来实现分数排名。</p><p>如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+----+-------+</span><br><span class="line">| Id | Score |</span><br><span class="line">+----+-------+</span><br><span class="line">| 1  | 3.50  |</span><br><span class="line">| 2  | 3.65  |</span><br><span class="line">| 3  | 4.00  |</span><br><span class="line">| 4  | 3.85  |</span><br><span class="line">| 5  | 4.00  |</span><br><span class="line">| 6  | 3.65  |</span><br><span class="line">+----+-------+</span><br></pre></td></tr></table></figure><p>例如，根据上述给定的 <code>Scores</code> 表，你的查询应该返回（按分数从高到低排列）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">+-------+------+</span><br><span class="line">| Score | Rank |</span><br><span class="line">+-------+------+</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 4.00  | 1    |</span><br><span class="line">| 3.85  | 2    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.65  | 3    |</span><br><span class="line">| 3.50  | 4    |</span><br><span class="line">+-------+------+</span><br></pre></td></tr></table></figure><p><strong>重要提示：</strong>对于 MySQL 解决方案，如果要转义用作列名的保留字，可以在关键字之前和之后使用撇号。例如 <strong><code>Rank</code></strong></p><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为中等题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"># 解法一</span><br><span class="line"><span class="keyword">select</span> Score,(</span><br><span class="line">        # 查询在当前成绩之前的成绩等级有几个</span><br><span class="line">        <span class="keyword">select</span> <span class="built_in">count</span>(<span class="keyword">distinct</span> Score) </span><br><span class="line">        <span class="keyword">from</span> Scores </span><br><span class="line">        # 此处用大于等于方便直接以 <span class="number">1</span> 开始排名</span><br><span class="line">        <span class="keyword">where</span> Score <span class="operator">&gt;=</span> s.Score</span><br><span class="line">    ) <span class="keyword">as</span> `Rank`</span><br><span class="line"><span class="keyword">from</span> Scores s</span><br><span class="line"># 再按照成绩进行降序排序</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span>;</span><br><span class="line"></span><br><span class="line"># 解法二</span><br><span class="line"># MySQL <span class="number">8</span> 支持 DENSE_RANK并列连续排序</span><br><span class="line"># 并列即相同的值，相同的值保留重复名次，遇到下一个不同值时，依然按照连续数字排名。</span><br><span class="line"><span class="keyword">select</span> Score, <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(</span><br><span class="line">        <span class="keyword">order</span> <span class="keyword">by</span> Score <span class="keyword">desc</span></span><br><span class="line">    ) <span class="keyword">as</span> `Rank` </span><br><span class="line"><span class="keyword">from</span> Scores;</span><br></pre></td></tr></table></figure><p>解法一效率：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220105222842315.png" alt="image-20220105222842315"></p><p>解法二效率：</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20220105222733193.png" alt="image-20220105222733193"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-178-分数排名&quot;&gt;&lt;a href=&quot;#力扣-178-分数排名&quot; class=&quot;headerlink&quot; title=&quot;力扣 178. 分数排名&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/rank-sc</summary>
      
    
    
    
    
    <category term="SQL" scheme="http://zhoushing.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>完美数</title>
    <link href="http://zhoushing.github.io/2021-12-31-%E5%AE%8C%E7%BE%8E%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-12-31-%E5%AE%8C%E7%BE%8E%E6%95%B0.html</id>
    <published>2021-12-31T07:09:22.000Z</published>
    <updated>2021-12-31T07:23:00.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-507-完美数"><a href="#力扣-507-完美数" class="headerlink" title="力扣 507. 完美数"></a>力扣 <a href="https://leetcode-cn.com/problems/perfect-number/">507. 完美数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。</p><p>给定一个 整数 n， 如果是完美数，返回 true，否则返回 false</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= num &lt;= 10^8</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 28</span><br><span class="line">输出：true</span><br><span class="line">解释：28 = 1 + 2 + 4 + 7 + 14</span><br><span class="line">1, 2, 4, 7, 和 14 是 28 的所有正因子。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 6</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 496</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 8128</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：num = 2</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题可以直接暴力求解，但是效率比较低，我们可以采用一次消去两个因子的形式，需要注意1不是完美数</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 求因子时我们可以一次计算两个因子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; (<span class="keyword">int</span>) Math.sqrt(num) + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                tick += i;</span><br><span class="line">                <span class="comment">// 排除出现开方因子的可能</span></span><br><span class="line">                <span class="keyword">if</span> (i * i != num) &#123;</span><br><span class="line">                    tick += num / i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tick + 1 是因为还存在 1 这个因子，此外还需要排除 num = 1 的情况</span></span><br><span class="line">        <span class="keyword">return</span> num == tick + <span class="number">1</span> &amp;&amp; num != <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211231152049174.png" alt="image-20211231152049174"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-507-完美数&quot;&gt;&lt;a href=&quot;#力扣-507-完美数&quot; class=&quot;headerlink&quot; title=&quot;力扣 507. 完美数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/perfect-nu</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>一手顺子</title>
    <link href="http://zhoushing.github.io/2021-12-30-%E4%B8%80%E6%89%8B%E9%A1%BA%E5%AD%90.html"/>
    <id>http://zhoushing.github.io/2021-12-30-%E4%B8%80%E6%89%8B%E9%A1%BA%E5%AD%90.html</id>
    <published>2021-12-30T11:54:19.000Z</published>
    <updated>2021-12-30T12:02:32.317Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-846-一手顺子"><a href="#力扣-846-一手顺子" class="headerlink" title="力扣 846. 一手顺子"></a>力扣 <a href="https://leetcode-cn.com/problems/hand-of-straights/">846. 一手顺子</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>Alice 手中有一把牌，她想要重新排列这些牌，分成若干组，使每一组的牌数都是 groupSize ，并且由 groupSize 张连续的牌组成。</p><p>给你一个整数数组 hand 其中 hand[i] 是写在第 i 张牌，和一个整数 groupSize 。如果她可能重新排列这些牌，返回 true ；否则，返回 false 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= hand.length &lt;= 10^4</code></li><li><code>0 &lt;= hand[i] &lt;= 10^9</code></li><li><code>1 &lt;= groupSize &lt;= hand.length</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hand = [1,2,3,6,2,3,4,7,8], groupSize = 3</span><br><span class="line">输出：true</span><br><span class="line">解释：Alice 手中的牌可以被重新排列为 [1,2,3]，[2,3,4]，[6,7,8]。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：hand = [1,2,3,4,5], groupSize = 4</span><br><span class="line">输出：false</span><br><span class="line">解释：Alice 手中的牌无法被重新排列成几个大小为 4 的组。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题可以采用贪心策略，我们将所有数据存进优先队列，如何取一个最小的数，然后再在优先队列中将后面的序列依次筛查即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 优先队列</span></span><br><span class="line"><span class="comment">     * 贪心</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNStraightHand</span><span class="params">(<span class="keyword">int</span>[] hand, <span class="keyword">int</span> groupSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = hand.length;</span><br><span class="line">        <span class="comment">// 特例</span></span><br><span class="line">        <span class="keyword">if</span> (groupSize == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h: hand) &#123;</span><br><span class="line">            queue.add(h);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 取出一个元素作为首元素</span></span><br><span class="line">            <span class="keyword">int</span> first = queue.poll();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 序列删除，如果队列中不包含后序元素则直接返回 false</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; groupSize; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!queue.remove(first + i)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 所有元素排完</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间空间效率都还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211230195948934.png" alt="image-20211230195948934"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-846-一手顺子&quot;&gt;&lt;a href=&quot;#力扣-846-一手顺子&quot; class=&quot;headerlink&quot; title=&quot;力扣 846. 一手顺子&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/hand-of</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="优先队列" scheme="http://zhoushing.github.io/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
    <category term="贪心" scheme="http://zhoushing.github.io/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>统计特殊四元组</title>
    <link href="http://zhoushing.github.io/2021-12-29-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84.html"/>
    <id>http://zhoushing.github.io/2021-12-29-%E7%BB%9F%E8%AE%A1%E7%89%B9%E6%AE%8A%E5%9B%9B%E5%85%83%E7%BB%84.html</id>
    <published>2021-12-29T13:28:13.000Z</published>
    <updated>2021-12-29T13:32:57.105Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1995-统计特殊四元组"><a href="#力扣-1995-统计特殊四元组" class="headerlink" title="力扣 1995. 统计特殊四元组"></a>力扣 <a href="https://leetcode-cn.com/problems/count-special-quadruplets/">1995. 统计特殊四元组</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个 下标从 0 开始 的整数数组 nums ，返回满足下述条件的 不同 四元组 (a, b, c, d) 的 数目 ：</p><ul><li>nums[a] + nums[b] + nums[c] == nums[d] ，且</li><li>a &lt; b &lt; c &lt; d</li></ul><p><strong>提示：</strong></p><ul><li><code>4 &lt;= nums.length &lt;= 50</code></li><li><code>1 &lt;= nums[i] &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,6]</span><br><span class="line">输出：1</span><br><span class="line">解释：满足要求的唯一一个四元组是 (0, 1, 2, 3) 因为 1 + 2 + 3 == 6 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3,6,4,5]</span><br><span class="line">输出：0</span><br><span class="line">解释：[3,3,6,4,5] 中不存在满足要求的四元组。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,3,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：满足要求的 4 个四元组如下：</span><br><span class="line">- (0, 1, 2, 3): 1 + 1 + 1 == 3</span><br><span class="line">- (0, 1, 3, 4): 1 + 1 + 3 == 5</span><br><span class="line">- (0, 2, 3, 4): 1 + 1 + 3 == 5</span><br><span class="line">- (1, 2, 3, 4): 1 + 1 + 3 == 5</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题简单在数据范围，可以直接用多重for循环暴力求解，我们在这里采用哈希表+双重for循环的形式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 哈希表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// 本题中看似是四个数的查找，其实我们将等式移动一下不难发现</span></span><br><span class="line">    <span class="comment">// a + b = d - c</span></span><br><span class="line">    <span class="comment">// 这样我们就可以利用哈希表从后向前记录 d - c 的可能</span></span><br><span class="line">    <span class="comment">// 同时利用 b 当中轴，如何向前遍历 a</span></span><br><span class="line">    <span class="comment">// 这样原来的四重 for 循环就变成双重循环了</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countQuadruplets</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> n = nums.length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此处将 b 作为中轴向前寻找 a，向后寻找 d - c</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = n - <span class="number">3</span>; b &gt;= <span class="number">1</span>; b--) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> d = b + <span class="number">2</span>; d &lt; n; d++) &#123;</span><br><span class="line">                temp = nums[d] - nums[b + <span class="number">1</span>];</span><br><span class="line">                map.put(temp, map.getOrDefault(temp, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a &lt; b; a++) &#123;</span><br><span class="line">                temp = nums[a] + nums[b];</span><br><span class="line">                result += map.getOrDefault(temp, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间效率还行，空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211229213115217.png" alt="image-20211229213115217"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1995-统计特殊四元组&quot;&gt;&lt;a href=&quot;#力扣-1995-统计特殊四元组&quot; class=&quot;headerlink&quot; title=&quot;力扣 1995. 统计特殊四元组&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="http://zhoushing.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>第二高的薪水</title>
    <link href="http://zhoushing.github.io/2021-12-28-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4.html"/>
    <id>http://zhoushing.github.io/2021-12-28-%E7%AC%AC%E4%BA%8C%E9%AB%98%E7%9A%84%E8%96%AA%E6%B0%B4.html</id>
    <published>2021-12-28T03:31:58.000Z</published>
    <updated>2021-12-28T03:34:36.111Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-176-第二高的薪水"><a href="#力扣-176-第二高的薪水" class="headerlink" title="力扣 176. 第二高的薪水"></a>力扣 <a href="https://leetcode-cn.com/problems/second-highest-salary/">176. 第二高的薪水</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Employee (id <span class="type">int</span>, salary <span class="type">int</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Employee</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;100&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;200&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Employee (id, salary) <span class="keyword">values</span> (<span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;300&#x27;</span>)</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，获取 <code>Employee</code> 表中第二高的薪水（Salary） 。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+--------+</span><br><span class="line">| Id | Salary |</span><br><span class="line">+----+--------+</span><br><span class="line">| 1  | 100    |</span><br><span class="line">| 2  | 200    |</span><br><span class="line">| 3  | 300    |</span><br><span class="line">+----+--------+</span><br></pre></td></tr></table></figure><p>例如上述 <code>Employee</code> 表，SQL查询应该返回 <code>200</code> 作为第二高的薪水。如果不存在第二高的薪水，那么查询应返回 <code>null</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+---------------------+</span><br><span class="line">| SecondHighestSalary |</span><br><span class="line">+---------------------+</span><br><span class="line">| 200                 |</span><br><span class="line">+---------------------+</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为中等题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"># 外层嵌套循环来实现题目要求的 &quot;如果不存在第二高的薪水，那么查询应返回 null&quot;</span><br><span class="line"><span class="keyword">select</span> (</span><br><span class="line">    # 因为薪水可能出现重复的，所以这里采用 <span class="keyword">distinct</span> 来取薪水的唯一值</span><br><span class="line">    <span class="keyword">select</span> <span class="keyword">distinct</span> salary </span><br><span class="line">    <span class="keyword">from</span> Employee </span><br><span class="line">    # 获取第二高，所以采用 <span class="keyword">order</span> <span class="keyword">by</span> 进行排序，且采用 <span class="keyword">desc</span> 降序排序</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span></span><br><span class="line">    # 取第二条数据（<span class="number">1</span>, <span class="number">1</span> 表示从第 <span class="number">2</span> 条数据开始取一条数据，MySQL 数据第 <span class="number">0</span> 行才是第 <span class="number">1</span> 条数据）</span><br><span class="line">    limit <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">) </span><br><span class="line"><span class="keyword">as</span> SecondHighestSalary</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211228113424399.png" alt="image-20211228113424399"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-176-第二高的薪水&quot;&gt;&lt;a href=&quot;#力扣-176-第二高的薪水&quot; class=&quot;headerlink&quot; title=&quot;力扣 176. 第二高的薪水&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/s</summary>
      
    
    
    
    
    <category term="SQL" scheme="http://zhoushing.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>适龄的朋友</title>
    <link href="http://zhoushing.github.io/2021-12-27-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B.html"/>
    <id>http://zhoushing.github.io/2021-12-27-%E9%80%82%E9%BE%84%E7%9A%84%E6%9C%8B%E5%8F%8B.html</id>
    <published>2021-12-27T15:31:33.000Z</published>
    <updated>2021-12-27T15:40:51.103Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-825-适龄的朋友"><a href="#力扣-825-适龄的朋友" class="headerlink" title="力扣 825. 适龄的朋友"></a>力扣 <a href="https://leetcode-cn.com/problems/friends-of-appropriate-ages/">825. 适龄的朋友</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>在社交媒体网站上有 n 个用户。给你一个整数数组 ages ，其中 ages[i] 是第 i 个用户的年龄。</p><p>如果下述任意一个条件为真，那么用户 x 将不会向用户 y（x != y）发送好友请求：</p><ul><li>age[y] &lt;= 0.5 * age[x] + 7</li><li>age[y] &gt; age[x]</li><li>age[y] &gt; 100 &amp;&amp; age[x] &lt; 100<br>否则，x 将会向 y 发送一条好友请求。</li></ul><p>注意，如果 x 向 y 发送一条好友请求，y 不必也向 x 发送一条好友请求。另外，用户不会向自己发送好友请求。</p><p>返回在该社交媒体网站上产生的好友请求总数。</p><p><strong>提示：</strong></p><ul><li><code>n == ages.length</code></li><li><code>1 &lt;= n &lt;= 2 * 10^4</code></li><li><code>1 &lt;= ages[i] &lt;= 120</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [16,16]</span><br><span class="line">输出：2</span><br><span class="line">解释：2 人互发好友请求。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [16,17,18]</span><br><span class="line">输出：2</span><br><span class="line">解释：产生的好友请求为 17 -&gt; 16 ，18 -&gt; 17 。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：ages = [20,30,100,110,120]</span><br><span class="line">输出：3</span><br><span class="line">解释：产生的好友请求为 110 -&gt; 100 ，120 -&gt; 110 ，120 -&gt; 100 。</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们可以先对数组进行排序，然后根据题目两个约束（虽然是三个条件，但实际符合前两个条件即可），用双指针来寻找符合条件的区间</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numFriendRequests</span><span class="params">(<span class="keyword">int</span>[] ages)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = ages.length;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(ages);</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 此时 age 是 ages[x]</span></span><br><span class="line">        <span class="comment">// 要寻找符合条件的 ages[y] 区间</span></span><br><span class="line">        <span class="comment">// 因为随着 ages[x] 的变大，ages[y] 左右区间也是向后偏移的，</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> age : ages) &#123;</span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当 ages[x] &lt; 15 时，找不到符合条件的 ages[y]</span></span><br><span class="line">            <span class="keyword">if</span> (age &lt; <span class="number">15</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配对的左区间</span></span><br><span class="line">            <span class="keyword">while</span> (ages[left] &lt;= <span class="number">0.5</span> * age + <span class="number">7</span>) &#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 配对的右区间</span></span><br><span class="line">            <span class="keyword">while</span> (right &lt; n - <span class="number">1</span> &amp;&amp; ages[right + <span class="number">1</span>] &lt;= age) &#123;</span><br><span class="line">                right++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 累加这个区间</span></span><br><span class="line">            result += right - left;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211227233415373.png" alt="image-20211227233415373"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-825-适龄的朋友&quot;&gt;&lt;a href=&quot;#力扣-825-适龄的朋友&quot; class=&quot;headerlink&quot; title=&quot;力扣 825. 适龄的朋友&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/frie</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>组合两个表</title>
    <link href="http://zhoushing.github.io/2021-12-27-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8.html"/>
    <id>http://zhoushing.github.io/2021-12-27-%E7%BB%84%E5%90%88%E4%B8%A4%E4%B8%AA%E8%A1%A8.html</id>
    <published>2021-12-27T03:25:31.000Z</published>
    <updated>2021-12-28T03:31:32.380Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-175-组合两个表"><a href="#力扣-175-组合两个表" class="headerlink" title="力扣 175. 组合两个表"></a>力扣 <a href="https://leetcode-cn.com/problems/combine-two-tables/">175. 组合两个表</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><blockquote><p>SQL架构</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Person (personId <span class="type">int</span>, firstName <span class="type">varchar</span>(<span class="number">255</span>), lastName <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Create</span> <span class="keyword">table</span> If <span class="keyword">Not</span> <span class="keyword">Exists</span> Address (addressId <span class="type">int</span>, personId <span class="type">int</span>, city <span class="type">varchar</span>(<span class="number">255</span>), state <span class="type">varchar</span>(<span class="number">255</span>))</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Person</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>, <span class="string">&#x27;Allen&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Person (personId, lastName, firstName) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line"><span class="keyword">Truncate</span> <span class="keyword">table</span> Address</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;New York City&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Address (addressId, personId, city, state) <span class="keyword">values</span> (<span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;Leetcode&#x27;</span>, <span class="string">&#x27;California&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><p>表1: Person</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型     |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| FirstName   | varchar |</span><br><span class="line">| LastName    | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">PersonId 是上表主键</span><br></pre></td></tr></table></figure></li><li><p>表2: Address</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-------------+---------+</span><br><span class="line">| 列名         | 类型    |</span><br><span class="line">+-------------+---------+</span><br><span class="line">| AddressId   | int     |</span><br><span class="line">| PersonId    | int     |</span><br><span class="line">| City        | varchar |</span><br><span class="line">| State       | varchar |</span><br><span class="line">+-------------+---------+</span><br><span class="line">AddressId 是上表主键</span><br></pre></td></tr></table></figure><p>编写一个 SQL 查询，满足条件：无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息：</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FirstName, LastName, City, State</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道SQL算法问题，在力扣题库中被定义为简单题。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Write your MySQL query statement below</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> FirstName, LastName, City, State </span><br><span class="line"># 题目要求：&quot;无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息&quot;</span><br><span class="line"># 所以在此处选择 Person 表左连接 Address 表，保证将所有 Person 表的数据都查询出来</span><br><span class="line"><span class="keyword">from</span> Person <span class="keyword">left</span> <span class="keyword">join</span> Address </span><br><span class="line"># 两表连接数据的筛选条件</span><br><span class="line"><span class="keyword">on</span> Person.PersonId <span class="operator">=</span> Address.PersonId</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211228113055962.png" alt="image-20211228113055962"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-175-组合两个表&quot;&gt;&lt;a href=&quot;#力扣-175-组合两个表&quot; class=&quot;headerlink&quot; title=&quot;力扣 175. 组合两个表&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/comb</summary>
      
    
    
    
    
    <category term="SQL" scheme="http://zhoushing.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>奇偶树</title>
    <link href="http://zhoushing.github.io/2021-12-25-%E5%A5%87%E5%81%B6%E6%A0%91.html"/>
    <id>http://zhoushing.github.io/2021-12-25-%E5%A5%87%E5%81%B6%E6%A0%91.html</id>
    <published>2021-12-25T02:14:24.000Z</published>
    <updated>2021-12-25T16:19:54.082Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1609-奇偶树"><a href="#力扣-1609-奇偶树" class="headerlink" title="力扣 1609. 奇偶树"></a>力扣 <a href="https://leetcode-cn.com/problems/even-odd-tree/">1609. 奇偶树</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>如果一棵二叉树满足下述几个条件，则可以称为 奇偶树 ：</p><p>二叉树根节点所在层下标为 0 ，根的子节点所在层下标为 1 ，根的孙节点所在层下标为 2 ，依此类推。<br>偶数下标 层上的所有节点的值都是 奇 整数，从左到右按顺序 严格递增<br>奇数下标 层上的所有节点的值都是 偶 整数，从左到右按顺序 严格递减<br>给你二叉树的根节点，如果二叉树为 奇偶树 ，则返回 true ，否则返回 false 。</p><p><strong>提示：</strong></p><ul><li>树中节点数在范围 <code>[1, 10^5]</code> 内</li><li><code>1 &lt;= Node.val &lt;= 10^6</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_1_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,10,4,3,null,7,9,12,8,6,null,null,2]</span><br><span class="line">输出：true</span><br><span class="line">解释：每一层的节点值分别是：</span><br><span class="line">0 层：[1]</span><br><span class="line">1 层：[10,4]</span><br><span class="line">2 层：[3,7,9]</span><br><span class="line">3 层：[12,8,6,2]</span><br><span class="line">由于 0 层和 2 层上的节点值都是奇数且严格递增，而 1 层和 3 层上的节点值都是偶数且严格递减，因此这是一棵奇偶树。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_2_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,2,3,3,7]</span><br><span class="line">输出：false</span><br><span class="line">解释：每一层的节点值分别是：</span><br><span class="line">0 层：[5]</span><br><span class="line">1 层：[4,2]</span><br><span class="line">2 层：[3,3,7]</span><br><span class="line">2 层上的节点值不满足严格递增的条件，所以这不是一棵奇偶树。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagessample_1_333_1966.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,9,1,3,5,7]</span><br><span class="line">输出：false</span><br><span class="line">解释：1 层上的节点值应为偶数。</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [11,8,6,1,3,9,11,30,20,18,16,12,10,4,2,17]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们直接层序遍历如何判断每层即可，不过读者切记需要判断是否“严格”递增</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 层序遍历</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEvenOddTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 根节点非奇节点</span></span><br><span class="line">        <span class="keyword">if</span> ((root.val &amp; <span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.offer(root.left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.offer(root.right);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> tick = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = stack.size();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> last = -<span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode node = stack.pop();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offer(node.left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    stack.offer(node.right);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> num = node.val;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 奇偶性错误</span></span><br><span class="line">                <span class="keyword">if</span> ((num &amp; <span class="number">1</span>) != tick) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 首元素</span></span><br><span class="line">                <span class="keyword">if</span> (last == -<span class="number">1</span>) &#123;</span><br><span class="line">                    last = num;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 和上一个数相等代表非严格递增或者递减</span></span><br><span class="line">                <span class="keyword">if</span> (num == last) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 增减性错误</span></span><br><span class="line">                <span class="keyword">int</span> count = num &gt; last? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (count != tick) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                last = num;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            tick = (tick + <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211226001854590.png" alt="image-20211226001854590"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1609-奇偶树&quot;&gt;&lt;a href=&quot;#力扣-1609-奇偶树&quot; class=&quot;headerlink&quot; title=&quot;力扣 1609. 奇偶树&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/even-od</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="层序遍历" scheme="http://zhoushing.github.io/tags/%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>重复叠加字符串匹配</title>
    <link href="http://zhoushing.github.io/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html"/>
    <id>http://zhoushing.github.io/2021-12-22-%E9%87%8D%E5%A4%8D%E5%8F%A0%E5%8A%A0%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D.html</id>
    <published>2021-12-22T15:41:38.000Z</published>
    <updated>2021-12-22T15:44:42.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-686-重复叠加字符串匹配"><a href="#力扣-686-重复叠加字符串匹配" class="headerlink" title="力扣 686. 重复叠加字符串匹配"></a>力扣 <a href="https://leetcode-cn.com/problems/repeated-string-match/">686. 重复叠加字符串匹配</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。</p><p>注意：字符串 “abc” 重复叠加 0 次是 “”，重复叠加 1 次是 “abc”，重复叠加 2 次是 “abcabc”。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= a.length &lt;= 10^4</code></li><li><code>1 &lt;= b.length &lt;= 10^4</code></li><li><code>a</code> 和 <code>b</code> 由小写英文字母组成</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abcd&quot;, b = &quot;cdabcdab&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：a 重复叠加三遍后为 &quot;abcdabcdabcd&quot;, 此时 b 是其子串。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;aa&quot;</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;a&quot;, b = &quot;a&quot;</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：a = &quot;abc&quot;, b = &quot;wxyz&quot;</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中我们只需要知道字符串a重复可能的上界即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 二分查找</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">repeatedStringMatch</span><span class="params">(String a, String b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sizeA = a.length();</span><br><span class="line">        <span class="keyword">int</span> sizeB = b.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 最少可能情况 a 包含 b</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 最大可能 a 重复 sizeB / sizeA 次，再在首位各自加一个</span></span><br><span class="line">        <span class="keyword">int</span> right = sizeB / sizeA + <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mid; i++) &#123;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!sb.toString().contains(b)) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">                sb.append(a);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> !sb.toString().contains(b)? -<span class="number">1</span>: left;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211222234404914.png" alt="image-20211222234404914"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-686-重复叠加字符串匹配&quot;&gt;&lt;a href=&quot;#力扣-686-重复叠加字符串匹配&quot; class=&quot;headerlink&quot; title=&quot;力扣 686. 重复叠加字符串匹配&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/p</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二分查找" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>一年中的第几天</title>
    <link href="http://zhoushing.github.io/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html"/>
    <id>http://zhoushing.github.io/2021-12-21-%E4%B8%80%E5%B9%B4%E4%B8%AD%E7%9A%84%E7%AC%AC%E5%87%A0%E5%A4%A9.html</id>
    <published>2021-12-21T07:16:42.000Z</published>
    <updated>2021-12-21T07:19:24.517Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1154-一年中的第几天"><a href="#力扣-1154-一年中的第几天" class="headerlink" title="力扣 1154. 一年中的第几天"></a>力扣 <a href="https://leetcode-cn.com/problems/day-of-the-year/">1154. 一年中的第几天</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 date ，按 YYYY-MM-DD 格式表示一个 现行公元纪年法 日期。请你计算并返回该日期是当年的第几天。</p><p>通常情况下，我们认为 1 月 1 日是每年的第 1 天，1 月 2 日是每年的第 2 天，依此类推。每个月的天数与现行公元纪年法（格里高利历）一致。</p><p><strong>提示：</strong></p><ul><li>date.length == 10</li><li>date[4] == date[7] == ‘-‘，其他的 date[i] 都是数字</li><li>date 表示的范围从 1900 年 1 月 1 日至 2019 年 12 月 31 日</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-01-09&quot;</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2019-02-10&quot;</span><br><span class="line">输出：41</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2003-03-01&quot;</span><br><span class="line">输出：60</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：date = &quot;2004-03-01&quot;</span><br><span class="line">输出：61</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题思路比较简单，直接计算即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每个月份的前置天数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span>[] counts = &#123;<span class="number">0</span>, <span class="number">31</span>, <span class="number">28</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前缀和计算好这个月之前过去了多少天</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; counts.length; i++) &#123;</span><br><span class="line">            counts[i] += counts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">dayOfYear</span><span class="params">(String date)</span> </span>&#123;</span><br><span class="line">        String[] temp = date.split(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> year = Integer.parseInt(temp[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> mouth = Integer.parseInt(temp[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">int</span> day = Integer.parseInt(temp[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 年份为闰年且月份在二月之后预先加上一天</span></span><br><span class="line">        <span class="keyword">int</span> result = (judge(year) &amp;&amp; mouth &gt; <span class="number">2</span>)? <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        result += counts[mouth - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        result += day;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前年份是否是闰年</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> year 年份</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 是闰年则返回 true，反之 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> year)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  (year % <span class="number">100</span> != <span class="number">0</span> &amp;&amp; year % <span class="number">4</span> == <span class="number">0</span>) || (year % <span class="number">400</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211221151847237.png" alt="image-20211221151847237"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1154-一年中的第几天&quot;&gt;&lt;a href=&quot;#力扣-1154-一年中的第几天&quot; class=&quot;headerlink&quot; title=&quot;力扣 1154. 一年中的第几天&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/prob</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>供暖器</title>
    <link href="http://zhoushing.github.io/2021-12-20-%E4%BE%9B%E6%9A%96%E5%99%A8.html"/>
    <id>http://zhoushing.github.io/2021-12-20-%E4%BE%9B%E6%9A%96%E5%99%A8.html</id>
    <published>2021-12-20T13:50:18.000Z</published>
    <updated>2021-12-20T13:54:52.872Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-475-供暖器"><a href="#力扣-475-供暖器" class="headerlink" title="力扣 475. 供暖器"></a>力扣 <a href="https://leetcode-cn.com/problems/heaters/">475. 供暖器</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</p><p>在加热器的加热半径范围内的每个房屋都可以获得供暖。</p><p>现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置，请你找出并返回可以覆盖所有房屋的最小加热半径。</p><p>说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= houses.length, heaters.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= houses[i], heaters[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3], heaters = [2]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 仅在位置2上有一个供暖器。如果我们将加热半径设为1，那么所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: houses = [1,2,3,4], heaters = [1,4]</span><br><span class="line">输出: 1</span><br><span class="line">解释: 在位置1, 4上有两个供暖器。我们需要将加热半径设为1，这样所有房屋就都能得到供暖。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：houses = [1,5], heaters = [2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题中的每个房子使用的供暖不是前一个供暖器就是后一个，所以我们只需要遍历每个屋子并判断即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * TreeSet</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findRadius</span><span class="params">(<span class="keyword">int</span>[] houses, <span class="keyword">int</span>[] heaters)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 采用 TreeSet 来存储供暖器的位置，方便取得房屋前后取暖器的位置</span></span><br><span class="line">        TreeSet&lt;Integer&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> heater: heaters) &#123;</span><br><span class="line">            set.add(heater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> house: houses) &#123;</span><br><span class="line">            <span class="comment">// floor：取得当前 TreeSet 中小于等于当前元素的最大值</span></span><br><span class="line">            Integer low = set.floor(house);</span><br><span class="line">            <span class="comment">// floor：取得当前 TreeSet 中大于等于当前元素的最小值</span></span><br><span class="line">            Integer high = set.ceiling(house);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (low == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = Math.max(result, high - house);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (high == <span class="keyword">null</span>) &#123;</span><br><span class="line">                result = Math.max(result, house - low);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                result = Math.max(result, Math.min((high - house), (house - low)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率一般，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/blog_imagesimage-20211220215307575.png" alt="image-20211220215307575"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-475-供暖器&quot;&gt;&lt;a href=&quot;#力扣-475-供暖器&quot; class=&quot;headerlink&quot; title=&quot;力扣 475. 供暖器&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/heaters/&quot;&gt;</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="TreeSet" scheme="http://zhoushing.github.io/tags/TreeSet/"/>
    
  </entry>
  
  <entry>
    <title>找到小镇的法官</title>
    <link href="http://zhoushing.github.io/2021-12-19-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98.html"/>
    <id>http://zhoushing.github.io/2021-12-19-%E6%89%BE%E5%88%B0%E5%B0%8F%E9%95%87%E7%9A%84%E6%B3%95%E5%AE%98.html</id>
    <published>2021-12-19T13:24:20.000Z</published>
    <updated>2021-12-19T14:12:53.386Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-997-找到小镇的法官"><a href="#力扣-997-找到小镇的法官" class="headerlink" title="力扣 997. 找到小镇的法官"></a>力扣 <a href="https://leetcode-cn.com/problems/find-the-town-judge/">997. 找到小镇的法官</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>在一个小镇里，按从 1 到 n 为 n 个人进行编号。传言称，这些人中有一个是小镇上的秘密法官。</p><p>如果小镇的法官真的存在，那么：</p><p>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足条件 1 和条件 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示编号为 a 的人信任编号为 b 的人。</p><p>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的编号。否则，返回 -1。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, trust = [[1,2]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,3],[2,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,3],[2,3],[3,1]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3, trust = [[1,2],[2,3]]</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p><strong>示例 5:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题不会出现某个人信任自己的情况，所以我们统计每个人信任和被信任的情况即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findJudge</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span>[][] trust)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = -<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 相信过几个人</span></span><br><span class="line">        <span class="keyword">int</span>[] tru = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 被几个人相信</span></span><br><span class="line">        <span class="keyword">int</span>[] beTru = <span class="keyword">new</span> <span class="keyword">int</span> [n + <span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>[] temp: trust) &#123;</span><br><span class="line">            tru[temp[<span class="number">0</span>]]++;</span><br><span class="line">            beTru[temp[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 当此人被其他所有人信任且不信任别人</span></span><br><span class="line">            <span class="comment">// 即可假定其是秘密法官</span></span><br><span class="line">            <span class="keyword">if</span> (beTru[i] == n - <span class="number">1</span> &amp;&amp; tru[i] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    result = i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 多于一人时说明无法确定</span></span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211219220721029.png" alt="image-20211219220721029"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-997-找到小镇的法官&quot;&gt;&lt;a href=&quot;#力扣-997-找到小镇的法官&quot; class=&quot;headerlink&quot; title=&quot;力扣 997. 找到小镇的法官&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>甲板上的战舰</title>
    <link href="http://zhoushing.github.io/2021-12-18-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0.html"/>
    <id>http://zhoushing.github.io/2021-12-18-%E7%94%B2%E6%9D%BF%E4%B8%8A%E7%9A%84%E6%88%98%E8%88%B0.html</id>
    <published>2021-12-18T03:20:54.000Z</published>
    <updated>2021-12-18T04:19:09.745Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-419-甲板上的战舰"><a href="#力扣-419-甲板上的战舰" class="headerlink" title="力扣 419. 甲板上的战舰"></a>力扣 <a href="https://leetcode-cn.com/problems/battleships-in-a-board/">419. 甲板上的战舰</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个大小为 m x n 的矩阵 board 表示甲板，其中，每个单元格可以是一艘战舰 ‘X’ 或者是一个空位 ‘.’ ，返回在甲板 board 上放置的 战舰 的数量。</p><p>战舰 只能水平或者垂直放置在 board 上。换句话说，战舰只能按 1 x k（1 行，k 列）或 k x 1（k 行，1 列）的形状建造，其中 k 可以是任意大小。两艘战舰之间至少有一个水平或垂直的空位分隔 （即没有相邻的战舰）。</p><p><strong>提示：</strong></p><ul><li><code>m == board.length</code></li><li><code>n == board[i].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>board[i][j]</code> 是 <code>&#39;.&#39;</code> 或 <code>&#39;X&#39;</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/battelship-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;X&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;],[&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;X&quot;]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;.&quot;]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题我们只需按照左上角计算战舰即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * DFS</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countBattleships</span><span class="params">(<span class="keyword">char</span>[][] board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[][] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ticks[i][j] &amp;&amp; board[i][j] == <span class="string">&#x27;X&#x27;</span>) &#123;</span><br><span class="line">                    <span class="comment">// 只统计左上角</span></span><br><span class="line">                    result++;</span><br><span class="line">                    tick(board, ticks, i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tick</span><span class="params">(<span class="keyword">char</span>[][] board, <span class="keyword">boolean</span>[][] ticks, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.length;</span><br><span class="line">        <span class="keyword">int</span> n = board[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 越界或者为空地则回退</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt;= m || j &gt;= n || board[i][j] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ticks[i][j] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 只向下向右判断</span></span><br><span class="line">        tick(board, ticks, i + <span class="number">1</span>, j);</span><br><span class="line">        tick(board, ticks, i, j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211218115423092.png" alt="image-20211218115423092"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-419-甲板上的战舰&quot;&gt;&lt;a href=&quot;#力扣-419-甲板上的战舰&quot; class=&quot;headerlink&quot; title=&quot;力扣 419. 甲板上的战舰&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/b</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="广度优先搜索" scheme="http://zhoushing.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>换酒问题</title>
    <link href="http://zhoushing.github.io/2021-12-17-%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98.html"/>
    <id>http://zhoushing.github.io/2021-12-17-%E6%8D%A2%E9%85%92%E9%97%AE%E9%A2%98.html</id>
    <published>2021-12-17T12:46:26.000Z</published>
    <updated>2021-12-17T12:59:37.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-1518-换酒问题"><a href="#力扣-1518-换酒问题" class="headerlink" title="力扣 1518. 换酒问题"></a>力扣 <a href="https://leetcode-cn.com/problems/water-bottles/">1518. 换酒问题</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>小区便利店正在促销，用 numExchange 个空酒瓶可以兑换一瓶新酒。你购入了 numBottles 瓶酒。</p><p>如果喝掉了酒瓶中的酒，那么酒瓶就会变成空的。</p><p>请你计算 最多 能喝到多少瓶酒。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= numBottles &lt;= 100</code></li><li><code>2 &lt;= numExchange &lt;= 100</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/sample_1_1875.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 9, numExchange = 3</span><br><span class="line">输出：13</span><br><span class="line">解释：你可以用 3 个空酒瓶兑换 1 瓶酒。</span><br><span class="line">所以最多能喝到 9 + 3 + 1 = 13 瓶酒。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/sample_2_1875.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 15, numExchange = 4</span><br><span class="line">输出：19</span><br><span class="line">解释：你可以用 4 个空酒瓶兑换 1 瓶酒。</span><br><span class="line">所以最多能喝到 15 + 3 + 1 = 19 瓶酒。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 5, numExchange = 5</span><br><span class="line">输出：6</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：numBottles = 2, numExchange = 3</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数学算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现此题我们直接模拟换算的过程即可</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数学</span></span><br><span class="line"><span class="comment">     * 模拟</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">numWaterBottles</span><span class="params">(<span class="keyword">int</span> numBottles, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (numBottles &lt; numExchange) &#123;</span><br><span class="line">            <span class="keyword">return</span> numBottles;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count(numBottles, <span class="number">0</span>, numExchange);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * now: 现在拥有的酒数</span></span><br><span class="line"><span class="comment">     * preRemain: 上次剩下的酒瓶子数</span></span><br><span class="line"><span class="comment">     * numExchange: 交换比例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> preRemain, <span class="keyword">int</span> numExchange)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = now;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((now + preRemain) &gt;= numExchange) &#123;</span><br><span class="line">            <span class="comment">// 酒瓶交换的酒数</span></span><br><span class="line">            <span class="keyword">int</span> exchangeNum = (now + preRemain) / numExchange;</span><br><span class="line">            <span class="comment">// 交换剩下的酒瓶数</span></span><br><span class="line">            <span class="keyword">int</span> remain = (now + preRemain) % numExchange;</span><br><span class="line">            result += count(exchangeNum, remain, numExchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211217205854842.png" alt="image-20211217205854842"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的每日一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-1518-换酒问题&quot;&gt;&lt;a href=&quot;#力扣-1518-换酒问题&quot; class=&quot;headerlink&quot; title=&quot;力扣 1518. 换酒问题&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/wate</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数学" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E5%AD%A6/"/>
    
    <category term="模拟" scheme="http://zhoushing.github.io/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>后端仔如何优雅的写前端（一）</title>
    <link href="http://zhoushing.github.io/2021-11-27-%E5%90%8E%E7%AB%AF%E4%BB%94%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89.html"/>
    <id>http://zhoushing.github.io/2021-11-27-%E5%90%8E%E7%AB%AF%E4%BB%94%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%86%99%E5%89%8D%E7%AB%AF%EF%BC%88%E4%B8%80%EF%BC%89.html</id>
    <published>2021-11-27T08:38:45.000Z</published>
    <updated>2021-11-28T02:48:25.963Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>​    无论是在生产或者学习中，我们后端开发人员（以下简称为后端仔），总是离不开和前端打交道，甚至在某些迫不得已的时候，我们也需要挺身而出靠自己的能力编写前端。此篇文章仅根据笔者自己的理解加一些的实际编写经验，适合对前端想要了解或者是来要做项目抱佛脚的后端仔。</p><p>​    我相信很多小伙伴其实和笔者一样，都是接触后端语言，类似于c++、java等入门的，各大高校的课程通常没有直接教学并实战前端的，所以在这里我先从前端的介绍开始逐步给大家展示如何上手前端。在本篇中主要是对前端的情况以及发展历史做一些介绍，不感兴趣的读者可以直接转看下一篇，但还是<strong>建议读者粗略的看一眼，只需注意加粗的部分即可，这关系到我们后面上手时所用的技术或语言</strong>。</p><h2 id="前端的介绍"><a href="#前端的介绍" class="headerlink" title="前端的介绍"></a>前端的介绍</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​    <strong>前端</strong>（英语：<strong>front-end</strong>）和<strong>后端</strong>（英语：<strong>back-end</strong>）是描述进程开始和结束的通用词汇。前端作用于采集输入信息，后端进行处理。计算机程序的<a href="https://zh.wikipedia.org/wiki/%E7%95%8C%E9%9D%A2">界面</a>样式，视觉呈现属于前端。在<a href="https://zh.wikipedia.org/wiki/%E8%BB%9F%E9%AB%94%E6%9E%B6%E6%A7%8B">软体架构</a>和<a href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1">程序设计</a>领域，前端是软体系统中直接和用户交互的部分，而后端控制着软件的输出。说白了在通常的项目和工程中，直接展示给用户，可以直接与用户进行交互的部分，例如一个网站项目中的<strong>HTML</strong>、<strong>CSS</strong>等负责展示的部分，<strong>JavaScript</strong>等负责交互的部分都属于<strong>前端</strong>；而与数据库中的数据进行交互，在用户看不见的地方进行数据处理的部分，例如<strong>c++、Java</strong>等部分都属于<strong>后端</strong>。</p><h3 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h3><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211127210505274.png" alt="image-20211127210505274"></p><p>我们可以看到从1990HTML问世以来，前端的发展已经经历了许多扩展和尝试了，在这其中有几个重要的节点，其中提到的名词可能大家都听说或者了解过。</p><p>1990 年，Tim 以超文本语言 HTML 为基础在 NeXT 电脑上发明了最原始的 <strong>Web 浏览器</strong>。</p><p>1994 年底，由 Tim 牵头的万维网联盟（World Wide Web Consortium）也就是 <strong>W3C</strong> 成立，这标志着万维网的正式诞生。此时的网页以 HTML 为主，是纯静态的网页，网页是“只读”的，信息流只能通过服务器到客户端单向流通，由此世界进入了 Web 1.0 时代。</p><p>1995 年，网景工程师 Brendan Eich 花了10天时间设计了 <strong>JavaScript</strong> 语言。起初这种<strong>脚本语言</strong>叫做 Mocha，后改名 LiveScript，后来为了借助 Java 语言创造良好的营销效果最终改名为 JavaScript。网景公司把这种脚本语言嵌入到了 Navigator 2.0 之中，使其能在浏览器中运行。</p><p>与此相对的是，1996 年，微软发布了 VBScript 和 JScript。JScript 是对 JavaScript 进行逆向工程的实现，并内置于 Internet Explorer 3 中。但是 JavaScript 与 JScript 两种语言的实现存在差别，这导致了程序员开发的网页不能同时兼容 Navigator 和 Internet Explorer 浏览器。 <strong>I</strong>nternet <strong>E</strong>xplorer 开始抢夺 Netscape 的市场份额，这导致了第一次浏览器战争。</p><ul><li><p>1996.12 W3C 推出了 <strong>CSS</strong> 1.0 规范</p></li><li><p>1997.6 ECMA 以 JavaScript 语言为基础制定了 ECMAScript 1.0 标准规范</p></li><li><p>1999 W3C 发布 HTML 4.01 标准，同年微软推出用于<strong>异步数据传输</strong>的 ActiveX，随即各大浏览器厂商模仿实现了 XMLHttpRequest（AJAX 雏形）。</p></li></ul><p>第一次浏览器战争以 IE 浏览器完胜 Netscape 而结束，IE 开始统领浏览器市场，份额的最高峰达到 2002 年的 96%。</p><h4 id="动态页面的崛起"><a href="#动态页面的崛起" class="headerlink" title="动态页面的崛起"></a><strong>动态页面的崛起</strong></h4><p><strong>PHP</strong>（PHP：Hypertext Preprocessor）最初是由 Rasmus Lerdorf 在 1995 年开始开发的，PHP 的主要目标是允许网络开发人员快速编写动态页面。</p><p><strong>JSP</strong>（JavaServer Pages）是由 Sun 公司倡导和许多公司参与共同创建的一种使软件开发者可以响应客户端请求，从而动态生成 HTML、XML 或其他格式文档的 Web 网页的技术标准。JSP 技术是以 Java 语言为基础的。1999 年，JSP 1.2 规范随着 J2EE 1.2 发布。</p><p><strong>ASP</strong>（Active Server Pages）1.0 在 1996 年随着 IIS 3.0 而发布。2002 年，<a href="http://asp.net/">ASP.NET</a> 发布，用于替代 ASP。</p><p>随着这些动态服务器页面技术的出现，页面不再是静止的，页面可以获取服务器数据信息并不断更新。以 <strong>Google</strong> 为代表的搜索引擎以及各种论坛相继出现，使得 Web 充满了活力。</p><p>从 Web 诞生至 2005 年，一直处于<strong>后端重、前端轻</strong>的状态。</p><h4 id="AJAX-的流行"><a href="#AJAX-的流行" class="headerlink" title="AJAX 的流行"></a><strong>AJAX 的流行</strong></h4><p>在 Web 最初发展的阶段，前端页面要想获取后台信息需要刷新整个页面，这是很糟糕的用户体验。</p><ul><li>2005年2月，<strong>Ajax</strong>的概念由杰西·詹姆士·贾瑞特所提出。**<a href="https://zh.wikipedia.org/wiki/AJAX">AJAX</a><strong>即“</strong>Asynchronous JavaScript and XML**”（异步的<a href="https://zh.wikipedia.org/wiki/JavaScript">JavaScript</a>与<a href="https://zh.wikipedia.org/wiki/XML">XML</a>技术），指的是一套综合了多项技术的<a href="https://zh.wikipedia.org/wiki/%E7%80%8F%E8%A6%BD%E5%99%A8">浏览器</a>端<a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81">网页</a>开发技术。</li></ul><p>随着 AJAX 的流行，越来越多的网站使用 AJAX 动态获取数据，这使得动态网页内容变成可能，像 Facebook 这样的社交网络开始变得繁荣起来，前端一时间呈现出了欣欣向荣的局面。</p><p>AJAX 使得浏览器客户端可以更方便地向服务器发送数据信息，这促进了 Web 2.0 的发展。</p><ul><li>2006 <strong>XMLHttpRequest</strong> 被 W3C 正式纳入标准。</li></ul><h4 id="前端兼容性框架的出现"><a href="#前端兼容性框架的出现" class="headerlink" title="前端兼容性框架的出现"></a><strong>前端兼容性框架的出现</strong></h4><p>Firefox 于 2004 年 11 月首次发布，并且 9 个月内下载量超过 6000 万，获取了巨大的成功，IE 的主导地位首次受到了挑战。之后 Firefox 浏览器一路奋起直追，逐渐蚕食 IE 市场份额，这引发了第二次浏览器战争。</p><p>第二次浏览器战争中，随着以 Firefox 和 Opera 为首的 W3C 阵营与 IE 对抗程度的加剧，浏览器碎片化问题越来越严重，不同的浏览器执行不同的标准，对于开发人员来说这是一个恶梦。</p><p>为了解决浏览器兼容性问题，Dojo、jQuery、YUI、ExtJS、MooTools 等前端 Framework 相继诞生。前端开发人员用这些 Framework 频繁发送 AJAX 请求到后台，在得到数据后，再用这些 Framework 更新 DOM 树。</p><p>其中，<strong>jQuery</strong> 独领风骚，几乎成了所有网站的标配。Dojo、YUI、ExtJS 等提供了很多组件，这使得开发复杂的企业级 Web 应用成为可能。</p><h4 id="HTML-5"><a href="#HTML-5" class="headerlink" title="HTML 5"></a><strong>HTML 5</strong></h4><p>1999年，W3C发布了 HTML 4.01 版本，在之后的几年，没有再发布更新的 Web 标准。随着Web的迅猛发展，旧的Web标准已不能满足 Web 应用的快速增长。</p><p>2004 年 6 月，Mozilla 基金会和 Opera 软件公司在万维网联盟（W3C）所主办的研讨会上提出了一份联合建议书，其中包括 Web Forms 2.0 的初步规范草案。建议举行一次投票，以表决 W3C 是否应该扩展 HTML 和 DOM，从而满足 Web 应用中的新需求。研讨会最后以 8 票赞成，14 票反对否决此建议，这引起一些人的不满，不久后，部分浏览器厂商宣布成立网页超文本技术工作小组（WHATWG），以继续推动该规范的开发工作，该组织再度提出 Web Applications 1.0 规范草案，后来这两种规范合并形成 <strong>HTML5</strong>。2007 年，获得 W3C 接纳，并成立了新的 HTML 工作团队。2008 年 1 月 22 日，第一份正式草案发布。</p><ul><li>2008.12 <strong>Chrome</strong> 发布，JavaScript 引擎 V8。</li></ul><p>HTML5 草案发布不久，Google 在 2008 年 12 月发布了 Chrome 浏览器，加入了第二次浏览器大战当中。Chrome 使用了 Safari 开源的 WebKit 作为布局引擎，并且研发了高效的 JavaScript 引擎 V8。</p><p>在第二次浏览器大战中，各个浏览器厂商都以提升 JavaScript 运行效率和支持 HTML5 各种新特性为主要目标，促进了浏览器的良性竞争。在这一场战争中，Chrome 攻城略地，抢夺 IE 市场份额。2013 年，Chrome 超过 IE，成为市场份额最高的浏览器。2016 年，Chrome 占据了浏览器市场的半壁江山。</p><p>自 2008 年以来，浏览器中不断支持的 HTML5 新特性让开发者激动不已：WebWorker 可以让 JavaScript 运行在多线程中，WebSocket 可以实现前端与后台的双工通信，WebGL 可以创建 Web3D 网页游戏…</p><ul><li>2012.10 微软发布 <strong>TypeScript</strong> 公开版</li></ul><p>TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。</p><p>TypeScript 扩展了 JavaScript 的语法，所以任何现有的 JavaScript 程序可以不加改变的在 TypeScript 下工作。TypeScript 是为大型应用之开发而设计，而编译时它产生 JavaScript 以确保兼容性。</p><ul><li>2013.6.19 TypeScript 0.9 正式版</li><li>2014.10.28 W3C 正式发布 <strong>HTML 5.0</strong> 推荐标准</li></ul><h4 id="Node-js-的爆发"><a href="#Node-js-的爆发" class="headerlink" title="Node.js 的爆发"></a><strong>Node.js 的爆发</strong></h4><p>2008 年 Chrome 发布，其 JavaScript 引擎 V8 的高效执行引起了 Ryan Dahl 的注意。2009 年，Ryan 利用 Chrome 的 V8 引擎打造了基于<strong>事件循环的异步 I/O 框架</strong> —— <strong>Node.js</strong> 诞生。</p><p>Node.js 具有以下特点：</p><ul><li>基于事件循环的异步 I/O 框架，能够提高 I/O 吞吐量</li><li>单线程运行，能够避免了多线程变量同步的问题</li><li>使得 JavaScript 可以编写后台代码，前后端编程语言统一。</li><li>Node.js 的出现吸引了很多前端开发人员开始用 JavaScript 开发服务器代码，其异步编程风格也深受开发人员的喜爱。Node.js 的伟大不仅在于拓展了 JavaScript 在服务器端的无限可能，更重要的是它构建了一个庞大的生态系统。</li></ul><p>2010 年 1 月，<strong>NPM</strong> 作为 Node.js 的包管理系统首次发布。开发人员可以按照 CommonJS 的规范编写 Node.js 模块，然后将其发布到 NPM 上面供其他开发人员使用。目前 NPM 具有 40 万左右的模块，是世界上最大的包模块管理系统。</p><h4 id="前端-MV-架构"><a href="#前端-MV-架构" class="headerlink" title="*前端 MV 架构**"></a>*<em>前端 MV</em> 架构**</h4><p>随着 HTML5 的流行，前端不再是人们眼中的小玩意，以前在 C/S 中实现的桌面软件的功能逐步迁移到了前端，前端的代码逻辑逐渐变得复杂起来。</p><p>以前只用于后台的 MV* 等架构在前端逐渐使用起来，以下列举了部分常用的 MV* 框架。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/20180413121849687" alt="这里写图片描述"></p><p>随着这些 MV* 框架的出现，网页逐渐由 Web Site 演变成了 Web App，最终导致了复杂的单页应用（ Single Page Application）的出现。</p><h4 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a><strong>ECMAScript 6</strong></h4><p>1997 年 6 月， ECMAScript 1.0 标准发布。</p><p>1998 年 6 月，ECMAScript 2.0 发布。</p><p>1999 年 12 月，ECMAScript 3.0 发布。</p><p>2007 年 10 月，Mozilla 主张的 ECMAScript 4.0 版草案发布，对 3.0 版做了大幅升级，该草案遭到了以 Yahoo、Microsoft、Google 为首的大公司的强烈反对，JavaScript 语言的创造者 Brendan Eich 和 IE 架构师 Chris Wilson 甚至在博客上就ES4向后兼容性问题打起了口水仗，最后由于各方分歧太大，ECMA 开会决定废弃中止 ECMAScript 4.0 草案。经各方妥协，在保证向下兼容的情况下，将部分增强的功能放到 ECMAScript 3.1 标准中，将原有 ECMAScript 4.0 草案中激进的功能放到以后的标准中。不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p><p>2009 年 12 月，本着’Don’t break the web’原则，<strong>ECMAScript 5</strong> 发布。新增了 strict 模式、属性 getter 和 setter 等。</p><p>2011 年 6 月，ECMAScript 5.1 发布。</p><p>2015 年 6 月，<strong>ECMAScript 6.0</strong> 发布。该版本增加了许多新的语法，包括支持 let、const、Arrow function、Class、Module、Promise、Iterator、Generator、Set、Map、async、Symbol、Proxy、Reflect、Decorator 等。TC39 委员会计划以后每年都发布一个新版本的 ECMAScript，所以 ECMAScript 6.0 改名为 ECMAScript 2015。</p><p>2016 年 6 月，在 ECMAScript 2015 的基础上进行了部分增强，发布了 ECMAScript 2016。</p><p>在 ECMAScript 的各个版本中，ECMAScript 6.0 无疑最受人瞩目的，它增加了许多新特性，极大拓展了 JavaScript 语法和能力，以至于许多浏览器都只能支持部分 ES6 中的新特性。随之，Babel 和 TypeScript 逐渐流行起来，编写 ES6 代码，然后用 Babel 或 TypeScript 将其编译为 ES5 等浏览器支持的 JavaScript。</p><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p>本文参考引用了 <a href="https://blog.csdn.net/freekiteyu/article/details/79927047">前端发展简史</a> 以及 <a href="https://zh.wikipedia.org/wiki">维基百科</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;​    无论是在生产或者学习中，我们后端开发人员（以下简称为后端仔），总是离不开和前端打交道，甚至在某些迫不得已的时候，我们也需要挺身而出</summary>
      
    
    
    
    <category term="后端仔写前端系列" scheme="http://zhoushing.github.io/categories/%E5%90%8E%E7%AB%AF%E4%BB%94%E5%86%99%E5%89%8D%E7%AB%AF%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="前端" scheme="http://zhoushing.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的最近公共祖先</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html</id>
    <published>2021-11-21T09:11:43.000Z</published>
    <updated>2021-11-21T09:18:34.139Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-236-二叉树的最近公共祖先"><a href="#力扣-236-二叉树的最近公共祖先" class="headerlink" title="力扣 236. 二叉树的最近公共祖先"></a>力扣 <a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p><p>百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”</p><p><strong>提示：</strong></p><ul><li>树中节点数目在范围 [2, 10^5] 内。</li><li>-10^9 &lt;= Node.val &lt;= 10^9</li><li>所有 Node.val 互不相同 。</li><li>p != q</li><li>p 和 q 均存在于给定的二叉树中。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1</span><br><span class="line">输出：3</span><br><span class="line">解释：节点 5 和节点 1 的最近公共祖先是节点 3 。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/binarytree.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4</span><br><span class="line">输出：5</span><br><span class="line">解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], p = 1, q = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道二叉树算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>我们可以通过分别判断左支右支包含目标两个节点的情况来判断公共祖宗节点的位置</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前根节点等于其中一个节点，直接得出当前节点是最近公共祖先节点</span></span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span> || root == p || root == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (left != <span class="keyword">null</span> &amp;&amp; right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果两个节点都在左支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 都在右支</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121171647061.png" alt="image-20211121171647061"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-236-二叉树的最近公共祖先&quot;&gt;&lt;a href=&quot;#力扣-236-二叉树的最近公共祖先&quot; class=&quot;headerlink&quot; title=&quot;力扣 236. 二叉树的最近公共祖先&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.co</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="二叉树" scheme="http://zhoushing.github.io/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>寻找重复数</title>
    <link href="http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html"/>
    <id>http://zhoushing.github.io/2021-11-21-%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E6%95%B0.html</id>
    <published>2021-11-21T09:05:22.000Z</published>
    <updated>2021-11-21T09:11:13.940Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-287-寻找重复数"><a href="#力扣-287-寻找重复数" class="headerlink" title="力扣 287. 寻找重复数"></a>力扣 <a href="https://leetcode-cn.com/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给定一个包含 n + 1 个整数的数组 nums ，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。</p><p>假设 nums 只有 一个重复的整数 ，找出 这个重复的数 。</p><p>你设计的解决方案必须不修改数组 nums 且只用常量级 O(1) 的额外空间。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= n &lt;= 10^5</li><li>nums.length == n + 1</li><li>1 &lt;= nums[i] &lt;= n</li><li>nums 中 只有一个整数 出现 两次或多次 ，其余整数均只出现 一次</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,4,2,2]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,1,3,4,2]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p><strong>示例 4:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现题目要求的是至少出现一个，所以就不能使用位运算了，这里可以将这个数组看成循环数组，然后使用快慢指针求解</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 将出现重复元素的数组看成环，用快慢指针来查找重复出现的那个节点</span></span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> fast = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast || fast == <span class="number">0</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[slow] != nums[fast]) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums[slow];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211121170916265.png" alt="image-20211121170916265"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-287-寻找重复数&quot;&gt;&lt;a href=&quot;#力扣-287-寻找重复数&quot; class=&quot;headerlink&quot; title=&quot;力扣 287. 寻找重复数&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/find</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="http://zhoushing.github.io/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>最长和谐子序列</title>
    <link href="http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html"/>
    <id>http://zhoushing.github.io/2021-11-20-%E6%9C%80%E9%95%BF%E5%92%8C%E8%B0%90%E5%AD%90%E5%BA%8F%E5%88%97.html</id>
    <published>2021-11-20T09:35:00.000Z</published>
    <updated>2021-11-20T09:39:48.789Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-594-最长和谐子序列"><a href="#力扣-594-最长和谐子序列" class="headerlink" title="力扣 594. 最长和谐子序列"></a>力扣 <a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/">594. 最长和谐子序列</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。</p><p>现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。</p><p>数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,2,2,5,2,3,7]</span><br><span class="line">输出：5</span><br><span class="line">解释：最长的和谐子序列是 [3,2,2,2,3]</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道数组算法问题，在力扣题库中被定义为简单题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>发现因为本题不要求是子数组，所以可以直接对元素进行统计</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数组</span></span><br><span class="line"><span class="comment">     * HashMap</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findLHS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 记录每个元素出现的频次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">            map.put(i, map.getOrDefault(i, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry: map.entrySet()) &#123;</span><br><span class="line">            <span class="keyword">int</span> key = entry.getKey();</span><br><span class="line">            <span class="keyword">int</span> value = entry.getValue();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> sub = map.getOrDefault(key - <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">int</span> add = map.getOrDefault(key + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加一减一的数都没出现过就跳过</span></span><br><span class="line">            <span class="keyword">if</span> (sub == -<span class="number">1</span> &amp;&amp; add == -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            result = Math.max(result, value + Math.max(sub, add));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211120173839981.png" alt="image-20211120173839981"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为简单，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-594-最长和谐子序列&quot;&gt;&lt;a href=&quot;#力扣-594-最长和谐子序列&quot; class=&quot;headerlink&quot; title=&quot;力扣 594. 最长和谐子序列&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problem</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="数组" scheme="http://zhoushing.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="HashMap" scheme="http://zhoushing.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>单词拆分</title>
    <link href="http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html"/>
    <id>http://zhoushing.github.io/2021-11-18-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86.html</id>
    <published>2021-11-18T13:44:22.000Z</published>
    <updated>2021-11-18T14:04:32.925Z</updated>
    
    <content type="html"><![CDATA[<h2 id="力扣-139-单词拆分"><a href="#力扣-139-单词拆分" class="headerlink" title="力扣 139. 单词拆分"></a>力扣 <a href="https://leetcode-cn.com/problems/word-break/">139. 单词拆分</a></h2><h3 id="题目说明"><a href="#题目说明" class="headerlink" title="题目说明"></a>题目说明</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典，判定 s 是否可以由空格拆分为一个或多个在字典中出现的单词。</p><p>说明：拆分时可以重复使用字典中的单词。</p><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 300</li><li>1 &lt;= wordDict.length &lt;= 1000</li><li>1 &lt;= wordDict[i].length &lt;= 20</li><li>s 和 wordDict[i] 仅有小写英文字母组成</li><li>wordDict 中的所有字符串 互不相同</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]</span><br><span class="line">输出: true</span><br><span class="line">解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。</span><br><span class="line">     注意你可以重复使用字典中的单词。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><h3 id="笔者理解"><a href="#笔者理解" class="headerlink" title="笔者理解"></a>笔者理解</h3><p>此题是一道字符串算法问题，在力扣题库中被定义为中等题。 </p><h4 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h4><p>当笔者阅读完此题后，<strong>需要注意题目中要求源字符串的匹配方式，在这里我们采取向后遍历所有字符串可能的方式，采用动态规划向后记录的方式</strong>，让我们来看看具体如何实现的吧。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字符串</span></span><br><span class="line"><span class="comment">     * 动态规划</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span>[] ticks = <span class="keyword">new</span> <span class="keyword">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 0 代表空串都是匹配的</span></span><br><span class="line">        ticks[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 直接逐长度匹配字典，通过动态规划来向后传递组合的可能性</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ticks[j] &amp;&amp; wordDict.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    ticks[i] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ticks[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间和空间效率还行，可见此解法还比较适合此题。</p><p><img src="https://pool-1305119010.cos.ap-nanjing.myqcloud.com/images/image-20211118214949077.png" alt="image-20211118214949077"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本题是今天的一题，难度是为中等，感兴趣的朋友都可以去尝试一下，此题还有其他更多的解法，朋友们可以自己逐一尝试。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;力扣-139-单词拆分&quot;&gt;&lt;a href=&quot;#力扣-139-单词拆分&quot; class=&quot;headerlink&quot; title=&quot;力扣 139. 单词拆分&quot;&gt;&lt;/a&gt;力扣 &lt;a href=&quot;https://leetcode-cn.com/problems/word-br</summary>
      
    
    
    
    
    <category term="java" scheme="http://zhoushing.github.io/tags/java/"/>
    
    <category term="动态规划" scheme="http://zhoushing.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="字符串" scheme="http://zhoushing.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
</feed>
